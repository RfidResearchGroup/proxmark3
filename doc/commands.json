{
    "metadata": {
        "extracted_by": "PM3Help2JSON v1.00",
        "extracted_on": "2021-05-30T01:19:33",
        "commands_extracted": 550
    },
    "commands": {
        "help": {
            "command": "help",
            "offline": true,
            "description": "help use `<command> help` for details of a command prefs { edit client/device preferences... } -------- ----------------------- technology ----------------------- analyse { analyse utils... } data { plot window / data buffer manipulation... } emv { emv iso-14443 / iso-7816... } hf { high frequency commands... } hw { hardware commands... } lf { low frequency commands... } reveng { crc calculations from reveng software... } smart { smart card iso-7816 commands... } script { scripting commands... } trace { trace manipulation... } wiegand { wiegand format manipulation... } -------- ----------------------- general ----------------------- clear clear screen hints turn hints on / off msleep add a pause in milliseconds rem add a text line in log file quit exit exit program [=] session log /home/ant.amazon.com/samwin/.proxmark3/logs/log_20210530.txt --------------------------------------------------------------------------------------- auto available offline: no run lf search / hf search / data plot / data save",
            "usage": "auto [-hc]",
            "options": [
                "-h, --help this help",
                "-c continue searching even after a first hit"
            ],
            "notes": [
                "auto"
            ]
        },
        "clear": {
            "command": "clear",
            "offline": true,
            "description": "clear the proxmark3 client terminal screen",
            "usage": "clear [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "clear"
            ]
        },
        "hints": {
            "command": "hints",
            "offline": true,
            "description": "turn on/off hints",
            "usage": "hints [-h10]",
            "options": [
                "-h, --help this help",
                "-1, --on turn on hints",
                "-0, --off turn off hints"
            ],
            "notes": [
                "hints --on",
                "hints -1"
            ]
        },
        "msleep": {
            "command": "msleep",
            "offline": true,
            "description": "sleep for given amount of milliseconds",
            "usage": "msleep [-h] [-t <ms>]",
            "options": [
                "-h, --help this help",
                "-t, --ms <ms> time in milliseconds"
            ],
            "notes": [
                "msleep 100"
            ]
        },
        "rem": {
            "command": "rem",
            "offline": true,
            "description": "add a text line in log file",
            "usage": "rem [-h] <string> [<string>]...",
            "options": [
                "-h, --help this help",
                "<string> message line you want inserted"
            ],
            "notes": [
                "rem my message -> adds a timestamp with `my message`"
            ]
        },
        "quit": {
            "command": "quit",
            "offline": true,
            "description": "quit the proxmark3 client terminal",
            "usage": "quit [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "quit"
            ]
        },
        "exit": {
            "command": "exit",
            "offline": true,
            "description": "quit the proxmark3 client terminal",
            "usage": "quit [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "quit"
            ]
        },
        "prefs help": {
            "command": "prefs help",
            "offline": true,
            "description": "help this help get { get a preference } set { set a preference } show show all preferences --------------------------------------------------------------------------------------- prefs show available offline: yes show all persistent preferences",
            "usage": "prefs show [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs show"
            ]
        },
        "prefs get barmode": {
            "command": "prefs get barmode",
            "offline": true,
            "description": "get preference of hf/lf tune command styled output in the client",
            "usage": "prefs get barmode [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs get barmode"
            ]
        },
        "prefs get clientdebug": {
            "command": "prefs get clientdebug",
            "offline": true,
            "description": "get preference of using clientside debug level",
            "usage": "prefs get clientdebug [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs get clientdebug"
            ]
        },
        "prefs get color": {
            "command": "prefs get color",
            "offline": true,
            "description": "get preference of using colors in the client",
            "usage": "prefs get color [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs get color"
            ]
        },
        "prefs get savepaths": {
            "command": "prefs get savepaths",
            "offline": true,
            "description": "get preference of file paths in the client",
            "usage": "prefs get savepaths [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs get savepaths"
            ]
        },
        "prefs get emoji": {
            "command": "prefs get emoji",
            "offline": true,
            "description": "get preference of using emojis in the client",
            "usage": "prefs get emoji [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs get emoji"
            ]
        },
        "prefs get hints": {
            "command": "prefs get hints",
            "offline": true,
            "description": "get preference of showing hint messages in the client",
            "usage": "prefs get hints [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs get hints"
            ]
        },
        "prefs get plotsliders": {
            "command": "prefs get plotsliders",
            "offline": true,
            "description": "get preference of showing the plotslider control in the client",
            "usage": "prefs get plotsliders [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "prefs get plotsliders"
            ]
        },
        "prefs set help": {
            "command": "prefs set help",
            "offline": true,
            "description": "help this help barmode set bar mode clientdebug set client debug level color set color support emoji set emoji display hints set hint display savepaths ... to be adjusted next ... plotsliders set plot slider display --------------------------------------------------------------------------------------- prefs set barmode available offline: yes set presistent preference of hf/lf tune command styled output in the client",
            "usage": "prefs set barmode [-h] [--bar] [--mix] [--val]",
            "options": [
                "-h, --help this help",
                "--bar measured values as bar only",
                "--mix measured values as numbers and bar",
                "--val measured values only"
            ],
            "notes": [
                "prefs set barmode --mix"
            ]
        },
        "prefs set clientdebug": {
            "command": "prefs set clientdebug",
            "offline": true,
            "description": "set presistent preference of using clientside debug level",
            "usage": "prefs set clientdebug [-h] [--off] [--simple] [--full]",
            "options": [
                "-h, --help this help",
                "--off no debug messages",
                "--simple simple debug messages",
                "--full full debug messages"
            ],
            "notes": [
                "prefs set clientdebug --simple"
            ]
        },
        "prefs set color": {
            "command": "prefs set color",
            "offline": true,
            "description": "set presistent preference of using colors in the client",
            "usage": "prefs set color [-h] [--ansi] [--off]",
            "options": [
                "-h, --help this help",
                "--ansi use ansi colors",
                "--off don't use colors"
            ],
            "notes": [
                "prefs set color --ansi"
            ]
        },
        "prefs set emoji": {
            "command": "prefs set emoji",
            "offline": true,
            "description": "set presistent preference of using emojis in the client",
            "usage": "prefs set emoji [-h] [--alias] [--emoji] [--alttext] [--none]",
            "options": [
                "-h, --help this help",
                "--alias show alias for emoji",
                "--emoji show emoji",
                "--alttext show alt text for emoji",
                "--none don't show emoji or text"
            ],
            "notes": [
                "prefs set emoji --alias"
            ]
        },
        "prefs set hints": {
            "command": "prefs set hints",
            "offline": true,
            "description": "set presistent preference of showing hint messages in the client",
            "usage": "prefs set hints [-h] [--off] [--on]",
            "options": [
                "-h, --help this help",
                "--off hide hints",
                "--on show hints"
            ],
            "notes": [
                "prefs set hints --on"
            ]
        },
        "prefs set savepaths": {
            "command": "prefs set savepaths",
            "offline": true,
            "description": "set presistent preference of file paths in the client",
            "usage": "prefs set savepaths [-hc] [--def <path>] [--dump <path>] [--trace <path>]",
            "options": [
                "-h, --help this help",
                "-c, --create create directory if it does not exist",
                "--def <path> default path",
                "--dump <path> dump file path",
                "--trace <path> trace path"
            ],
            "notes": [
                "prefs set savepaths --dump /home/mydumpfolder -> all dump files will be saved into this folder",
                "prefs set savepaths --def /home/myfolder -c -> create if needed, all files will be saved into this folder"
            ]
        },
        "prefs set plotsliders": {
            "command": "prefs set plotsliders",
            "offline": true,
            "description": "set presistent preference of showing the plotslider control in the client",
            "usage": "prefs set plotsliders [-h] [--off] [--on]",
            "options": [
                "-h, --help this help",
                "--off hide plot slider controls",
                "--on show plot slider controls"
            ],
            "notes": [
                "prefs set plotsliders --on"
            ]
        },
        "analyse help": {
            "command": "analyse help",
            "offline": true,
            "description": "help this help lcr generate final byte for xor lrc crc stub method for crc evaluations chksum checksum with adding, masking and one's complement dates look for datestamps in a given array of bytes tea crypto tea test lfsr lfsr tests a num bits test nuid create nuid from 7byte uid demodbuff load binary string to demodbuffer freq calc wave lengths foo muxer units convert etu <> us <> ssp_clk (3.39mhz) --------------------------------------------------------------------------------------- analyse lcr available offline: yes specifying the bytes of a uid with a known lrc will find the last byte value needed to generate that lrc with a rolling xor. all bytes should be specified in hex.",
            "usage": "analyse lcr [-h] -d <hex>",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to calc missing xor in a lcr"
            ],
            "notes": [
                "analyse lcr -d 04008064ba -> target (ba) requires final lrc xor byte value: 5a"
            ]
        },
        "analyse crc": {
            "command": "analyse crc",
            "offline": true,
            "description": "a stub method to test different crc implementations inside the pm3 sourcecode. just because you figured out the poly, doesn't mean you get the desired output",
            "usage": "analyse crc [-h] -d <hex>",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to calc crc"
            ],
            "notes": [
                "analyse crc -d 137af00a0a0d"
            ]
        },
        "analyse chksum": {
            "command": "analyse chksum",
            "offline": true,
            "description": "the bytes will be added with eachother and than limited with the applied mask finally compute ones' complement of the least significant bytes.",
            "usage": "analyse chksum [-hv] -d <hex> [-m <hex>]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to calc checksum",
                "-m, --mask <hex> bit mask to limit the output (4 hex bytes max)",
                "-v, --verbose verbose"
            ],
            "notes": [
                "analyse chksum -d 137af00a0a0d -> expected output: 0x61",
                "analyse chksum -d 137af00a0a0d -m ff"
            ]
        },
        "analyse dates": {
            "command": "analyse dates",
            "offline": true,
            "description": "tool to look for date/time stamps in a given array of bytes",
            "usage": "analyse dates [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "analyse dates"
            ]
        },
        "analyse tea": {
            "command": "analyse tea",
            "offline": true,
            "description": "crypto tea self tests",
            "usage": "analyse tea [-h] -d <hex>",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to encrypt ( 8 hex bytes )"
            ],
            "notes": [
                "analyse tea -d 1122334455667788"
            ]
        },
        "analyse lfsr": {
            "command": "analyse lfsr",
            "offline": true,
            "description": "looks at legic prime's lfsr, iterates the first 48 values",
            "usage": "analyse lfsr [-h] --iv <hex> [--find <hex>]",
            "options": [
                "-h, --help this help",
                "--iv <hex> init vector data (1 hex byte)",
                "--find <hex> lfsr data to find (1 hex byte)"
            ],
            "notes": [
                "analyse lfsr --iv 55"
            ]
        },
        "analyse a": {
            "command": "analyse a",
            "offline": true,
            "description": "iceman's personal garbage test command",
            "usage": "analyse a [-h] -d <hex>",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to manipulate"
            ],
            "notes": [
                "analyse a -d 137af00a0a0d"
            ]
        },
        "analyse nuid": {
            "command": "analyse nuid",
            "offline": true,
            "description": "generate 4byte nuid from 7byte uid",
            "usage": "analyse nuid [-ht] [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to send",
                "-t, --test self test"
            ],
            "notes": [
                "analyse nuid -d 11223344556677"
            ]
        },
        "analyse demodbuff": {
            "command": "analyse demodbuff",
            "offline": true,
            "description": "loads a binary string into demod buffer",
            "usage": "analyse demodbuff [-h] -d <bin>",
            "options": [
                "-h, --help this help",
                "-d, --data <bin> binary string to load"
            ],
            "notes": [
                "analyse demodbuff -d 0011101001001011"
            ]
        },
        "analyse freq": {
            "command": "analyse freq",
            "offline": true,
            "description": "calc wave lengths",
            "usage": "analyse freq [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "analyse freq"
            ]
        },
        "analyse foo": {
            "command": "analyse foo",
            "offline": true,
            "description": "experiments of cliparse",
            "usage": "analyse foo [-h] [-r <hex>]...",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw bytes (strx)"
            ],
            "notes": [
                "analyse foo -r a0000000a0002021"
            ]
        },
        "analyse units": {
            "command": "analyse units",
            "offline": true,
            "description": "experiments of unit conversions found in hf. etu (1/13.56mhz), us or ssp_clk (1/3.39mhz)",
            "usage": "analyse units [-h] [--etu <dec>] [--us <dec>]",
            "options": [
                "-h, --help this help",
                "--etu <dec> number in etu",
                "--us <dec> number in micro seconds (us)"
            ],
            "notes": [
                "analyse uints --etu 10analyse uints --us 100"
            ]
        },
        "data help": {
            "command": "data help",
            "offline": true,
            "description": "help this help ----------- ------------------------- modulation------------------------- biphaserawdecode biphase decode bin stream in demodbuffer detectclock detect ask, fsk, nrz, psk clock rate of wave in graphbuffer fsktonrz convert fsk2 to nrz wave for alternate fsk demodulating (for weak fsk) manrawdecode manchester decode binary stream in demodbuffer modulation identify lf signal for clock and modulation rawdemod demodulate the data in the graphbuffer and output binary ----------- ------------------------- graph------------------------- askedgedetect adjust graph for manual ask demod using the length of sample differences to detect the edge of a wave autocorr autocorrelation over window dirthreshold max rising higher up-thres/ min falling lower down-thres, keep rest as prev. decimate decimate samples undecimate un-decimate samples hide hide graph window hpf remove dc offset from trace iir apply iir buttersworth filter on plot data grid overlay grid on graph window ltrim trim samples from left of trace mtrim trim out samples from the specified start to the specified stop norm normalize max/min to +/-128 plot show graph window rtrim trim samples from right of trace setgraphmarkers set blue and orange marker in graph window shiftgraphzero shift 0 for graphed wave + or - shift value timescale set a timescale to get a differential reading between the yellow and purple markers as time duration zerocrossings count time between zero-crossings convertbitstream convert graphbuffer's 0/1 values to 127 / -127 getbitstream convert graphbuffer's >=1 values to 1 and <1 to 0 ----------- ------------------------- general------------------------- bin2hex converts binary to hexadecimal clear clears bigbuf on deviceside and graph window hex2bin converts hexadecimal to binary load load contents of file into graph window ndef decode ndef records print print the data in the demodbuffer save save signal trace data (from graph window) setdebugmode set debugging level on client side --------------------------------------------------------------------------------------- data biphaserawdecode available offline: yes biphase decode binary stream in demodbuffer converts 10 or 01 -> 1 and 11 or 00 -> 0 - must have binary sequence in demodbuffer (run `data rawdemod --ar` before) - invert for conditional dephase encoding (cdp) aka differential manchester",
            "usage": "data biphaserawdecode [-hoi] [--err <dec>]",
            "options": [
                "-h, --help this help",
                "-o, --offset set to adjust decode start position",
                "-i, --inv invert output",
                "--err <dec> set max errors tolerated (def 20)"
            ],
            "notes": [
                "data biphaserawdecode -> decode biphase bitstream from the demodbuffer",
                "data biphaserawdecode -oi -> decode biphase bitstream from the demodbuffer, adjust offset, and invert output"
            ]
        },
        "data detectclock": {
            "command": "data detectclock",
            "offline": true,
            "description": "detect ask, fsk, nrz, psk clock rate of wave in graphbuffer",
            "usage": "data detectclock [-hafnp]",
            "options": [
                "-h, --help this help",
                "-a, --ask specify ask modulation clock detection",
                "-f, --fsk specify fsk modulation clock detection",
                "-n, --nzr specify nzr/direct modulation clock detection",
                "-p, --psk specify psk modulation clock detection"
            ],
            "notes": [
                "data detectclock -a -> detect clock of an ask wave in graphbuffer",
                "data detectclock -f -> detect clock of an fsk wave in graphbuffer",
                "data detectclock -n -> detect clock of an psk wave in graphbuffer",
                "data detectclock -p -> detect clock of an nrz/direct wave in graphbuffer"
            ]
        },
        "data fsktonrz": {
            "command": "data fsktonrz",
            "offline": true,
            "description": "convert fsk2 to nrz wave for alternate fsk demodulating (for weak fsk) omitted values are autodetect instead",
            "usage": "data fsktonrz [-h] [-c <dec>] [--low <dec>] [--hi <dec>]",
            "options": [
                "-h, --help this help",
                "-c, --clk <dec> clock",
                "--low <dec> low field clock",
                "--hi <dec> high field clock"
            ],
            "notes": [
                "data fsktonrz",
                "data fsktonrz -c 32 --low 8 --hi 10"
            ]
        },
        "data manrawdecode": {
            "command": "data manrawdecode",
            "offline": true,
            "description": "manchester decode binary stream in demodbuffer converts 10 and 01 and converts to 0 and 1 respectively - must have binary sequence in demodbuffer (run `data rawdemod --ar` before)",
            "usage": "data manrawdecode [-hi] [--err <dec>]",
            "options": [
                "-h, --help this help",
                "-i, --inv invert output",
                "--err <dec> set max errors tolerated (def 20)"
            ],
            "notes": [
                "data manrawdecode"
            ]
        },
        "data modulation": {
            "command": "data modulation",
            "offline": true,
            "description": "search lf signal after clock and modulation",
            "usage": "data modulation [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data modulation"
            ]
        },
        "data rawdemod": {
            "command": "data rawdemod",
            "offline": true,
            "description": "demodulate the data in the graphbuffer and output binary",
            "usage": "data rawdemod [-h] [--ab] [--am] [--ar] [--fs] [--nr] [--p1] [--p2] [<params>]...",
            "options": [
                "-h, --help this help",
                "--ab ask/biphase demodulation",
                "--am ask/manchester demodulation",
                "--ar ask/raw demodulation",
                "--fs fsk demodulation",
                "--nr nrz/direct demodulation",
                "--p1 psk 1 demodulation",
                "--p2 psk 2 demodulation",
                "<params> params for sub command"
            ],
            "notes": [
                "data rawdemod --fs -> demod fsk - autodetect",
                "data rawdemod --ab -> demod ask/biphase - autodetect",
                "data rawdemod --am -> demod ask/manchester - autodetect",
                "data rawdemod --ar -> demod ask/raw - autodetect",
                "data rawdemod --nr -> demod nrz/direct - autodetect",
                "data rawdemod --p1 -> demod psk1 - autodetect",
                "data rawdemod --p2 -> demod psk2 - autodetect"
            ]
        },
        "data askedgedetect": {
            "command": "data askedgedetect",
            "offline": true,
            "description": "adjust graph for manual ask demod using the length of sample differences to detect the edge of a wave",
            "usage": "data askedgedetect [-h] [-t <dec>]",
            "options": [
                "-h, --help this help",
                "-t, --thres <dec> threshold, use 20 - 45 (def 25)"
            ],
            "notes": [
                "data askedgedetect -t 20"
            ]
        },
        "data autocorr": {
            "command": "data autocorr",
            "offline": true,
            "description": "autocorrelate over window is used to detect repeating sequences. we use it as detection of how long in bits a message inside the signal is",
            "usage": "data autocorr [-hg] [-w <dec>]",
            "options": [
                "-h, --help this help",
                "-g save back to graphbuffer (overwrite)",
                "-w, --win <dec> window length for correlation. def 4000"
            ],
            "notes": [
                "data autocorr -w 4000",
                "data autocorr -w 4000 -g"
            ]
        },
        "data dirthreshold": {
            "command": "data dirthreshold",
            "offline": true,
            "description": "max rising higher up-thres/ min falling lower down-thres, keep rest as prev.",
            "usage": "data dirthreshold [-h] -d <dec> -u <dec>",
            "options": [
                "-h, --help this help",
                "-d, --down <dec> threshold down",
                "-u, --up <dec> threshold up"
            ],
            "notes": [
                "data dirthreshold -u 10 -d -10"
            ]
        },
        "data decimate": {
            "command": "data decimate",
            "offline": true,
            "description": "performs decimation, by reducing samples n times in the grapbuf. good for psk",
            "usage": "data decimate [-h] [-n <dec>]",
            "options": [
                "-h, --help this help",
                "-n <dec> factor to reduce sample set (default 2)"
            ],
            "notes": [
                "data decimate",
                "data decimate -n 4"
            ]
        },
        "data undecimate": {
            "command": "data undecimate",
            "offline": true,
            "description": "performs un-decimation, by repeating each sample n times in the graphbuf",
            "usage": "data undecimate [-h] [-n <dec>]",
            "options": [
                "-h, --help this help",
                "-n <dec> factor to repeat each sample (default 2)"
            ],
            "notes": [
                "data undecimate",
                "data undecimate -n 4"
            ]
        },
        "data hide": {
            "command": "data hide",
            "offline": true,
            "description": "show graph window",
            "usage": "data hide [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data hide"
            ]
        },
        "data hpf": {
            "command": "data hpf",
            "offline": true,
            "description": "remove dc offset from trace. it should centralize around 0",
            "usage": "data hpf [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data hpf"
            ]
        },
        "data iir": {
            "command": "data iir",
            "offline": true,
            "description": "apply iir buttersworth filter on plot data",
            "usage": "data iir [-h] -n <dec>",
            "options": [
                "-h, --help this help",
                "-n <dec> factor n"
            ],
            "notes": [
                "data iir -n 2"
            ]
        },
        "data grid": {
            "command": "data grid",
            "offline": true,
            "description": "this function overlay grid on graph plot window. use zero value to turn off either",
            "usage": "data grid [-h] [-x <dec>] [-y <dec>]",
            "options": [
                "-h, --help this help",
                "-x <dec> plot grid x coord",
                "-y <dec> plot grid y coord"
            ],
            "notes": [
                "data grid -> turn off",
                "data grid -x 64 -y 50"
            ]
        },
        "data ltrim": {
            "command": "data ltrim",
            "offline": true,
            "description": "trim samples from left of trace",
            "usage": "data ltrim [-h] -i <dec>",
            "options": [
                "-h, --help this help",
                "-i, --idx <dec> from index to beginning trace"
            ],
            "notes": [
                "data ltrim -i 300 -> keep 300 - end"
            ]
        },
        "data mtrim": {
            "command": "data mtrim",
            "offline": true,
            "description": "trim out samples from the specified start to the specified end point",
            "usage": "data mtrim [-h] -s <dec> -e <dec>",
            "options": [
                "-h, --help this help",
                "-s, --start <dec> start point",
                "-e, --end <dec> end point"
            ],
            "notes": [
                "data mtrim -s 1000 -e 2000 -> keep between 1000 and 2000"
            ]
        },
        "data norm": {
            "command": "data norm",
            "offline": true,
            "description": "normalize max/min to +/-128",
            "usage": "data norm [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data norm"
            ]
        },
        "data plot": {
            "command": "data plot",
            "offline": true,
            "description": "show graph window hit 'h' in window for detail keystroke help available",
            "usage": "data plot [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data plot"
            ]
        },
        "data rtrim": {
            "command": "data rtrim",
            "offline": true,
            "description": "trim samples from right of trace",
            "usage": "data rtrim [-h] -i <dec>",
            "options": [
                "-h, --help this help",
                "-i, --idx <dec> from index to end trace"
            ],
            "notes": [
                "data rtrim -i 4000 -> keep 0 - 4000"
            ]
        },
        "data setgraphmarkers": {
            "command": "data setgraphmarkers",
            "offline": true,
            "description": "set blue and orange marker in graph window",
            "usage": "data setgraphmarkers [-h] [-a <dec>] [-b <dec>]",
            "options": [
                "-h, --help this help",
                "-a <dec> orange marker",
                "-b <dec> blue marker"
            ],
            "notes": [
                "data setgraphmarkers -> turn off",
                "data setgraphmarkers -a 64 -b 50"
            ]
        },
        "data shiftgraphzero": {
            "command": "data shiftgraphzero",
            "offline": true,
            "description": "shift 0 for graphed wave + or - shift value",
            "usage": "data shiftgraphzero [-h] -n <dec>",
            "options": [
                "-h, --help this help",
                "-n <dec> shift + or -"
            ],
            "notes": [
                "data shiftgraphzero -n 10 -> shift 10 points",
                "data shiftgraphzero -n -22 -> shift negative 22 points"
            ]
        },
        "data timescale": {
            "command": "data timescale",
            "offline": true,
            "description": "set cursor display timescale. setting the timescale makes the differential `dt` reading between the yellow and purple markers meaningful. once the timescale is set, the differential reading between brackets can become a time duration.",
            "usage": "data timescale [-h] --sr <float> [-u <string>]",
            "options": [
                "-h, --help this help",
                "--sr <float> sets timescale factor according to sampling rate",
                "-u, --unit <string> time unit to display (max 10 chars)"
            ],
            "notes": [
                "data timescale --sr 125 -u ms -> for lf sampled at 125 khz. reading will be in milliseconds",
                "data timescale --sr 1.695 -u us -> for hf sampled at 16 * fc/128. reading will be in microseconds",
                "data timescale --sr 16 -u etu -> for hf with 16 samples per etu (fc/128). reading will be in etus"
            ]
        },
        "data zerocrossings": {
            "command": "data zerocrossings",
            "offline": true,
            "description": "count time between zero-crossings",
            "usage": "data zerocrossings [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data zerocrossings"
            ]
        },
        "data convertbitstream": {
            "command": "data convertbitstream",
            "offline": true,
            "description": "convert graphbuffer's 0|1 values to 127|-127",
            "usage": "data convertbitstream [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data convertbitstream"
            ]
        },
        "data getbitstream": {
            "command": "data getbitstream",
            "offline": true,
            "description": "convert graphbuffer's value accordingly - larger or equal to one becomes one - less than one becomes zero",
            "usage": "data getbitstream [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data getbitstream"
            ]
        },
        "data bin2hex": {
            "command": "data bin2hex",
            "offline": true,
            "description": "this function converts binary to hexadecimal. it will ignore all characters not 1 or 0 but stop reading on whitespace",
            "usage": "data bin2hex [-h] [-d <bin>]...",
            "options": [
                "-h, --help this help",
                "-d, --data <bin> binary string to convert"
            ],
            "notes": [
                "data bin2hex -d 0101111001010"
            ]
        },
        "data bitsamples": {
            "command": "data bitsamples",
            "offline": false,
            "description": "get raw samples from device as bitstring",
            "usage": "data bitsamples [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data bitsamples"
            ]
        },
        "data clear": {
            "command": "data clear",
            "offline": true,
            "description": "this function clears the bigbuff on deviceside and graph window",
            "usage": "data clear [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data clear"
            ]
        },
        "data hexsamples": {
            "command": "data hexsamples",
            "offline": false,
            "description": "dump big buffer as hex bytes",
            "usage": "data hexsamples [-h] [-b <dec>] [-n <dec>] [-o <hex>]",
            "options": [
                "-h, --help this help",
                "-b, --breaks <dec> row break, def 16",
                "-n <dec> num of bytes to download",
                "-o, --offset <hex> offset in big buffer"
            ],
            "notes": [
                "data hexsamples -n 128 -> dumps 128 bytes from offset 0"
            ]
        },
        "data hex2bin": {
            "command": "data hex2bin",
            "offline": true,
            "description": "this function converts hexadecimal to binary. it will ignore all non-hexadecimal characters but stop reading on whitespace",
            "usage": "data hex2bin [-h] [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to convert"
            ],
            "notes": [
                "data hex2bin -d 01020304"
            ]
        },
        "data load": {
            "command": "data load",
            "offline": true,
            "description": "this command loads the contents of a pm3 file into graph window",
            "usage": "data load [-h] -f <fn>",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> file to load"
            ],
            "notes": [
                "data load -f myfilename"
            ]
        },
        "data ndef": {
            "command": "data ndef",
            "offline": true,
            "description": "decode and print nfc data exchange format (ndef)",
            "usage": "data ndef [-hv] [-d <hex>]...",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> ndef data to decode",
                "-v, --verbose verbose mode"
            ],
            "notes": [
                "data ndef -d 9101085402656e48656c6c6f5101085402656e576f726c64",
                "data ndef -d 0103d020240203e02c040300fe"
            ]
        },
        "data print": {
            "command": "data print",
            "offline": true,
            "description": "print the data in the demodbuffer as hex or binary. defaults to binary output",
            "usage": "data print [-hisx] [-o <dec>]",
            "options": [
                "-h, --help this help",
                "-i, --inv invert demodbuffer before printing",
                "-o, --offset <dec> offset in # of bits",
                "-s, --strip strip leading zeroes, i.e. set offset to first bit equal to one",
                "-x, --hex output in hex (omit for binary output)"
            ],
            "notes": [
                "data print"
            ]
        },
        "data samples": {
            "command": "data samples",
            "offline": false,
            "description": "get raw samples for graph window (graphbuffer) from device. if 0, then get whole big buffer from device.",
            "usage": "data samples [-hv] [-n <dec>]",
            "options": [
                "-h, --help this help",
                "-n <dec> num of samples (512 - 40000)",
                "-v, --verbose verbose"
            ],
            "notes": [
                "data samples",
                "data samples -n 10000"
            ]
        },
        "data save": {
            "command": "data save",
            "offline": true,
            "description": "save trace from graph window , i.e. the graphbuffer this is a text file with number -127 to 127. with the option `w` you can save it as wave file filename should be without file extension",
            "usage": "data save [-hw] -f <fn w/o ext>",
            "options": [
                "-h, --help this help",
                "-w, --wave save as wave format (.wav)",
                "-f, --file <fn w/o ext> save file name"
            ],
            "notes": [
                "data save -f myfilename -> save graph buffer to file",
                "data save --wave -f myfilename -> save graph buffer to wave file"
            ]
        },
        "data setdebugmode": {
            "command": "data setdebugmode",
            "offline": true,
            "description": "set debugging level on client side",
            "usage": "data setdebugmode [-h012]",
            "options": [
                "-h, --help this help",
                "-0 no debug messages",
                "-1 debug",
                "-2 verbose debugging"
            ],
            "notes": [
                "data setdebugmode"
            ]
        },
        "data tune": {
            "command": "data tune",
            "offline": false,
            "description": "measure tuning of device antenna. results shown in graph window. this command doesn't actively tune your antennas, it's only informative by measuring voltage that the antennas will generate",
            "usage": "data tune [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "data tune"
            ]
        },
        "emv help": {
            "command": "emv help",
            "offline": true,
            "description": "help this help test crypto logic test. list list iso7816 history --------------------------------------------------------------------------------------- emv exec available offline: no executes emv contactless transaction",
            "usage": "emv exec [-hsatjfvcxgw] by default:",
            "options": [
                "-h, --help this help",
                "-s, -s, --select activate field and select card.",
                "-a, -a, --apdu show apdu reqests and responses.",
                "-t, -t, --tlv tlv decode results.",
                "-j, -j, --jload load transaction parameters from `emv_defparams.json` file.",
                "-f, -f, --forceaid force search aid. search aid instead of execute ppse.",
                "by default: transaction type - msd",
                "-v, -v, --qvsdc transaction type - qvsdc or m/chip.",
                "-c, -c, --qvsdccda transaction type - qvsdc or m/chip plus cda (sdad generation).",
                "-x, -x, --vsdc transaction type - vsdc. for test only. not a standard behavior.",
                "-g, -g, --acgpo visa. generate ac from gpo.",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv exec -sat -> select card, execute msd transaction, show apdu and tlv",
                "emv exec -satc -> select card, execute cda transaction, show apdu and tlv"
            ]
        },
        "emv pse": {
            "command": "emv pse",
            "offline": false,
            "description": "executes pse/ppse select command. it returns list of applet on the card:",
            "usage": "emv pse [-hsk12atw]",
            "options": [
                "-h, --help this help",
                "-s, -s, --select activate field and select card",
                "-k, -k, --keep keep field on for next command",
                "-1, --pse pse (1pay.sys.ddf01) mode",
                "-2, --ppse ppse (2pay.sys.ddf01) mode (default mode)",
                "-a, -a, --apdu show apdu reqests and responses",
                "-t, -t, --tlv tlv decode results of selected applets",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv pse -s1 -> select, get pse",
                "emv pse -st2 -> select, get ppse, show result in tlv"
            ]
        },
        "emv search": {
            "command": "emv search",
            "offline": false,
            "description": "tries to select all applets from applet list",
            "usage": "emv search [-hskatw]",
            "options": [
                "-h, --help this help",
                "-s, -s, --select activate field and select card",
                "-k, -k, --keep keep field on for next command",
                "-a, -a, --apdu show apdu reqests and responses",
                "-t, -t, --tlv tlv decode results of selected applets",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv search -s -> select card and search",
                "emv search -st -> select card, search and show result in tlv"
            ]
        },
        "emv select": {
            "command": "emv select",
            "offline": false,
            "description": "executes select applet command",
            "usage": "emv select [-hskatw] [<hex applet aid>]...",
            "options": [
                "-h, --help this help",
                "-s, -s, --select activate field and select card",
                "-k, -k, --keep keep field for next command",
                "-a, -a, --apdu show apdu reqests and responses",
                "-t, -t, --tlv tlv decode results",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv select -s a00000000101 -> select card, select applet",
                "emv select -st a00000000101 -> select card, select applet, show result in tlv"
            ]
        },
        "emv gpo": {
            "command": "emv gpo",
            "offline": false,
            "description": "executes get processing options command. it returns data in tlv format (0x77 - format2) or plain format (0x80 - format1). needs a emv applet to be selected.",
            "usage": "emv gpo [-hkpmatw] [<hex pdoldata/pdol>]...",
            "options": [
                "-h, --help this help",
                "-k, -k, --keep keep field on for next command",
                "-p, -p, --params load parameters from `emv_defparams.json` file for pdoldata making from pdol and parameters",
                "-m, -m, --make make pdoldata from pdol (tag 9f38) and parameters (by default uses default parameters)",
                "-a, -a, --apdu show apdu reqests and responses",
                "-t, -t, --tlv tlv decode results of selected applets",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv gpo -k -> execute gpo",
                "emv gpo -t 01020304 -> execute gpo with 4-byte pdol data, show result in tlv",
                "emv gpo -pmt 9f 37 04 -> load params from file, make pdol data from pdol, execute gpo with pdol, show result in tlv"
            ]
        },
        "emv readrec": {
            "command": "emv readrec",
            "offline": false,
            "description": "executes read record command. it returns data in tlv format. needs a bank applet to be selected and sometimes needs gpo to be executed.",
            "usage": "emv readrec [-hkatw] <sfi 1byte hex><sfirecord 1byte hex> [<sfi 1byte hex><sfirecord 1byte hex>]...",
            "options": [
                "-h, --help this help",
                "-k, -k, --keep keep field on for next command",
                "-a, -a, --apdu show apdu reqests and responses",
                "-t, -t, --tlv tlv decode results of selected applets",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv readrec -k 0101 -> read file sfi=01, sfirec=01",
                "emv readrec -kt 0201 -> read file 0201 and show result in tlv"
            ]
        },
        "emv genac": {
            "command": "emv genac",
            "offline": false,
            "description": "generate application cryptogram command. it returns data in tlv format. needs a emv applet to be selected and gpo to be executed.",
            "usage": "emv genac [-hkcpmatw] [-d <aac|tc|arqc>] <hex cdoldata/cdol> [<hex cdoldata/cdol>]...",
            "options": [
                "-h, --help this help",
                "-k, -k, --keep keep field on for next command",
                "-c, -c, --cda executes cda transaction. needs to get sdad in results.",
                "-d, -d, --decision <aac|tc|arqc> terminal decision. aac - declined, tc - approved, arqc - online authorisation requested",
                "-p, -p, --params load parameters from `emv_defparams.json` file for cdoldata making from cdol and parameters",
                "-m, -m, --make make cdoldata from cdol (tag 8c and 8d) and parameters (by default uses default parameters)",
                "-a, -a, --apdu show apdu reqests and responses",
                "-t, -t, --tlv tlv decode results of selected applets",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv genac -k 0102 -> generate ac with 2-byte cdoldata and keep field on after command",
                "emv genac -t 01020304 -> generate ac with 4-byte cdol data, show result in tlv",
                "emv genac -daac 01020304 -> generate ac with 4-byte cdol data and terminal decision 'declined'",
                "emv genac -pmt 9f 37 04 -> load params from file, make cdol data from cdol, generate ac with cdol, show result in tlv"
            ]
        },
        "emv challenge": {
            "command": "emv challenge",
            "offline": false,
            "description": "executes generate challenge command. it returns 4 or 8-byte random number from card. needs a emv applet to be selected and gpo to be executed.",
            "usage": "emv challenge [-hkaw]",
            "options": [
                "-h, --help this help",
                "-k, -k, --keep keep field on for next command",
                "-a, -a, --apdu show apdu reqests and responses",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv challenge -> get challenge",
                "emv challenge -k -> get challenge, keep fileld on"
            ]
        },
        "emv intauth": {
            "command": "emv intauth",
            "offline": false,
            "description": "generate internal authenticate command. usually needs 4-byte random number. it returns data in tlv format . needs a emv applet to be selected and gpo to be executed.",
            "usage": "emv intauth [-hkpmatw] <hex ddoldata/ddol> [<hex ddoldata/ddol>]...",
            "options": [
                "-h, --help this help",
                "-k, -k, --keep keep field on for next command",
                "-p, -p, --params load parameters from `emv_defparams.json` file for ddoldata making from ddol and parameters",
                "-m, -m, --make make ddoldata from ddol (tag 9f49) and parameters (by default uses default parameters)",
                "-a, -a, --apdu show apdu reqests and responses",
                "-t, -t, --tlv tlv decode results of selected applets",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default."
            ],
            "notes": [
                "emv intauth -k 01020304 -> execute internal authenticate with 4-byte ddoldata and keep field on after command",
                "emv intauth -t 01020304 -> execute internal authenticate with 4-byte ddol data, show result in tlv",
                "emv intauth -pmt 9f 37 04 -> load params from file, make ddol data from ddol, internal authenticate with ddol, show result in tlv"
            ]
        },
        "emv scan": {
            "command": "emv scan",
            "offline": false,
            "description": "scan emv card and save it contents to a file. it executes emv contactless transaction and saves result to a file which can be used for emulation",
            "usage": "emv scan [-hatejvcxgmw] by default: output.json",
            "options": [
                "-h, --help this help",
                "-a, -a, --apdu show apdu reqests and responses.",
                "-t, -t, --tlv tlv decode results.",
                "-e, -e, --extract extract tlv elements and fill application data",
                "-j, -j, --jload load transaction parameters from `emv_defparams.json` file.",
                "by default: transaction type - msd",
                "-v, -v, --qvsdc transaction type - qvsdc or m/chip.",
                "-c, -c, --qvsdccda transaction type - qvsdc or m/chip plus cda (sdad generation).",
                "-x, -x, --vsdc transaction type - vsdc. for test only. not a standard behavior.",
                "-g, -g, --acgpo visa. generate ac from gpo.",
                "-m, -m, --merge merge output file with card's data. (warning: the file may be corrupted!)",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default.",
                "output.json json output file name"
            ],
            "notes": [
                "emv scan -at -> scan msd transaction mode and show apdu and tlv",
                "emv scan -c -> scan cda transaction mode"
            ]
        },
        "emv test": {
            "command": "emv test",
            "offline": true,
            "description": "executes tests",
            "usage": "emv test [-hil]",
            "options": [
                "-h, --help this help",
                "-i, --ignore ignore timing tests for vm",
                "-l, --long run long tests too"
            ],
            "notes": [
                "emv test -i",
                "emv test --long"
            ]
        },
        "emv list": {
            "command": "emv list",
            "offline": true,
            "description": "alias of `trace list -t 7816` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "emv list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "emv list -f -> show frame delay times",
                "emv list -1 -> use trace buffer"
            ]
        },
        "emv roca": {
            "command": "emv roca",
            "offline": false,
            "description": "tries to extract public keys and run the roca test against them.",
            "usage": "emv roca [-htaw]",
            "options": [
                "-h, --help this help",
                "-t, -t, --selftest self test",
                "-a, -a, --apdu show apdu reqests and responses",
                "-w, -w, --wired send data via contact (iso7816) interface. contactless interface set by default"
            ],
            "notes": [
                "emv roca -w -> select --contact-- card and run test",
                "emv roca -> select --contactless-- card and run test"
            ]
        },
        "hf help": {
            "command": "hf help",
            "offline": true,
            "description": "-------- ----------------------- high frequency ----------------------- 14a { iso14443a rfids... } 14b { iso14443b rfids... } 15 { iso15693 rfids... } epa { german identification card... } emrtd { machine readable travel document... } felica { iso18092 / felica rfids... } fido { fido and fido2 authenticators... } jooki { jooki rfids... } iclass { iclass rfids... } legic { legic rfids... } lto { lto cartridge memory rfids... } mf { mifare rfids... } mfp { mifare plus rfids... } mfu { mifare ultralight rfids... } mfdes { mifare desfire rfids... } st { st rothult rfids... } thinfilm { thinfilm rfids... } topaz { topaz (nfc type 1) rfids... } waveshare { waveshare nfc epaper... } ----------- --------------------- general --------------------- help this help list list protocol data in trace buffer search search for known hf tags --------------------------------------------------------------------------------------- hf list available offline: yes alias of `trace list -t raw` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf list -f -> show frame delay times",
                "hf list -1 -> use trace buffer"
            ]
        },
        "hf plot": {
            "command": "hf plot",
            "offline": false,
            "description": "plots hf signal after rf signal path and a/d conversion.",
            "usage": "hf plot [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "this can be used after any hf command and will show the last few milliseconds of the hf signal.",
                "note: if the last hf command terminated because of a timeout you will most probably see nothing."
            ]
        },
        "hf tune": {
            "command": "hf tune",
            "offline": false,
            "description": "continuously measure hf antenna tuning. press button or <enter> to interrupt.",
            "usage": "hf tune [-h] [-n <dec>] [--bar] [--mix] [--value]",
            "options": [
                "-h, --help this help",
                "-n, --iter <dec> number of iterations (default: 0=infinite)",
                "--bar bar style",
                "--mix mixed style",
                "--value values style"
            ],
            "notes": [
                "hf tune",
                "hf tune --mix"
            ]
        },
        "hf search": {
            "command": "hf search",
            "offline": true,
            "description": "will try to find a hf read out of the unknown tag. continues to search for all different hf protocols.",
            "usage": "hf search [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf search"
            ]
        },
        "hf sniff": {
            "command": "hf sniff",
            "offline": false,
            "description": "the high frequency sniffer will assign all available memory on device for sniffed data. use `data samples` to download from device and `data plot` to visualize it. press button to quit the sniffing.",
            "usage": "hf sniff [-h] [--sp <dec>] [--st <dec>]",
            "options": [
                "-h, --help this help",
                "--sp <dec> skip sample pairs",
                "--st <dec> skip number of triggers"
            ],
            "notes": [
                "hf sniff",
                "hf sniff --sp 1000 --st 0 -> skip 1000 pairs, skip 0 triggers"
            ]
        },
        "hf 14a help": {
            "command": "hf 14a help",
            "offline": true,
            "description": "help this help list list iso 14443-a history --------------------------------------------------------------------------------------- hf 14a list available offline: yes alias of `trace list -t 14a` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf 14a list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf 14a list -f -> show frame delay times",
                "hf 14a list -1 -> use trace buffer"
            ]
        },
        "hf 14a info": {
            "command": "hf 14a info",
            "offline": false,
            "description": "this command makes more extensive tests against a iso14443a tag in order to collect information",
            "usage": "hf 14a info [-hvns]",
            "options": [
                "-h, --help this help",
                "-v, --verbose adds some information to results",
                "-n, --nacktest test for nack bug",
                "-s, --aidsearch checks if aids from aidlist.json is present on the card and prints information about found aids"
            ],
            "notes": [
                "hf 14a info -nsv -> shows full information about the card"
            ]
        },
        "hf 14a reader": {
            "command": "hf 14a reader",
            "offline": false,
            "description": "reader for iso 14443a based tags",
            "usage": "hf 14a reader [-hks@] [--drop] [--skip]",
            "options": [
                "-h, --help this help",
                "-k, --keep keep the field active after command executed",
                "-s, --silent silent (no messages)",
                "--drop just drop the signal field",
                "--skip iso14443-3 select only (skip rats)",
                "-@ continuous reader mode"
            ],
            "notes": [
                "hf 14a reader -@ -> continuous mode"
            ]
        },
        "hf 14a cuids": {
            "command": "hf 14a cuids",
            "offline": false,
            "description": "collect n>0 iso14443-a uids in one go",
            "usage": "hf 14a cuids [-h] [-n <dec>]",
            "options": [
                "-h, --help this help",
                "-n, --num <dec> number of uids to collect"
            ],
            "notes": [
                "hf 14a cuids -n 5 -> collect 5 uids"
            ]
        },
        "hf 14a sim": {
            "command": "hf 14a sim",
            "offline": false,
            "description": "simulate iso/iec 14443 type a tag with 4,7 or 10 byte uid",
            "usage": "hf 14a sim [-hxv] -t <1-10> [-u <hex>] [-n <dec>] [--sk]",
            "options": [
                "-h, --help this help",
                "-t, --type <1-10> simulation type to use",
                "-u, --uid <hex> 4, 7 or 10 byte uid",
                "-n, --num <dec> exit simulation after <numreads> blocks have been read by reader. 0 = infinite",
                "-x performs the 'reader attack', nr/ar attack against a reader",
                "--sk fill simulator keys from found keys",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf 14a sim -t 1 --uid 11223344 -> mifare classic 1k",
                "hf 14a sim -t 2 -> mifare ultralight",
                "hf 14a sim -t 3 -> mifare desfire",
                "hf 14a sim -t 4 -> iso/iec 14443-4",
                "hf 14a sim -t 5 -> mifare tnp3xxx",
                "hf 14a sim -t 6 -> mifare mini",
                "hf 14a sim -t 7 -> amiibo (ntag 215), pack 0x8080",
                "hf 14a sim -t 8 -> mifare classic 4k",
                "hf 14a sim -t 9 -> fm11rf005sh shanghai metro",
                "hf 14a sim -t 10 -> st25ta ikea rothult"
            ]
        },
        "hf 14a sniff": {
            "command": "hf 14a sniff",
            "offline": false,
            "description": "collect data from the field and save into command buffer. buffer accessible from command 'hf 14a list'",
            "usage": "hf 14a sniff [-hcr]",
            "options": [
                "-h, --help this help",
                "-c, --card triggered by first data from card",
                "-r, --reader triggered by first 7-bit request from reader (req,wup,...)"
            ],
            "notes": [
                "hf 14a sniff -c -r"
            ]
        },
        "hf 14a apdu": {
            "command": "hf 14a apdu",
            "offline": false,
            "description": "sends an iso 7816-4 apdu via iso 14443-4 block transmission protocol (t=cl). works with all apdu types from iso 7816-4:2013",
            "usage": "hf 14a apdu [-hsktde] [-m <head (cla ins p1 p2) hex>] [-l <le (int)>] <apdu (hex) | data (hex)> [<apdu (hex) | data (hex)>]...",
            "options": [
                "-h, --help this help",
                "-s, --select activate field and select card",
                "-k, --keep keep signal field on after receive",
                "-t, --tlv executes tlv decoder if it possible",
                "-d, --decapdu decode apdu request if it possible",
                "-m, --make <head (cla ins p1 p2) hex> make apdu with head from this field and data from data field. must be 4 bytes length: <cla ins p1 p2>",
                "-e, --extended make extended length apdu if `m` parameter included",
                "-l, --le <le (int)> le apdu parameter if `m` parameter included",
                "<apdu (hex) | data (hex)> data if `m` parameter included"
            ],
            "notes": [
                "hf 14a apdu -st 00a404000e325041592e5359532e444446303100",
                "hf 14a apdu -sd 00a404000e325041592e5359532e444446303100 -> decode apdu",
                "hf 14a apdu -sm 00a40400 325041592e5359532e4444463031 -l 256 -> encode standard apdu",
                "hf 14a apdu -sm 00a40400 325041592e5359532e4444463031 -el 65536 -> encode extended apdu"
            ]
        },
        "hf 14a chaining": {
            "command": "hf 14a chaining",
            "offline": false,
            "description": "enable/disable iso14443a input chaining. maximum input length goes from ats.",
            "usage": "hf 14a chaining [-h] [<enable/disable or 0/1>]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf 14a chaining disable -> disable chaining",
                "hf 14a chaining -> show chaining enable/disable state"
            ]
        },
        "hf 14a raw": {
            "command": "hf 14a raw",
            "offline": false,
            "description": "sends raw bytes over iso14443a. with option to use topaz 14a mode.",
            "usage": "hf 14a raw [-hack3rs] [-b <dec>] [-t <ms>] [--topaz] <hex> [<hex>]...",
            "options": [
                "-h, --help this help",
                "-a active signal field on without select",
                "-b <dec> number of bits to send. useful for send partial byte",
                "-c calculate and append crc",
                "-k keep signal field on after receive",
                "-3 iso14443-3 select only (skip rats)",
                "-r do not read response",
                "-s active signal field on with select",
                "-t, --timeout <ms> timeout in milliseconds",
                "--topaz use topaz protocol to send command",
                "<hex> raw bytes to send"
            ],
            "notes": [
                "hf 14a raw -sc 3000 -> select, crc, where 3000 == 'read block 00'",
                "hf 14a raw -ak -b 7 40 -> send 7 bit byte 0x40"
            ]
        },
        "hf 14a antifuzz": {
            "command": "hf 14a antifuzz",
            "offline": false,
            "description": "tries to fuzz the iso14443a anticollision phase",
            "usage": "hf 14a antifuzz [-h47] [--10]",
            "options": [
                "-h, --help this help",
                "-4 4 byte uid",
                "-7 7 byte uid",
                "--10 10 byte uid"
            ],
            "notes": [
                "hf 14a antifuzz -4"
            ]
        },
        "hf 14a config": {
            "command": "hf 14a config",
            "offline": false,
            "description": "--------------------------------------------------------------------------------------- hf 14a apdufind available offline: no enumerate apdu's of iso7816 protocol to find valid cls/ins/p1/p2 commands. it loops all 256 possible values for each byte. the loop oder is ins -> p1/p2 (alternating) -> cla. tag must be on antenna before running.",
            "usage": "hf 14a apdufind [-hlv] [-c <hex>] [-i <hex>] [--p1 <hex>] [--p2 <hex>] [-r <number>] [-e <number>] [-s <hex>]...",
            "options": [
                "-h, --help this help",
                "-c, --cla <hex> start value of class (1 hex byte)",
                "-i, --ins <hex> start value of instruction (1 hex byte)",
                "--p1 <hex> start value of p1 (1 hex byte)",
                "--p2 <hex> start value of p2 (1 hex byte)",
                "-r, --reset <number> minimum secondes before resetting the tag (to prevent timeout issues). default is 5 minutes",
                "-e, --error-limit <number> maximum times an status word other than 0x9000 or 0x6d00 is shown. default is 512.",
                "-s, --skip-ins <hex> do not test an instructions (can be specifed multiple times)",
                "-l, --with-le serach for apdus with le=0 (case 2s) as well",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf 14a apdufind",
                "hf 14a apdufind --cla 80",
                "hf 14a apdufind --cla 80 --error-limit 20 --skip-ins a4 --skip-ins b0 --with-le"
            ]
        },
        "hf 14b help": {
            "command": "hf 14b help",
            "offline": true,
            "description": "help this help list list iso-14443-b history --------------------------------------------------------------------------------------- hf 14b apdu available offline: no sends an iso 7816-4 apdu via iso 14443-4 block transmission protocol (t=cl). works with all apdu types from iso 7816-4:2013",
            "usage": "hf 14b apdu [-hskte] [--decode] [-m <hex>] [-l <int>] -d <hex> [-d <hex>]... [--timeout <dec>]",
            "options": [
                "-h, --help this help",
                "-s, --select activate field and select card",
                "-k, --keep leave the signal field on after receive response",
                "-t, --tlv executes tlv decoder if it possible",
                "--decode decode apdu request if it possible",
                "-m, --make <hex> make apdu with head from this field and data from data field.",
                "must be 4 bytes: <cla ins p1 p2>",
                "-e, --extended make extended length apdu if `m` parameter included",
                "-l, --le <int> le apdu parameter if `m` parameter included",
                "-d, --data <hex> <apdu | data> if `m` parameter included",
                "--timeout <dec> timeout in ms"
            ],
            "notes": [
                "hf 14b apdu -s -d 94a40800043f000002",
                "hf 14b apdu -s --decode -d 00a404000e325041592e5359532e444446303100 -> decode apdu",
                "hf 14b apdu -sm 00a40400 -l 256 -d 325041592e5359532e4444463031 -> encode standard apdu",
                "hf 14b apdu -sm 00a40400 -el 65536 -d 325041592e5359532e4444463031 -> encode extended apdu"
            ]
        },
        "hf 14b dump": {
            "command": "hf 14b dump",
            "offline": false,
            "description": "this command dumps the contents of a iso-14443-b tag and save it to file tries to autodetect cardtype, memory size defaults to sri4k",
            "usage": "hf 14b dump [-h] [-f <filename>]...",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> (optional) filename, if no <name> uid will be used as filename"
            ],
            "notes": [
                "hf 14b dump",
                "hf 14b dump -f myfilename"
            ]
        },
        "hf 14b info": {
            "command": "hf 14b info",
            "offline": false,
            "description": "tag information for iso/iec 14443 type b based tags",
            "usage": "hf 14b info [-hsv]",
            "options": [
                "-h, --help this help",
                "-s, --aidsearch checks if aids from aidlist.json is present on the card and prints information about found aids",
                "-v, --verbose verbose"
            ],
            "notes": [
                "hf 14b info"
            ]
        },
        "hf 14b list": {
            "command": "hf 14b list",
            "offline": true,
            "description": "alias of `trace list -t 14b` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf 14b list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf 14b list -f -> show frame delay times",
                "hf 14b list -1 -> use trace buffer"
            ]
        },
        "hf 14b ndef": {
            "command": "hf 14b ndef",
            "offline": false,
            "description": "print nfc data exchange format (ndef)",
            "usage": "hf 14b ndef [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf 14b ndef"
            ]
        },
        "hf 14b raw": {
            "command": "hf 14b raw",
            "offline": false,
            "description": "sends raw bytes to card",
            "usage": "hf 14b raw [-hkscrv] [--sr] [--cts] [-t <dec>] [-d <hex>]...",
            "options": [
                "-h, --help this help",
                "-k, --keep leave the signal field on after receive response",
                "-s, --std activate field, use iso14b select",
                "--sr activate field, use srx st select",
                "--cts activate field, use ask c-ticket select",
                "-c, --crc calculate and append crc",
                "-r do not read response from card",
                "-t, --timeout <dec> timeout in ms",
                "-v, --verbose verbose",
                "-d, --data <hex> data, bytes to send"
            ],
            "notes": [
                "hf 14b raw -cks --data 0200a40400 -> standard select, apdu 0200a4000 (7816)",
                "hf 14b raw -ck --sr --data 0200a40400 -> srx select",
                "hf 14b raw -ck --cts --data 0200a40400 -> c-ticket select"
            ]
        },
        "hf 14b reader": {
            "command": "hf 14b reader",
            "offline": false,
            "description": "act as a 14443b reader to identify a tag",
            "usage": "hf 14b reader [-hs@]",
            "options": [
                "-h, --help this help",
                "-s, --silent silent (no messages)",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "hf 14b reader"
            ]
        },
        "hf 14b sim": {
            "command": "hf 14b sim",
            "offline": false,
            "description": "simulate a iso/iec 14443 type b tag with 4 byte uid / pupi",
            "usage": "hf 14b sim [-h] [-u hex]...",
            "options": [
                "-h, --help this help",
                "-u, --uid hex 4byte uid/pupi"
            ],
            "notes": [
                "hf 14b sim -u 11aa33bb"
            ]
        },
        "hf 14b sniff": {
            "command": "hf 14b sniff",
            "offline": false,
            "description": "sniff the communication reader and tag",
            "usage": "hf 14b sniff [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf 14b sniff"
            ]
        },
        "hf 14b rdbl": {
            "command": "hf 14b rdbl",
            "offline": false,
            "description": "read sri512 | srix4k block",
            "usage": "hf 14b rdbl [-h] [-b <dec>]",
            "options": [
                "-h, --help this help",
                "-b, --block <dec> block number"
            ],
            "notes": [
                "hf 14b rdbl -b 06"
            ]
        },
        "hf 14b sriwrite": {
            "command": "hf 14b sriwrite",
            "offline": false,
            "description": "write data to a sri512 or srix4k block",
            "usage": "hf 14b sriwrite [-h] [-b <dec>] -d <hex> [--512] [--4k] [--sb]",
            "options": [
                "-h, --help this help",
                "-b, --block <dec> block number",
                "-d, --data <hex> 4 hex bytes",
                "--512 target sri 512 tag",
                "--4k target srix 4k tag",
                "--sb special block write at end of memory (0xff)"
            ],
            "notes": [
                "hf 14b sriwrite --4k -b 100 -d 11223344",
                "hf 14b sriwrite --4k --sb -d 11223344 -> special block write",
                "hf 14b sriwrite --512 -b 15 -d 11223344",
                "hf 14b sriwrite --512 --sb -d 11223344 -> special block write"
            ]
        },
        "hf 15 help": {
            "command": "hf 15 help",
            "offline": true,
            "description": "----------- --------------------- general --------------------- help this help list list iso-15693 history demod demodulate iso-15693 from tag --------------------------------------------------------------------------------------- hf 15 list available offline: yes alias of `trace list -t 15` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf 15 list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf 15 list -f -> show frame delay times",
                "hf 15 list -1 -> use trace buffer"
            ]
        },
        "hf 15 demod": {
            "command": "hf 15 demod",
            "offline": true,
            "description": "tries to demodulate / decode iso-15693, from downloaded samples. gather samples with 'hf 15 samples' / 'hf 15 sniff'",
            "usage": "hf 15 demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf 15 demod"
            ]
        },
        "hf 15 dump": {
            "command": "hf 15 dump",
            "offline": false,
            "description": "this command dumps the contents of a iso-15693 tag and save it to file",
            "usage": "hf 15 dump [-h*2o] [-u <hex>] [--ua] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)",
                "-f, --file <fn> filename of dump"
            ],
            "notes": [
                "hf 15 dump",
                "hf 15 dump -*",
                "hf 15 dump -u e011223344556677 -f hf-15-my-dump.bin"
            ]
        },
        "hf 15 info": {
            "command": "hf 15 info",
            "offline": false,
            "description": "uses the optional command `get_systeminfo` 0x2b to try and extract information",
            "usage": "hf 15 info [-h*2o] [-u <hex>] [--ua]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)"
            ],
            "notes": [
                "hf 15 info",
                "hf 15 info -*",
                "hf 15 info -u e011223344556677"
            ]
        },
        "hf 15 sniff": {
            "command": "hf 15 sniff",
            "offline": false,
            "description": "sniff activity without enabling carrier",
            "usage": "hf 15 sniff [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf 15 sniff"
            ]
        },
        "hf 15 raw": {
            "command": "hf 15 raw",
            "offline": false,
            "description": "sends raw bytes over iso-15693 to card",
            "usage": "hf 15 raw [-h2ckr] -d <hex> [-d <hex>]...",
            "options": [
                "-h, --help this help",
                "-2 use slower '1 out of 256' mode",
                "-c, --crc calculate and append crc",
                "-k keep signal field on after receive",
                "-r do not read response",
                "-d, --data <hex> raw bytes to send"
            ],
            "notes": [
                "hf 15 raw -c -d 260100 -> add crc",
                "hf 15 raw -krc -d 260100 -> add crc, keep field on, skip response"
            ]
        },
        "hf 15 rdbl": {
            "command": "hf 15 rdbl",
            "offline": false,
            "description": "read page on iso-15693 tag",
            "usage": "hf 15 rdbl [-h*2o] [-u <hex>] [--ua] -b <dec>",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)",
                "-b, --blk <dec> page number (0-255)"
            ],
            "notes": [
                "hf 15 rdbl -* -b 12",
                "hf 15 rdbl -u e011223344556677 -b 12"
            ]
        },
        "hf 15 rdmulti": {
            "command": "hf 15 rdmulti",
            "offline": false,
            "description": "read multiple pages on a iso-15693 tag",
            "usage": "hf 15 rdmulti [-h*2o] [-u <hex>] [--ua] -b <dec> --cnt <dec>",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)",
                "-b <dec> first page number (0-255)",
                "--cnt <dec> number of pages (1-6)"
            ],
            "notes": [
                "hf 15 rdmulti -* -b 1 --cnt 6 -> read 6 blocks",
                "hf 15 rdmulti -u e011223344556677 -b 12 --cnt 3 -> read three blocks"
            ]
        },
        "hf 15 reader": {
            "command": "hf 15 reader",
            "offline": false,
            "description": "act as a iso-15693 reader. look for iso-15693 tags until enter or the pm3 button is pressed",
            "usage": "hf 15 reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ continuous reader mode"
            ],
            "notes": [
                "hf 15 reader",
                "hf 15 reader -@ -> continuous mode"
            ]
        },
        "hf 15 restore": {
            "command": "hf 15 restore",
            "offline": false,
            "description": "this command restore the contents of a dump file onto a iso-15693 tag",
            "usage": "hf 15 restore [-h*2ov] [-u <hex>] [--ua] [-f <fn>] [-r <dec>] [--bs <dec>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)",
                "-f, --file <fn> filename of dump",
                "-r, --retry <dec> number of retries (def 3)",
                "--bs <dec> block size (def 4)",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf 15 restore",
                "hf 15 restore -*",
                "hf 15 restore -u e011223344556677 -f hf-15-my-dump.bin"
            ]
        },
        "hf 15 samples": {
            "command": "hf 15 samples",
            "offline": false,
            "description": "acquire samples as reader (enables carrier, send inquiry and download it to graphbuffer. try 'hf 15 demod' to try to demodulate/decode signal",
            "usage": "hf 15 samples [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf 15 samples"
            ]
        },
        "hf 15 sim": {
            "command": "hf 15 sim",
            "offline": false,
            "description": "simulate a iso-15693 tag",
            "usage": "hf 15 sim [-h] -u <8b hex>",
            "options": [
                "-h, --help this help",
                "-u, --uid <8b hex> uid eg e011223344556677"
            ],
            "notes": [
                "hf 15 sim -u e011223344556677"
            ]
        },
        "hf 15 wrbl": {
            "command": "hf 15 wrbl",
            "offline": false,
            "description": "write block on iso-15693 tag",
            "usage": "hf 15 wrbl [-h*2ov] [-u <hex>] [--ua] -b <dec> -d <hex>",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)",
                "-b, --blk <dec> page number (0-255)",
                "-d, --data <hex> data, 4 bytes",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf 15 wrbl -* -b 12 -d aabbccdd",
                "hf 15 wrbl -u e011223344556677 -b 12 -d aabbccdd"
            ]
        },
        "hf 15 findafi": {
            "command": "hf 15 findafi",
            "offline": false,
            "description": "this command attempts to brute force afi of an iso-15693 tag estimated execution time is around 2 minutes",
            "usage": "hf 15 findafi [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf 15 findafi"
            ]
        },
        "hf 15 writeafi": {
            "command": "hf 15 writeafi",
            "offline": false,
            "description": "write afi on card",
            "usage": "hf 15 writeafi [-h*2o] [-u <hex>] [--ua] --afi <dec>",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)",
                "--afi <dec> afi number (0-255)"
            ],
            "notes": [
                "hf 15 writeafi -* --afi 12",
                "hf 15 writeafi -u e011223344556677 --afi 12"
            ]
        },
        "hf 15 writedsfid": {
            "command": "hf 15 writedsfid",
            "offline": false,
            "description": "write dsfid on card",
            "usage": "hf 15 writedsfid [-h*2o] [-u <hex>] [--ua] --dsfid <dec>",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> full uid, 8 bytes",
                "--ua unaddressed mode",
                "-* scan for tag",
                "-2 use slower '1 out of 256' mode",
                "-o, --opt set option flag (needed for ti)",
                "--dsfid <dec> dsfid number (0-255)"
            ],
            "notes": [
                "hf 15 writedsfid -* --dsfid 12",
                "hf 15 writedsfid -u e011223344556677 --dsfid 12"
            ]
        },
        "hf 15 csetuid": {
            "command": "hf 15 csetuid",
            "offline": false,
            "description": "set uid for magic chinese card (only works with such cards)",
            "usage": "hf 15 csetuid [-h] -u <8b hex>",
            "options": [
                "-h, --help this help",
                "-u, --uid <8b hex> uid eg e011223344556677"
            ],
            "notes": [
                "hf 15 csetuid -u e011223344556677"
            ]
        },
        "hf epa help": {
            "command": "hf epa help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- hf epa cnonces available offline: no tries to collect nonces when doing part of pace protocol.",
            "usage": "hf epa cnonces [-h] --size <dec> --num <dec> -d <dec>",
            "options": [
                "-h, --help this help",
                "--size <dec> nonce size",
                "--num <dec> number of nonces to collect",
                "-d, --delay <dec> delay between attempts"
            ],
            "notes": [
                "hf epa cnonces --size 4 --num 4 --delay 1"
            ]
        },
        "hf epa preplay": {
            "command": "hf epa preplay",
            "offline": false,
            "description": "perform pace protocol by replaying given apdus",
            "usage": "hf epa preplay [-h] --mse <hex> --get <hex> --map <hex> --pka <hex> --ma <hex>",
            "options": [
                "-h, --help this help",
                "--mse <hex> msesa apdu",
                "--get <hex> gn apdu",
                "--map <hex> map apdu",
                "--pka <hex> pka apdu",
                "--ma <hex> ma apdu"
            ],
            "notes": [
                "hf epa preplay --mse 0022c1a4 --get 1068000000 --map 1086000002 --pka 1234abcdef --ma 1a2b3c4d"
            ]
        },
        "hf emrtd help": {
            "command": "hf emrtd help",
            "offline": true,
            "description": "help this help info display info about an emrtd list list iso 14443a/7816 history --------------------------------------------------------------------------------------- hf emrtd dump available offline: no dump all files on an emrtd",
            "usage": "hf emrtd dump [-h] [-n <alphanum>] [-d <yymmdd>] [-e <yymmdd>] [-m <[0-9a-z<]>] [--path <dirpath>]",
            "options": [
                "-h, --help this help",
                "-n, --documentnumber <alphanum> document number, up to 9 chars",
                "-d, --dateofbirth <yymmdd> date of birth in yymmdd format",
                "-e, --expiry <yymmdd> expiry in yymmdd format",
                "-m, --mrz <[0-9a-z<]> 2nd line of mrz, 44 chars",
                "--path <dirpath> save dump to the given dirpath"
            ],
            "notes": [
                "hf emrtd dump"
            ]
        },
        "hf emrtd info": {
            "command": "hf emrtd info",
            "offline": true,
            "description": "display info about an emrtd",
            "usage": "hf emrtd info [-h] [-n <alphanum>] [-d <yymmdd>] [-e <yymmdd>] [-m <[0-9a-z<]>] [--path <dirpath>]",
            "options": [
                "-h, --help this help",
                "-n, --documentnumber <alphanum> document number, up to 9 chars",
                "-d, --dateofbirth <yymmdd> date of birth in yymmdd format",
                "-e, --expiry <yymmdd> expiry in yymmdd format",
                "-m, --mrz <[0-9a-z<]> 2nd line of mrz, 44 chars (passports only)",
                "--path <dirpath> display info from offline dump stored in dirpath"
            ],
            "notes": [
                "hf emrtd info"
            ]
        },
        "hf emrtd list": {
            "command": "hf emrtd list",
            "offline": true,
            "description": "alias of `trace list -t 7816` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf emrtd list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf emrtd list -f -> show frame delay times",
                "hf emrtd list -1 -> use trace buffer"
            ]
        },
        "hf felica help": {
            "command": "hf felica help",
            "offline": true,
            "description": "help this help ----------- ----------------------- general ----------------------- list list iso 18092/felica history ----------- ----------------------- felica standard ----------------------- ----------- ----------------------- felica light ----------------------- --------------------------------------------------------------------------------------- hf felica list available offline: yes alias of `trace list -t felica` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf felica list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf felica list -f -> show frame delay times",
                "hf felica list -1 -> use trace buffer"
            ]
        },
        "hf felica reader": {
            "command": "hf felica reader",
            "offline": false,
            "description": "reader for felica based tags",
            "usage": "hf felica reader [-hs@]",
            "options": [
                "-h, --help this help",
                "-s, --silent silent (no messages)",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "hf felica reader -@ -> continuous mode"
            ]
        },
        "hf felica info": {
            "command": "hf felica info",
            "offline": false,
            "description": "reader for felica based tags",
            "usage": "hf felica info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf felica info"
            ]
        },
        "hf felica sniff": {
            "command": "hf felica sniff",
            "offline": false,
            "description": "collect data from the field and save into command buffer. buffer accessible from `hf felica list`",
            "usage": "hf felica sniff [-h] [-s <dec>] [-t <dec>]",
            "options": [
                "-h, --help this help",
                "-s, --samples <dec> samples to skip",
                "-t, --trig <dec> triggers to skip"
            ],
            "notes": [
                "hf felica sniff",
                "hf felica sniff -s 10 -t 19"
            ]
        },
        "hf felica raw": {
            "command": "hf felica raw",
            "offline": false,
            "description": "send raw hex data to tag",
            "usage": "hf felica raw [-hackrs] [-n <dec>] <hex> [<hex>]...",
            "options": [
                "-h, --help this help",
                "-a active signal field on without select",
                "-c calculate and append crc",
                "-k keep signal field on after receive",
                "-n <dec> number of bits",
                "-r do not read response",
                "-s active signal field on with select",
                "<hex> raw bytes to send"
            ],
            "notes": [
                "hf felica raw -cs 20",
                "hf felica raw -cs 2008"
            ]
        },
        "hf felica rdbl": {
            "command": "hf felica rdbl",
            "offline": false,
            "description": "use this command to read block data from authentication-not-required service. - mode shall be mode0. - successful == block data - unsuccessful == status flag1 and flag2",
            "usage": "hf felica rdbl [-hblv] [-i <hex>] [--sn <hex>] [--scl <hex>] [--bn <hex>] [--ble <hex>]",
            "options": [
                "-h, --help this help",
                "-b get all block list elements 00 -> ff",
                "-i <hex> set custom idm",
                "-l, --long use 3 byte block list element block number",
                "--sn <hex> number of service",
                "--scl <hex> service code list",
                "--bn <hex> number of block",
                "--ble <hex> block list element (def 2|3 bytes)",
                "-v, --verbose verbose helptext"
            ],
            "notes": [
                "hf felica rdbl --sn 01 --scl 8b00 --bn 01 --ble 8000",
                "hf felica rdbl --sn 01 --scl 4b18 --bn 01 --ble 8000 -b",
                "hf felica rdbl -i 01100910c11bc407 --sn 01 --scl 8b00 --bn 01 --ble 8000"
            ]
        },
        "hf felica wrbl": {
            "command": "hf felica wrbl",
            "offline": false,
            "description": "use this command to write block data to authentication-not-required service. - mode shall be mode0. - un-/ssuccessful == status flag1 and flag2",
            "usage": "hf felica wrbl [-hv] [-d <hex>] [-i <hex>] [--sn <hex>] [--scl <hex>] [--bn <hex>] [--ble <hex>]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> data, 16 hex bytes",
                "-i <hex> set custom idm",
                "--sn <hex> number of service",
                "--scl <hex> service code list",
                "--bn <hex> number of block",
                "--ble <hex> block list element (def 2|3 bytes)",
                "-v, --verbose verbose helptext"
            ],
            "notes": [
                "hf felica wrbl --sn 01 --scl cb10 --bn 01 --ble 8001 -d 0102030405060708090a0b0c0d0e0f10",
                "hf felica wrbl -i 01100910c11bc407 --sn 01 --scl cb10 --bn 01 --ble 8001 -d 0102030405060708090a0b0c0d0e0f10"
            ]
        },
        "hf felica rqservice": {
            "command": "hf felica rqservice",
            "offline": false,
            "description": "use this command to verify the existence of area and service, and to acquire key version: - when the specified area or service exists, the card returns key version. - when the specified area or service does not exist, the card returns ffffh as key version. for node code list of a command packet, area code or service code of the target of acquisition of key version shall be enumerated in little endian format. if key version of system is the target of acquisition, ffffh shall be specified in the command packet.",
            "usage": "hf felica rqservice [-ha] [-n <hex>] [-c <hex>] [-i <hex>]",
            "options": [
                "-h, --help this help",
                "-a, --all auto node number mode, iterates through all nodes 1 < n < 32",
                "-n, --node <hex> number of node",
                "-c, --code <hex> node code list (little endian)",
                "-i, --idm <hex> use custom idm"
            ],
            "notes": [
                "hf felcia rqservice --node 01 --code ffff",
                "hf felcia rqservice -a --code ffff",
                "hf felica rqservice -i 011204126417e405 --node 01 --code ffff"
            ]
        },
        "hf felica rqresponse": {
            "command": "hf felica rqresponse",
            "offline": false,
            "description": "use this command to verify the existence of a card and its mode. - current mode of the card is returned",
            "usage": "hf felica rqresponse [-h] [-i <hex>]",
            "options": [
                "-h, --help this help",
                "-i <hex> set custom idm"
            ],
            "notes": [
                "hf felica rqresponse -i 11100910c11bc407"
            ]
        },
        "hf felica scsvcode": {
            "command": "hf felica scsvcode",
            "offline": false,
            "description": "feature not implemented yet. feel free to contribute!",
            "usage": "hf felica scsvcode [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf felica scsvcode"
            ]
        },
        "hf felica rqsyscode": {
            "command": "hf felica rqsyscode",
            "offline": false,
            "description": "use this command to acquire system code registered to the card. - if a card is divided into more than one system, this command acquires system code of each system existing in the card.",
            "usage": "hf felica rqsyscode [-h] [-i <hex>]",
            "options": [
                "-h, --help this help",
                "-i <hex> set custom idm"
            ],
            "notes": [
                "hf felica rqsyscode",
                "hf felica rqsyscode -i 11100910c11bc407"
            ]
        },
        "hf felica auth1": {
            "command": "hf felica auth1",
            "offline": false,
            "description": "initiate mutual authentication. this command must always be executed before auth2 command and mutual authentication is achieve only after auth2 command has succeeded. incomplete / experimental command!!!",
            "usage": "hf felica auth1 [-hv] [--an <hex>] [--acl <hex>] [-i <hex>] [--sn <hex>] [--scl <hex>] [-k <hex>]",
            "options": [
                "-h, --help this help",
                "--an <hex> number of areas, 1 byte",
                "--acl <hex> area code list, 2 bytes",
                "-i <hex> set custom idm",
                "--sn <hex> number of service, 1 byte",
                "--scl <hex> service code list, 2 bytes",
                "-k, --key <hex> 3des key, 16 bytes",
                "-v, --verbose verbose helptext"
            ],
            "notes": [
                "hf felica auth1 --an 01 --acl 0000 --sn 01 --scl 8b00 --key aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb",
                "hf felica auth1 --an 01 --acl 0000 --sn 01 --scl 8b00 --key aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaa",
                "hf felica auth1 -i 11100910c11bc407 --an 01 --acl 0000 --sn 01 ..scl 8b00 --key aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb"
            ]
        },
        "hf felica auth2": {
            "command": "hf felica auth2",
            "offline": false,
            "description": "complete mutual authentication. this command can only be executed subsquent to auth1 incomplete / experimental command!!! experimental command - m2c/p2c will be not checked",
            "usage": "hf felica auth2 [-hv] [-i <hex>] [-c <hex>] [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-i <hex> set custom idm",
                "-c, --cc <hex> m3c card challenge, 8 bytes",
                "-k, --key <hex> 3des m3c decryption key, 16 bytes",
                "-v, --verbose verbose helptext"
            ],
            "notes": [
                "hf felica auth2 --cc 0102030405060708 --key aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb",
                "hf felica auth2 -i 11100910c11bc407 --cc 0102030405060708 --key aaaaaaaaaaaaaaaabbbbbbbbbbbbbbbb"
            ]
        },
        "hf felica rqspecver": {
            "command": "hf felica rqspecver",
            "offline": false,
            "description": "use this command to acquire the version of card os. response: - format version: fixed value 00h. provided only if status flag1 = 00h - basic version: each value of version is expressed in bcd notation. provided only if status flag1 = 00h - number of option: value = 0: aes card, value = 1: aes/des card. provided only if status flag1 = 00h - option version list: provided only if status flag1 = 00h - aes card: not added - aes/des card: des option version is added - bcd notation",
            "usage": "hf felica rqspecver [-hv] [-i <hex>] [-r <hex>]",
            "options": [
                "-h, --help this help",
                "-i <hex> set custom idm",
                "-r <hex> set custom reserve",
                "-v, --verbose verbose helptext"
            ],
            "notes": [
                "hf felica rqspecver",
                "hf felica rqspecver -r 0001",
                "hf felica rqspecver -i 11100910c11bc407"
            ]
        },
        "hf felica resetmode": {
            "command": "hf felica resetmode",
            "offline": false,
            "description": "use this command to reset mode to mode 0.",
            "usage": "hf felica resetmode [-hv] [-i <hex>] [-r <hex>]",
            "options": [
                "-h, --help this help",
                "-i <hex> set custom idm",
                "-r <hex> set custom reserve",
                "-v, --verbose verbose helptext"
            ],
            "notes": [
                "hf felica resetmode",
                "hf felica resetmode -r 0001",
                "hf felica resetmode -i 11100910c11bc407"
            ]
        },
        "hf felica litesim": {
            "command": "hf felica litesim",
            "offline": false,
            "description": "emulating iso/18092 felica lite tag",
            "usage": "hf felica litesim [-h] -u <hex>",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> uid/ndef2 8 hex bytes"
            ],
            "notes": [
                "hf felica litesim -u 1122334455667788"
            ]
        },
        "hf felica litedump": {
            "command": "hf felica litedump",
            "offline": false,
            "description": "dump iso/18092 felica lite tag. it will timeout after 200sec",
            "usage": "hf felica litedump [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf felica litedump"
            ]
        },
        "hf fido help": {
            "command": "hf fido help",
            "offline": true,
            "description": "help this help. list list iso 14443a history --------------------------------------------------------------------------------------- hf fido list available offline: yes alias of `trace list -t 14a` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf fido list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf fido list -f -> show frame delay times",
                "hf fido list -1 -> use trace buffer"
            ]
        },
        "hf fido info": {
            "command": "hf fido info",
            "offline": false,
            "description": "get info from fido tags",
            "usage": "hf fido info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf fido info"
            ]
        },
        "hf fido reg": {
            "command": "hf fido reg",
            "offline": false,
            "description": "initiate a u2f token registration. needs two 32-byte hash numbers. challenge parameter (32b) and application parameter (32b).",
            "usage": "hf fido reg [-havpt] [-j fido.json] [--cp <hex/ascii>] [--ap <hex/ascii>]",
            "options": [
                "-h, --help this help",
                "-a, --apdu show apdu requests and responses",
                "-v, --verbose show technical data. vv - show full certificates data",
                "-p, --plain send plain ascii to challenge and application parameters instead of hex",
                "-t, --tlv show der certificate contents in tlv representation",
                "-j, --json fido.json json input / output file name for parameters.",
                "--cp <hex/ascii> challenge parameter (32 bytes hex / 1..16 chars)",
                "--ap <hex/ascii> application parameter (32 bytes hex / 1..16 chars)"
            ],
            "notes": [
                "hf fido reg -> execute command with 2 parameters, filled 0x00",
                "hf fido reg -p s0 s1 -> execute command with plain parameters",
                "hf fido reg --cp 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f --ap 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f"
            ]
        },
        "hf fido auth": {
            "command": "hf fido auth",
            "offline": false,
            "description": "initiate a u2f token authentication. needs key handle and two 32-byte hash numbers. key handle(var 0..255), challenge parameter (32b) and application parameter (32b)",
            "usage": "hf fido auth [-havpuc] default mode: [-j fido.json] [-k <hex>] [--kh <hex>] [--cp <hex/ascii>] [--ap <hex/ascii>]",
            "options": [
                "-h, --help this help",
                "-a, --apdu show apdu reqests and responses",
                "-v, --verbose show technical data",
                "-p, --plain send plain ascii to challenge and application parameters instead of hex",
                "default mode: dont-enforce-user-presence-and-sign",
                "-u, --user mode: enforce-user-presence-and-sign",
                "-c, --check mode: check-only",
                "-j, --json fido.json json input / output file name for parameters.",
                "-k, --key <hex> public key to verify signature",
                "--kh <hex> key handle (var 0..255b)",
                "--cp <hex/ascii> challenge parameter (32 bytes hex / 1..16 chars)",
                "--ap <hex/ascii> application parameter (32 bytes hex / 1..16 chars)"
            ],
            "notes": [
                "hf fido auth --kh 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f -> execute command with 2 parameters, filled 0x00 and key handle",
                "hf fido auth",
                "--kh 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f",
                "--cp 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f",
                "--ap 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f -> execute command with parameters"
            ]
        },
        "hf fido make": {
            "command": "hf fido make",
            "offline": false,
            "description": "execute a fido2 make credential command. needs json file with parameters. sample file `fido2.json` in `client/resources/`.",
            "usage": "hf fido make [-havtc] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-a, --apdu show apdu reqests and responses",
                "-v, --verbose show technical data. vv - show full certificates data",
                "-t, --tlv show der certificate contents in tlv representation",
                "-c, --cbor show cbor decoded data",
                "-f, --file <fn> parameter json file name. (def `fido2.json`)"
            ],
            "notes": [
                "hf fido make -> default parameters file `fido2.json`",
                "hf fido make -f test.json -> use parameters file `text.json`"
            ]
        },
        "hf fido assert": {
            "command": "hf fido assert",
            "offline": false,
            "description": "execute a fido2 get assertion command. needs json file with parameters. sample file `fido2.json` in `client/resources/`. - needs if `rk` option is `false` (authenticator doesn't store credential to its memory)",
            "usage": "hf fido assert [-havcl] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-a, --apdu show apdu reqests and responses",
                "-v, --verbose show technical data. vv - show full certificates data",
                "-c, --cbor show cbor decoded data",
                "-l, --list add credentialid from json to allowlist.",
                "-f, --file <fn> parameter json file name. (def `fido2.json`)"
            ],
            "notes": [
                "hf fido assert -> default parameters file `fido2.json`",
                "hf fido assert -f test.json -l -> use parameters file `text.json` and add to request credentialid"
            ]
        },
        "hf jooki help": {
            "command": "hf jooki help",
            "offline": true,
            "description": "help this help decode decode jooki token encode encode jooki token --------------------------------------------------------------------------------------- hf jooki clone available offline: no write a jooki token to a ultralight or ntag tag",
            "usage": "hf jooki clone [-h] [-b <base64>] [-d <hex>] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-b, --b64 <base64> base64 url parameter",
                "-d, --data <hex> raw ndef bytes",
                "-p, --pwd <hex> password for authentication (ev1/ntag 4 bytes)"
            ],
            "notes": [
                "hf jooki clone -d <hex bytes> -> where hex is raw ndef",
                "hf jooki clone --b64 7wzlgezqlgwtnwny -> using base64 url parameter"
            ]
        },
        "hf jooki decode": {
            "command": "hf jooki decode",
            "offline": true,
            "description": "decode a base64-encode jooki token in ndef uri format",
            "usage": "hf jooki decode [-hv] -d <base64>",
            "options": [
                "-h, --help this help",
                "-d, --data <base64> base64 url parameter",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf jooki decode -d 7wzlgezqlgwtnwny"
            ]
        },
        "hf jooki encode": {
            "command": "hf jooki encode",
            "offline": true,
            "description": "encode a jooki token to base64 ndef uri format",
            "usage": "hf jooki encode [-hrtv] [-u <hex>] [--dragon] [--fox] [--ghost] [--knight] [--whale] [--blackdragon] [--blackfox] [--blackknight] [--blackwhale] [--whitedragon] [--whitefox] [--whiteknight] [--whitewhale] [--tid <dec>] [--fid <dec>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> uid bytes",
                "-r read uid from tag instead",
                "-t selftest",
                "-v, --verbose verbose output",
                "--dragon figurine type",
                "--fox figurine type",
                "--ghost figurine type",
                "--knight figurine type",
                "--whale figurine type",
                "--blackdragon figurine type",
                "--blackfox figurine type",
                "--blackknight figurine type",
                "--blackwhale figurine type",
                "--whitedragon figurine type",
                "--whitefox figurine type",
                "--whiteknight figurine type",
                "--whitewhale figurine type",
                "--tid <dec> figurine type id",
                "--fid <dec> figurine id"
            ],
            "notes": [
                "hf jooki encode -t -> selftest",
                "hf jooki encode -r --dragon -> read uid from tag and use for encoding",
                "hf jooki encode --uid 04010203040506 --dragon",
                "hf jooki encode --uid 04010203040506 --tid 1 --fid 1"
            ]
        },
        "hf jooki sim": {
            "command": "hf jooki sim",
            "offline": false,
            "description": "simulate a jooki token. either `hf mfu eload` before or use `-d` param",
            "usage": "hf jooki sim [-h] [-b <base64>]",
            "options": [
                "-h, --help this help",
                "-b, --b64 <base64> base64 url parameter"
            ],
            "notes": [
                "hf jooki sim -> use token in emulator memory",
                "hf jooki sim -b 7wzlgezqlgwtnwny -> using base64 url parameter"
            ]
        },
        "hf iclass help": {
            "command": "hf iclass help",
            "offline": true,
            "description": "----------- --------------------- operations --------------------- help this help info tag information list list iclass history ----------- --------------------- recovery --------------------- loclass use loclass to perform bruteforce reader attack lookup uses authentication trace to check for key in dictionary file ----------- --------------------- simulation --------------------- ----------- --------------------- utils --------------------- configcard reader configuration card calcnewkey calc diversified keys (blocks 3 & 4) to write new keys encode encode binary wiegand to block 7 encrypt encrypt given block data decrypt decrypt given block data or tag dump file managekeys manage keys to use with iclass commands view display content from tag dump file --------------------------------------------------------------------------------------- hf iclass dump available offline: no dump all memory from a iclass tag",
            "usage": "hf iclass dump [-h] [-f <fn>] [-k <hex>] [--ki <dec>] [--credit <hex>] [--ci <dec>] [--elite] [--raw] [--nr]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> save filename",
                "-k, --key <hex> debit key or nr/mac for replay as 8 hex bytes",
                "--ki <dec> debit key index to select key from memory 'hf iclass managekeys'",
                "--credit <hex> credit key as 8 hex bytes",
                "--ci <dec> credit key index to select key from memory 'hf iclass managekeys'",
                "--elite elite computations applied to key",
                "--raw raw, the key is interpreted as raw block 3/4",
                "--nr replay of nr/mac"
            ],
            "notes": [
                "hf iclass dump -k 001122334455667b",
                "hf iclass dump -k aaaaaaaaaaaaaaaa --credit 001122334455667b",
                "hf iclass dump -k aaaaaaaaaaaaaaaa --elite",
                "hf iclass dump --ki 0",
                "hf iclass dump --ki 0 --ci 2"
            ]
        },
        "hf iclass info": {
            "command": "hf iclass info",
            "offline": true,
            "description": "act as a iclass reader. reads / fingerprints a iclass tag.",
            "usage": "hf iclass info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf iclass info"
            ]
        },
        "hf iclass list": {
            "command": "hf iclass list",
            "offline": true,
            "description": "alias of `trace list -t iclass` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf iclass list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf iclass list -f -> show frame delay times",
                "hf iclass list -1 -> use trace buffer"
            ]
        },
        "hf iclass rdbl": {
            "command": "hf iclass rdbl",
            "offline": false,
            "description": "read a iclass block from tag",
            "usage": "hf iclass rdbl [-hv] [-k <hex>] [--ki <dec>] -b <dec> [--credit] [--elite] [--raw] [--nr]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> access key as 8 hex bytes",
                "--ki <dec> key index to select key from memory 'hf iclass managekeys'",
                "-b, --block <dec> the block number to read",
                "--credit key is assumed to be the credit key",
                "--elite elite computations applied to key",
                "--raw no computations applied to key",
                "--nr replay of nr/mac",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf iclass rdbl -b 6 -k 0011223344556677",
                "hf iclass rdbl -b 27 -k 0011223344556677 --credit",
                "hf iclass rdbl -b 10 --ki 0"
            ]
        },
        "hf iclass reader": {
            "command": "hf iclass reader",
            "offline": false,
            "description": "act as a iclass reader. look for iclass tags until enter or the pm3 button is pressed",
            "usage": "hf iclass reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "hf iclass reader -@ -> continuous reader mode"
            ]
        },
        "hf iclass restore": {
            "command": "hf iclass restore",
            "offline": false,
            "description": "restore data from dumpfile onto a iclass tag",
            "usage": "hf iclass restore [-hv] -f <fn> [-k <hex>] [--ki <dec>] --first <dec> --last <dec> [--credit] [--elite] [--raw]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> specify a filename to restore (bin/eml/json)",
                "-k, --key <hex> access key as 8 hex bytes",
                "--ki <dec> key index to select key from memory 'hf iclass managekeys'",
                "--first <dec> the first block number to restore",
                "--last <dec> the last block number to restore",
                "--credit key is assumed to be the credit key",
                "--elite elite computations applied to key",
                "--raw no computations applied to key",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf iclass restore -f hf-iclass-aa162d30f8ff12f1-dump.bin --first 6 --last 18 --ki 0",
                "hf iclass restore -f hf-iclass-aa162d30f8ff12f1-dump.bin --first 6 --last 18 --ki 0 --elite",
                "hf iclass restore -f hf-iclass-aa162d30f8ff12f1-dump.bin --first 6 --last 18 -k 1122334455667788 --elite"
            ]
        },
        "hf iclass sniff": {
            "command": "hf iclass sniff",
            "offline": false,
            "description": "sniff the communication reader and tag",
            "usage": "hf iclass sniff [-hj]",
            "options": [
                "-h, --help this help",
                "-j, --jam jam (prevent) e-purse updates"
            ],
            "notes": [
                "hf iclass sniff",
                "hf iclass sniff -j -> jam e-purse updates"
            ]
        },
        "hf iclass wrbl": {
            "command": "hf iclass wrbl",
            "offline": false,
            "description": "write data to an iclass tag",
            "usage": "hf iclass wrbl [-hv] [-k <hex>] [--ki <dec>] -b <dec> -d <hex> [--credit] [--elite] [--raw] [--nr]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> access key as 8 hex bytes",
                "--ki <dec> key index to select key from memory 'hf iclass managekeys'",
                "-b, --block <dec> the block number to read",
                "-d, --data <hex> data to write as 8 hex bytes",
                "--credit key is assumed to be the credit key",
                "--elite elite computations applied to key",
                "--raw no computations applied to key",
                "--nr replay of nr/mac",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf iclass wrbl -b 10 -d aaaaaaaaaaaaaaaa -k 001122334455667b",
                "hf iclass wrbl -b 10 -d aaaaaaaaaaaaaaaa -k 001122334455667b --credit",
                "hf iclass wrbl -b 10 -d aaaaaaaaaaaaaaaa --ki 0"
            ]
        },
        "hf iclass chk": {
            "command": "hf iclass chk",
            "offline": false,
            "description": "checkkeys loads a dictionary text file with 8byte hex keys to test authenticating against a iclass tag",
            "usage": "hf iclass chk [-h] -f <fn> [--credit] [--elite] [--raw]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> dictionary file with default iclass keys",
                "--credit key is assumed to be the credit key",
                "--elite elite computations applied to key",
                "--raw no computations applied to key (raw)"
            ],
            "notes": [
                "hf iclass chk -f iclass_default_keys.dic",
                "hf iclass chk -f iclass_default_keys.dic --elite"
            ]
        },
        "hf iclass loclass": {
            "command": "hf iclass loclass",
            "offline": true,
            "description": "execute the offline part of loclass attack an iclass dumpfile is assumed to consist of an arbitrary number of malicious csns, and their protocol responses the binary format of the file is expected to be as follows: <8 byte csn><8 byte cc><4 byte nr><4 byte mac> <8 byte csn><8 byte cc><4 byte nr><4 byte mac> <8 byte csn><8 byte cc><4 byte nr><4 byte mac> ... totalling n*24 bytes",
            "usage": "hf iclass loclass [-h] [-f <fn>] [--test] [--long]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename with nr/mac data from `hf iclass sim -t 2`",
                "--test perform self-test",
                "--long perform self-test, including long ones"
            ],
            "notes": [
                "hf iclass loclass -f iclass_dump.bin",
                "hf iclass loclass --test"
            ]
        },
        "hf iclass lookup": {
            "command": "hf iclass lookup",
            "offline": true,
            "description": "lookup keys takes some sniffed trace data and tries to verify what key was used against a dictionary file",
            "usage": "hf iclass lookup [-h] -f <fn> --csn <hex> --epurse <hex> --macs <hex> [--elite] [--raw]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> dictionary file with default iclass keys",
                "--csn <hex> specify csn as 8 hex bytes",
                "--epurse <hex> specify epurse as 8 hex bytes",
                "--macs <hex> macs",
                "--elite elite computations applied to key",
                "--raw no computations applied to key"
            ],
            "notes": [
                "hf iclass lookup --csn 9655a400f8ff12e0 --epurse f0ffffffffffffff --macs 0000000089cb984b -f iclass_default_keys.dic",
                "hf iclass lookup --csn 9655a400f8ff12e0 --epurse f0ffffffffffffff --macs 0000000089cb984b -f iclass_default_keys.dic --elite"
            ]
        },
        "hf iclass sim": {
            "command": "hf iclass sim",
            "offline": false,
            "description": "simulate a iclass legacy/standard tag",
            "usage": "hf iclass sim [-h] -t <0-4> [--csn <hex>]",
            "options": [
                "-h, --help this help",
                "-t, --type <0-4> simulation type to use",
                "--csn <hex> specify csn as 8 hex bytes to use with sim type 0"
            ],
            "notes": [
                "hf iclass sim -t 0 --csn 031fec8af7ff12e0 -> simulate with specficied csn",
                "hf iclass sim -t 1 -> simulate with default csn",
                "hf iclass sim -t 2 -> execute loclass attack online part",
                "hf iclass sim -t 3 -> simulate full iclass 2k tag",
                "hf iclass sim -t 4 -> reader-attack, adapted for keyroll mode, gather reader responses to extract elite key"
            ]
        },
        "hf iclass eload": {
            "command": "hf iclass eload",
            "offline": false,
            "description": "load emulator memory with data from (bin/eml/json) iclass dump file",
            "usage": "hf iclass eload [-h] -f <fn>",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump (bin/eml/json)"
            ],
            "notes": [
                "hf iclass eload -f hf-iclass-aa162d30f8ff12f1-dump.bin",
                "hf iclass eload -f hf-iclass-aa162d30f8ff12f1-dump.eml"
            ]
        },
        "hf iclass esave": {
            "command": "hf iclass esave",
            "offline": false,
            "description": "save emulator memory to file. if filename is not supplied, csn will be used.",
            "usage": "hf iclass esave [-h] [-f <fn>] [-s <256|2048>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump file",
                "-s, --size <256|2048> number of bytes to save (default 256)"
            ],
            "notes": [
                "hf iclass esave",
                "hf iclass esave -f hf-iclass-dump",
                "hf iclass esave -s 2048 -f hf-iclass-dump"
            ]
        },
        "hf iclass eview": {
            "command": "hf iclass eview",
            "offline": false,
            "description": "display emulator memory. number of bytes to download defaults to 256. other value is 2048.",
            "usage": "hf iclass eview [-hv] [-s <256|2048>]",
            "options": [
                "-h, --help this help",
                "-s, --size <256|2048> number of bytes to save (default 256)",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf iclass eview",
                "hf iclass eview -s 2048",
                "hf iclass eview -s 2048 -v"
            ]
        },
        "hf iclass configcard": {
            "command": "hf iclass configcard",
            "offline": true,
            "description": "manage reader configuration card via cardhelper, the generated config card will be uploaded to device emulator memory. you can start simulating `hf iclass sim -t 3` or use the emul commands",
            "usage": "hf iclass configcard [-hglp] [--ci <dec>] [--ki <dec>]",
            "options": [
                "-h, --help this help",
                "--ci <dec> use config slot at index",
                "--ki <dec> key index to select key from memory 'hf iclass managekeys'",
                "-g generate card dump file",
                "-l load available cards",
                "-p print available cards"
            ],
            "notes": [
                "hf iclass configcard -l -> download config card settings",
                "hf iclass configcard -p -> print all config cards",
                "hf iclass configcard --ci 1 -> view config card setting in slot 1",
                "hf iclass configcard -g --ci 0 -> generate config file from slot 0"
            ]
        },
        "hf iclass calcnewkey": {
            "command": "hf iclass calcnewkey",
            "offline": true,
            "description": "calculate new keys for updating (blocks 3 & 4)",
            "usage": "hf iclass calcnewkey [-h] [--old <hex>] [--oki <dec>] [--new <hex>] [--nki <dec>] [--csn <hex>] [--elite] [--elite2]",
            "options": [
                "-h, --help this help",
                "--old <hex> specify key as 8 hex bytes",
                "--oki <dec> old key index to select key from memory 'hf iclass managekeys'",
                "--new <hex> specify key as 8 hex bytes",
                "--nki <dec> new key index to select key from memory 'hf iclass managekeys'",
                "--csn <hex> specify a card serial number (csn) to diversify the key (if omitted will attempt to read a csn)",
                "--elite elite computations applied to new key",
                "--elite2 elite computations applied to both old and new key"
            ],
            "notes": [
                "hf iclass calcnewkey --old 1122334455667788 --new 2233445566778899 --csn deadbeafdeadbeaf --elite2 -> e key to e key given csn",
                "hf iclass calcnewkey --old 1122334455667788 --new 2233445566778899 --elite -> std key to e key read csn",
                "hf iclass calcnewkey --old 1122334455667788 --new 2233445566778899 -> std to std read csn"
            ]
        },
        "hf iclass encode": {
            "command": "hf iclass encode",
            "offline": true,
            "description": "encode binary wiegand to block 7",
            "usage": "hf iclass encode [-h] --bin <bin> --ki <dec> [--credit] [--elite] [--raw] [--enckey <hex>]",
            "options": [
                "-h, --help this help",
                "--bin <bin> binary string i.e 0001001001",
                "--ki <dec> key index to select key from memory 'hf iclass managekeys'",
                "--credit key is assumed to be the credit key",
                "--elite elite computations applied to key",
                "--raw no computations applied to key",
                "--enckey <hex> 3des transport key, 16 hex bytes"
            ],
            "notes": [
                "hf iclass encode --bin 10001111100000001010100011 --ki 0 -> fc 31 cn 337",
                "hf iclass encode --bin 10001111100000001010100011 --ki 0 --elite -> fc 31 cn 337, writing w elite key"
            ]
        },
        "hf iclass encrypt": {
            "command": "hf iclass encrypt",
            "offline": true,
            "description": "3des encrypt data obs! in order to use this function, the file 'iclass_decryptionkey.bin' must reside in the resources directory. the file should be 16 hex bytes of binary data",
            "usage": "hf iclass encrypt [-hv] -d <hex> [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> data to encrypt",
                "-k, --key <hex> 3des transport key",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf iclass encrypt -d 0102030405060708",
                "hf iclass encrypt -d 0102030405060708 -k 00112233445566778899aabbccddeeff"
            ]
        },
        "hf iclass decrypt": {
            "command": "hf iclass decrypt",
            "offline": true,
            "description": "3des decrypt data this is a naive implementation, it tries to decrypt every block after block 6. correct behaviour would be to decrypt only the application areas where the key is valid, which is defined by the configuration block. obs! in order to use this function, the file `iclass_decryptionkey.bin` must reside in the resources directory. the file should be 16 bytes binary data or... make sure your cardhelper is placed in the sim module",
            "usage": "hf iclass decrypt [-hv] [-f <fn>] [-d <hex>] [-k <hex>] [--d6]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump file (bin/eml/json)",
                "-d, --data <hex> 3des encrypted data",
                "-k, --key <hex> 3des transport key",
                "-v, --verbose verbose output",
                "--d6 decode as block 6"
            ],
            "notes": [
                "hf iclass decrypt -f hf-iclass-aa162d30f8ff12f1-dump.bin",
                "hf iclass decrypt -f hf-iclass-aa162d30f8ff12f1-dump.bin -k 000102030405060708090a0b0c0d0e0f",
                "hf iclass decrypt -d 1122334455667788 -k 000102030405060708090a0b0c0d0e0f"
            ]
        },
        "hf iclass managekeys": {
            "command": "hf iclass managekeys",
            "offline": true,
            "description": "manage iclass keys in client memory",
            "usage": "hf iclass managekeys [-hp] [-f <fn>] [-k <hex>] [--ki <dec>] [--save] [--load]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> specify a filename for load / save operations",
                "-k, --key <hex> access key as 8 hex bytes",
                "--ki <dec> specify key index to set key in memory",
                "--save save keys in memory to file specified by filename",
                "--load load keys to memory from file specified by filename",
                "-p, --print print keys loaded into memory"
            ],
            "notes": [
                "hf iclass managekeys --ki 0 -k 1122334455667788 -> set key 1122334455667788 at index 0",
                "hf iclass managekeys -f mykeys.bin --save -> save key file",
                "hf iclass managekeys -f mykeys.bin --load -> load key file",
                "hf iclass managekeys -p -> print keys"
            ]
        },
        "hf iclass permutekey": {
            "command": "hf iclass permutekey",
            "offline": false,
            "description": "permute function from 'heart of darkness' paper.",
            "usage": "hf iclass permutekey [-hr] --key <hex>",
            "options": [
                "-h, --help this help",
                "-r, --reverse reverse permuted key",
                "--key <hex> input key, 8 hex bytes"
            ],
            "notes": [
                "hf iclass permutekey --reverse --key 0123456789abcdef",
                "hf iclass permutekey --key ff55330f0055330f"
            ]
        },
        "hf iclass view": {
            "command": "hf iclass view",
            "offline": true,
            "description": "print a iclass tag dump file (bin/eml/json)",
            "usage": "hf iclass view [-hv] -f <fn> [--first <dec>] [--last <dec>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump (bin/eml/json)",
                "--first <dec> begin printing from this block (default block 6)",
                "--last <dec> end printing at this block (default 0, all)",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf iclass view -f hf-iclass-aa162d30f8ff12f1-dump.bin",
                "hf iclass view --first 1 -f hf-iclass-aa162d30f8ff12f1-dump.bin"
            ]
        },
        "hf legic help": {
            "command": "hf legic help",
            "offline": true,
            "description": "help this help list list legic history crc calculate legic crc over given bytes eload load binary dump to emulator memory esave save emulator memory to binary file --------------------------------------------------------------------------------------- hf legic list available offline: yes alias of `trace list -t legic` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf legic list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf legic list -f -> show frame delay times",
                "hf legic list -1 -> use trace buffer"
            ]
        },
        "hf legic reader": {
            "command": "hf legic reader",
            "offline": false,
            "description": "read uid and type information from a legic prime tag",
            "usage": "hf legic reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "hf legic reader"
            ]
        },
        "hf legic info": {
            "command": "hf legic info",
            "offline": false,
            "description": "gets information from a legic prime tag like systemarea, user areas, etc",
            "usage": "hf legic info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf legic info"
            ]
        },
        "hf legic dump": {
            "command": "hf legic dump",
            "offline": false,
            "description": "read all memory from legic prime mim22, mim256, mim1024 and saves bin/eml/json dump file it autodetects card type.",
            "usage": "hf legic dump [-h] [-f <filename>] [--de]",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> specify a filename for dump file",
                "--de deobfuscate dump data (xor with mcc)"
            ],
            "notes": [
                "hf legic dump -> use uid as filename",
                "hf legic dump -f myfile -> use user specified filename",
                "hf legic dump --de -> use uid as filename and deobfuscate data"
            ]
        },
        "hf legic restore": {
            "command": "hf legic restore",
            "offline": false,
            "description": "reads binary file and it autodetects card type and verifies that the file has the same size then write the data back to card. all bytes except the first 7bytes [uid(4) mcc(1) dcf(2)]",
            "usage": "hf legic restore [-h] -f <filename> [--ob]",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> specify a filename to restore",
                "--ob obfuscate dump data (xor with mcc)"
            ],
            "notes": [
                "hf legic restore -f myfile -> use user specified filename",
                "hf legic restore -f myfile --ob -> use uid as filename and obfuscate data"
            ]
        },
        "hf legic rdbl": {
            "command": "hf legic rdbl",
            "offline": false,
            "description": "read data from a legic prime tag",
            "usage": "hf legic rdbl [-h] -o <dec> -l <dec> [--iv <hex>]",
            "options": [
                "-h, --help this help",
                "-o, --offset <dec> offset in data array to start download from",
                "-l, --length <dec> number of bytes to read",
                "--iv <hex> initialization vector to use. must be odd and 7bits max"
            ],
            "notes": [
                "hf legic rdbl -o 0 -l 16 -> reads from byte[0] 16 bytes(system header)",
                "hf legic rdbl -o 0 -l 4 --iv 55 -> reads from byte[0] 4 bytes with iv 0x55",
                "hf legic rdbl -o 0 -l 256 --iv 55 -> reads from byte[0] 256 bytes with iv 0x55"
            ]
        },
        "hf legic sim": {
            "command": "hf legic sim",
            "offline": false,
            "description": "simulates a legic prime tag. mim22, mim256, mim1024 types can be emulated",
            "usage": "hf legic sim [-h] [-t <dec>]",
            "options": [
                "-h, --help this help",
                "-t, --type <dec> tag type to simulate."
            ],
            "notes": [
                "hf legic sim -t 0 -> simulate type mim22",
                "hf legic sim -t 1 -> simulate type mim256 (default)",
                "hf legic sim -t 2 -> simulate type mim1024"
            ]
        },
        "hf legic wrbl": {
            "command": "hf legic wrbl",
            "offline": false,
            "description": "write data to a legic prime tag. it autodetects tagsize to ensure proper write",
            "usage": "hf legic wrbl [-h] -o <dec> -d <hex> [--danger]",
            "options": [
                "-h, --help this help",
                "-o, --offset <dec> offset in data array to start writing",
                "-d, --data <hex> data to write",
                "--danger auto-confirm dangerous operations"
            ],
            "notes": [
                "hf legic wrbl -o 0 -d 11223344 -> write 0x11223344 starting from offset 0)",
                "hf legic wrbl -o 10 -d deadbeef -> write 0xdeadbeef starting from offset 10"
            ]
        },
        "hf legic crc": {
            "command": "hf legic crc",
            "offline": true,
            "description": "calculates the legic crc8/crc16 on the given data",
            "usage": "hf legic crc [-h] -d <hex> [--mcc <hex>] [-t <dec>]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to calculate crc over",
                "--mcc <hex> mcc hex byte (uid crc)",
                "-t, --type <dec> crc type (default: 8)"
            ],
            "notes": [
                "hf legic crc -d deadbeef1122",
                "hf legic crc -d deadbeef1122 --mcc 9a -t 16 -> crc type 16"
            ]
        },
        "hf legic eload": {
            "command": "hf legic eload",
            "offline": true,
            "description": "loads a legic binary dump into emulator memory",
            "usage": "hf legic eload [-h] -f <filename> [-t <dec>] [--obfuscate]",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> specify a filename to restore",
                "-t, --type <dec> tag type to simulate.",
                "--obfuscate obfuscate dump data (xor with mcc)"
            ],
            "notes": [
                "hf legic eload -f myfile -t 0 -> simulate type mim22",
                "hf legic eload -f myfile -t 1 -> simulate type mim256 (default)",
                "hf legic eload -f myfile -t 2 -> simulate type mim1024"
            ]
        },
        "hf legic esave": {
            "command": "hf legic esave",
            "offline": true,
            "description": "saves bin/eml/json dump file of emulator memory",
            "usage": "hf legic esave [-h] [-f <filename>] [-t <dec>] [--deobfuscate]",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> specify a filename to save",
                "-t, --type <dec> tag type",
                "--deobfuscate de-obfuscate dump data (xor with mcc)"
            ],
            "notes": [
                "hf legic esave -> uses uid as filename",
                "hf legic esave -f myfile -t 0 -> type mim22",
                "hf legic esave -f myfile -t 1 -> type mim256 (default)",
                "hf legic esave -f myfile -t 2 -> type mim1024"
            ]
        },
        "hf legic wipe": {
            "command": "hf legic wipe",
            "offline": false,
            "description": "fills a legic prime tags memory with zeros. from byte7 and to the end it autodetects card type",
            "usage": "hf legic wipe [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf legic wipe"
            ]
        },
        "hf lto help": {
            "command": "hf lto help",
            "offline": true,
            "description": "help this help list list lto-cm history --------------------------------------------------------------------------------------- hf lto dump available offline: no dump data from lto tag",
            "usage": "hf lto dump [-h] -f <filename>",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> specify a filename for dumpfile"
            ],
            "notes": [
                "hf lto dump -f myfile"
            ]
        },
        "hf lto restore": {
            "command": "hf lto restore",
            "offline": false,
            "description": "restore data from dumpfile to lto tag",
            "usage": "hf lto restore [-h] -f <filename>",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> specify a filename for dumpfile"
            ],
            "notes": [
                "hf lto restore -f hf-lto-92c7842cff.bin|.eml"
            ]
        },
        "hf lto info": {
            "command": "hf lto info",
            "offline": false,
            "description": "get info from lto tags",
            "usage": "hf lto info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf lto info"
            ]
        },
        "hf lto rdbl": {
            "command": "hf lto rdbl",
            "offline": false,
            "description": "reead blocks from lto tag",
            "usage": "hf lto rdbl [-h] [--first <dec>] [--last <dec>]",
            "options": [
                "-h, --help this help",
                "--first <dec> the first block number to read as an integer",
                "--last <dec> the last block number to read as an integer"
            ],
            "notes": [
                "hf lto rdbl --first 0 --last 254"
            ]
        },
        "hf lto wrbl": {
            "command": "hf lto wrbl",
            "offline": false,
            "description": "write data to block on lto tag",
            "usage": "hf lto wrbl [-h] -d <hex> --block <dec>",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> 32 bytes of data to write (64 hex symbols, no spaces)",
                "--block <dec> the block number to write to as an integer"
            ],
            "notes": [
                "hf lto wrbl --block 128 -d 0001020304050607080910111213141516171819202122232425262728293031"
            ]
        },
        "hf lto list": {
            "command": "hf lto list",
            "offline": true,
            "description": "alias of `trace list -t lto` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf lto list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf lto list -f -> show frame delay times",
                "hf lto list -1 -> use trace buffer"
            ]
        },
        "hf mf help": {
            "command": "hf mf help",
            "offline": true,
            "description": "help this help list list mifare history hardnested nested attack for hardened mifare classic cards decrypt [nt] [ar_enc] [at_enc] [data] - to decrypt sniff or trace view display content from tag dump file --------------------------------------------------------------------------------------- hf mf list available offline: yes alias of `trace list -t mf` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf mf list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf mf list -f -> show frame delay times",
                "hf mf list -1 -> use trace buffer"
            ]
        },
        "hf mf darkside": {
            "command": "hf mf darkside",
            "offline": false,
            "description": "darkside attack",
            "usage": "hf mf darkside [-hb] [--blk <dec> ]",
            "options": [
                "-h, --help this help",
                "--blk <dec> simulation type to use",
                "-b target key b instead of default key a"
            ],
            "notes": [
                "hf mf darkside",
                "hf mf darkside --blk 16",
                "hf mf darkside --blk 16 -b"
            ]
        },
        "hf mf nested": {
            "command": "hf mf nested",
            "offline": false,
            "description": "execute nested attack against mifare classic card for key recovery",
            "usage": "hf mf nested [-hab] [-k <hex>] [--mini] [--1k] [--2k] [--4k] [--blk <dec>] [--tblk <dec>] [--ta] [--tb] [--emu] [--dump] [--single]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key specified as 12 hex symbols",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--blk <dec> input block number",
                "-a input key specified is a key (default)",
                "-b input key specified is b key",
                "--tblk <dec> target block number",
                "--ta target a key (default)",
                "--tb target b key",
                "--emu fill simulator keys from found keys",
                "--dump dump found keys to file",
                "--single single sector (defaults to all)"
            ],
            "notes": [
                "hf mf nested --single --blk 0 -a ffffffffffff --tblk 4 --ta -> single sector key recovery. use block 0 key a to find block 4 key a",
                "hf mf nested --mini --blk 0 -a -k ffffffffffff -> key recovery against mifare mini",
                "hf mf nested --1k --blk 0 -a -k ffffffffffff -> key recovery against mifare classic 1k",
                "hf mf nested --2k --blk 0 -a -k ffffffffffff -> key recovery against mifare 2k",
                "hf mf nested --4k --blk 0 -a -k ffffffffffff -> key recovery against mifare 4k"
            ]
        },
        "hf mf hardnested": {
            "command": "hf mf hardnested",
            "offline": true,
            "description": "nested attack for hardened mifare classic cards. `--i<x>` set type of simd instructions. without this flag programs autodetect it. or hf mf hardnested -r --tk [known target key] add the known target key to check if it is present in the remaining key space hf mf hardnested --blk 0 -a -k a0a1a2a3a4a5 --tblk 4 --ta --tk ffffffffffff",
            "usage": "hf mf hardnested [-habrstw] [-k <hex>] [--blk <dec>] [--tblk <dec>] [--ta] [--tb] [--tk <hex>] [-u <hex>] [-f <fn>] [--in] [--im] [--is] [--ia] [--i2] [--i5]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key, 12 hex bytes",
                "--blk <dec> input block number",
                "-a input key a (def)",
                "-b input key b",
                "--tblk <dec> target block number",
                "--ta target key a",
                "--tb target key b",
                "--tk <hex> target key, 12 hex bytes",
                "-u, --uid <hex> r/w `hf-mf-<uid>-nonces.bin` instead of default name",
                "-f, --file <fn> r/w <name> instead of default name",
                "-r, --read read `hf-mf-<uid>-nonces.bin` if tag present, otherwise `nonces.bin`, and start attack",
                "-s, --slow slower acquisition (required by some non standard cards)",
                "-t, --tests run tests",
                "-w, --wr acquire nonces and uid, and write them to file `hf-mf-<uid>-nonces.bin`",
                "--in none (use cpu regular instruction set)",
                "--im mmx",
                "--is sse2",
                "--ia avx",
                "--i2 avx2",
                "--i5 avx512"
            ],
            "notes": [
                "hf mf hardnested --blk 0 -a -k ffffffffffff --tblk 4 --ta",
                "hf mf hardnested --blk 0 -a -k ffffffffffff --tblk 4 --ta -w",
                "hf mf hardnested --blk 0 -a -k ffffffffffff --tblk 4 --ta -f nonces.bin -w -s",
                "hf mf hardnested -r",
                "hf mf hardnested -r --tk a0a1a2a3a4a5",
                "hf mf hardnested -t --tk a0a1a2a3a4a5",
                "hf mf hardnested --blk 0 -a -k a0a1a2a3a4a5 --tblk 4 --ta --tk ffffffffffff"
            ]
        },
        "hf mf staticnested": {
            "command": "hf mf staticnested",
            "offline": false,
            "description": "execute nested attack against mifare classic card with static nonce for key recovery",
            "usage": "hf mf staticnested [-habe] [-k <hex>] [--mini] [--1k] [--2k] [--4k] [--blk <dec>] [--dumpkeys]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key specified as 12 hex symbols",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--blk <dec> input block number",
                "-a input key specified is a key (default)",
                "-b input key specified is b key",
                "-e, --emukeys fill simulator keys from found keys",
                "--dumpkeys dump found keys to file"
            ],
            "notes": [
                "hf mf staticnested --mini --blk 0 -a -k ffffffffffff -> key recovery against mifare mini",
                "hf mf staticnested --1k --blk 0 -a -k ffffffffffff -> key recovery against mifare classic 1k",
                "hf mf staticnested --2k --blk 0 -a -k ffffffffffff -> key recovery against mifare 2k",
                "hf mf staticnested --4k --blk 0 -a -k ffffffffffff -> key recovery against mifare 4k"
            ]
        },
        "hf mf autopwn": {
            "command": "hf mf autopwn",
            "offline": false,
            "description": "this command automates the key recovery process on mifare classic cards. it uses the fchk, chk, darkside, nested, hardnested and staticnested to recover keys. if all keys are found, it try dumping card content both to file and emulator memory.",
            "usage": "hf mf autopwn [-habslv] [-k <hex>] [-s <dec>] [-f <fn>] [--mini] [--1k] [--2k] [--4k] [--in] [--im] [--is] [--ia] [--i2] [--i5]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> known key, 12 hex bytes",
                "-s, --sector <dec> input sector number",
                "-a input key a (def)",
                "-b input key b",
                "-f, --file <fn> filename of dictionary",
                "-s, --slow slower acquisition (required by some non standard cards)",
                "-l, --legacy legacy mode (use the slow `hf mf chk`)",
                "-v, --verbose verbose output (statistics)",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (default)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--in none (use cpu regular instruction set)",
                "--im mmx",
                "--is sse2",
                "--ia avx",
                "--i2 avx2",
                "--i5 avx512"
            ],
            "notes": [
                "hf mf autopwn",
                "hf mf autopwn -s 0 -a -k ffffffffffff -> target mfc 1k card, sector 0 with known key a 'ffffffffffff'",
                "hf mf autopwn --1k -f mfc_default_keys -> target mfc 1k card, default dictionary",
                "hf mf autopwn --1k -s 0 -a -k ffffffffffff -f mfc_default_keys -> combo of the two above samples"
            ]
        },
        "hf mf nack": {
            "command": "hf mf nack",
            "offline": false,
            "description": "test a mifare classic based card for the nack bug",
            "usage": "hf mf nack [-hv]",
            "options": [
                "-h, --help this help",
                "-v, --verbose verbose output`"
            ],
            "notes": [
                "hf mf nack"
            ]
        },
        "hf mf chk": {
            "command": "hf mf chk",
            "offline": false,
            "description": "check keys on mifare classic card",
            "usage": "hf mf chk [-hab*] [-k <hex>]... [--blk <dec>] [--mini] [--1k] [--2k] [--4k] [--emu] [--dump] [-f <filename>]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key specified as 12 hex symbols",
                "--blk <dec> input block number",
                "-a target key a, if found also check key b for duplicate",
                "-b target key b",
                "-*, --all target both key a & b (default)",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (default)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--emu fill simulator keys from found keys",
                "--dump dump found keys to binary file",
                "-f, --file <filename> filename of dictionary"
            ],
            "notes": [
                "hf mf chk --mini -k ffffffffffff -> check all sectors, all keys against mifare mini",
                "hf mf chk --1k -k ffffffffffff -> check all sectors, all keys against mifare classic 1k",
                "hf mf chk --2k -k ffffffffffff -> check all sectors, all keys against mifare 2k",
                "hf mf chk --4k -k ffffffffffff -> check all sectors, all keys against mifare 4k",
                "hf mf chk --1k --emu -> check all sectors, all keys, 1k, and write to emulator memory",
                "hf mf chk --1k --dump -> check all sectors, all keys, 1k, and write to file",
                "hf mf chk -a --blk 0 -f mfc_default_keys.dic -> check dictionary against block 0, key a"
            ]
        },
        "hf mf fchk": {
            "command": "hf mf fchk",
            "offline": false,
            "description": "this is a improved checkkeys method speedwise. it checks mifare classic tags sector keys against a dictionary file with keys",
            "usage": "hf mf fchk [-h] [-k <hex>]... [--mini] [--1k] [--2k] [--4k] [--emu] [--dump] [--mem] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key specified as 12 hex symbols",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (default)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--emu fill simulator keys from found keys",
                "--dump dump found keys to binary file",
                "--mem use dictionary from flashmemory",
                "-f, --file <fn> filename of dictionary"
            ],
            "notes": [
                "hf mf fchk --mini -k ffffffffffff -> key recovery against mifare mini",
                "hf mf fchk --1k -k ffffffffffff -> key recovery against mifare classic 1k",
                "hf mf fchk --2k -k ffffffffffff -> key recovery against mifare 2k",
                "hf mf fchk --4k -k ffffffffffff -> key recovery against mifare 4k",
                "hf mf fchk --1k -f mfc_default_keys.dic -> target 1k using default dictionary file",
                "hf mf fchk --1k --emu -> target 1k, write to emulator memory",
                "hf mf fchk --1k --dump -> target 1k, write to file",
                "hf mf fchk --1k --mem -> target 1k, use dictionary from flashmemory"
            ]
        },
        "hf mf decrypt": {
            "command": "hf mf decrypt",
            "offline": true,
            "description": "decrypt crypto-1 encrypted bytes given some known state of crypto. see tracelog to gather needed values",
            "usage": "hf mf decrypt [-h] --nt <hex> --ar <hex> --at <hex> -d <hex>",
            "options": [
                "-h, --help this help",
                "--nt <hex> tag nonce",
                "--ar <hex> ar_enc, encrypted reader response",
                "--at <hex> at_enc, encrypted tag response",
                "-d, --data <hex> encrypted data, taken directly after at_enc and forward"
            ],
            "notes": [
                "hf mf decrypt --nt b830049b --ar 9248314a --at 9280e203 -d 41e586f9",
                "-> 41e586f9 becomes 3003999a",
                "-> which annotates 30 03 [99 9a] read block 3 [crc]"
            ]
        },
        "hf mf supercard": {
            "command": "hf mf supercard",
            "offline": false,
            "description": "extract info from a `super card`",
            "usage": "hf mf supercard [-hr]",
            "options": [
                "-h, --help this help",
                "-r, --reset reset card"
            ],
            "notes": [
                "hf mf supercard"
            ]
        },
        "hf mf auth4": {
            "command": "hf mf auth4",
            "offline": false,
            "description": "executes aes authentication command in iso14443-4",
            "usage": "hf mf auth4 [-h] <key num (hex 2 bytes)> <key value (hex 16 bytes)>",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mf auth4 4000 000102030405060708090a0b0c0d0e0f -> executes authentication",
                "hf mf auth4 9003 ffffffffffffffffffffffffffffffff -> executes authentication"
            ]
        },
        "hf mf dump": {
            "command": "hf mf dump",
            "offline": false,
            "description": "dump mifare classic tag to binary file if no <name> given, uid will be used as filename",
            "usage": "hf mf dump [-h] [-f <fn>] [-k <fn>] [--mini] [--1k] [--2k] [--4k]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump",
                "-k, --keys <fn> filename of keys",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70"
            ],
            "notes": [
                "hf mf dump --mini -> mifare mini",
                "hf mf dump --1k -> mifare classic 1k",
                "hf mf dump --2k -> mifare 2k",
                "hf mf dump --4k -> mifare 4k",
                "hf mf dump --keys hf-mf-066c8b78-key.bin -> mifare 1k with keys from specified file"
            ]
        },
        "hf mf mad": {
            "command": "hf mf mad",
            "offline": false,
            "description": "checks and prints mifare application directory (mad)",
            "usage": "hf mf mad [-hvb] [--aid <aid>] [-k <key>] [--be] [--dch]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show technical data",
                "--aid <aid> print all sectors with specified aid",
                "-k, --key <key> key for printing sectors",
                "-b, --keyb use key b for access printing sectors (by default: key a)",
                "--be (optional, bigendian)",
                "--dch decode card holder information"
            ],
            "notes": [
                "hf mf mad -> shows mad if exists",
                "hf mf mad --aid e103 -k ffffffffffff -b -> shows ndef data if exists. read card with custom key and key b",
                "hf mf mad --dch -k ffffffffffff -> decode cardholder information"
            ]
        },
        "hf mf ndef": {
            "command": "hf mf ndef",
            "offline": false,
            "description": "prints nfc data exchange format (ndef)",
            "usage": "hf mf ndef [-hvb] [--aid <aid>] [-k <key>]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show technical data",
                "--aid <aid> replace default aid for ndef",
                "-k, --key <key> replace default key for ndef",
                "-b, --keyb use key b for access sectors (by default: key a)"
            ],
            "notes": [
                "hf mf ndef -> shows ndef parsed data",
                "hf mf ndef -vv -> shows ndef parsed and raw data",
                "hf mf ndef --aid e103 -k ffffffffffff -b -> shows ndef data with custom aid, key and with key b"
            ]
        },
        "hf mf personalize": {
            "command": "hf mf personalize",
            "offline": false,
            "description": "personalize the uid of a mifare classic ev1 card. this is only possible if it is a 7byte uid card and if it is not already personalized.",
            "usage": "hf mf personalize [-hab] [-k <hex>] [--f0] [--f1] [--f2] [--f3]",
            "options": [
                "-h, --help this help",
                "-a use key a to authenticate sector 0 (def)",
                "-b use key b to authenticate sector 0",
                "-k, --key <hex> key (def ffffffffffff)",
                "--f0 uidfo, double size uid",
                "--f1 uidf1, double size uid, optional usage of selection process shortcut",
                "--f2 uidf2, single size random id",
                "--f3 uidf3, single size nuid"
            ],
            "notes": [
                "hf mf personalize -f0 -> double size uid",
                "hf mf personalize -f1 -> double size uid, optional usage of selection process shortcut",
                "hf mf personalize -f2 -> single size random id",
                "hf mf personalize -f3 -> single size nuid",
                "hf mf personalize -b -k b0b1b2b3b4b5 -f3 -> use key b = 0xb0b1b2b3b4b5"
            ]
        },
        "hf mf rdbl": {
            "command": "hf mf rdbl",
            "offline": false,
            "description": "read mifare classic block",
            "usage": "hf mf rdbl [-habv] --blk <dec> [-k <hex>]",
            "options": [
                "-h, --help this help",
                "--blk <dec> block number",
                "-a input key type is key a (def)",
                "-b input key type is key b",
                "-k, --key <hex> key, 6 hex bytes",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf rdbl --blk 0 -k ffffffffffff",
                "hf mf rdbl -b 3 -v -> get block 3, decode sector trailer"
            ]
        },
        "hf mf rdsc": {
            "command": "hf mf rdsc",
            "offline": false,
            "description": "read mifare classic sector",
            "usage": "hf mf rdsc [-habv] [-k <hex>] -s <dec>",
            "options": [
                "-h, --help this help",
                "-a input key specified is a key (def)",
                "-b input key specified is b key",
                "-k, --key <hex> key specified as 6 hex bytes",
                "-s, --sec <dec> sector number",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf rdsc -s 0 -k ffffffffffff"
            ]
        },
        "hf mf restore": {
            "command": "hf mf restore",
            "offline": false,
            "description": "restore mifare classic binary file to tag. the key file and data file will program the card sector trailers. by default we authenticate to card with key b 0xffffffffffff. `--uid` param is used for filename templates `hf-mf-<uid>-dump.bin` and `hf-mf-<uid>-key.bin. if not specified, it will read the card uid instead. `-w` param you can indicate that the key file should be used for authentication instead. if so we also try both b/a keys",
            "usage": "hf mf restore [-h] [--mini] [--1k] [--2k] [--4k] [-u <hex>] [-f <fn>] [-k <fn>] [--ka]",
            "options": [
                "-h, --help this help",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "-u, --uid <hex> uid, 6 hex bytes",
                "-f, --file <fn> data filename",
                "-k, --kfn <fn> key filename",
                "--ka use specified keyfile to authenticate"
            ],
            "notes": [
                "hf mf restore",
                "hf mf restore --1k --uid 04010203",
                "hf mf restore --1k --uid 04010203 -k hf-mf-aabbccdd-key.bin",
                "hf mf restore --4k"
            ]
        },
        "hf mf setmod": {
            "command": "hf mf setmod",
            "offline": false,
            "description": "sets the load modulation strength of a mifare classic ev1 card",
            "usage": "hf mf setmod [-h01] [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-0 normal modulation",
                "-1 strong modulation (def)",
                "-k, --key <hex> key a, sector 0, 6 hex bytes"
            ],
            "notes": [
                "hf mf setmod -k ffffffffffff -0"
            ]
        },
        "hf mf view": {
            "command": "hf mf view",
            "offline": true,
            "description": "print a mifare classic dump file (bin/eml/json)",
            "usage": "hf mf view [-hv] -f <fn>",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf view -f hf-mf-01020304-dump.bin"
            ]
        },
        "hf mf wipe": {
            "command": "hf mf wipe",
            "offline": false,
            "description": "wipe card to zeros and default keys/acc. this command taks a key file to wipe card new a/b keys ff ff ff ff ff ff new acc ff 07 80 new gdb 69",
            "usage": "hf mf wipe [-h] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> key filename"
            ],
            "notes": [
                "hf mf wipe"
            ]
        },
        "hf mf wrbl": {
            "command": "hf mf wrbl",
            "offline": false,
            "description": "write mifare classic block",
            "usage": "hf mf wrbl [-hab] --blk <dec> [-k <hex>] [-d <hex>]",
            "options": [
                "-h, --help this help",
                "--blk <dec> block number",
                "-a input key type is key a (def)",
                "-b input key type is key b",
                "-k, --key <hex> key, 6 hex bytes",
                "-d, --data <hex> bytes to write, 16 hex bytes"
            ],
            "notes": [
                "hf mf wrbl --blk 1 -k ffffffffffff -d 000102030405060708090a0b0c0d0e0f"
            ]
        },
        "hf mf sim": {
            "command": "hf mf sim",
            "offline": false,
            "description": "simulate mifare classic card",
            "usage": "hf mf sim [-hixev] [-u <hex>] [--mini] [--1k] [--2k] [--4k] [--atqa <hex>] [--sak <hex>] [-n <dec> ]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> uid 4,7 or 10bytes. if not specified, the uid 4b/7b from emulator memory will be used",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--atqa <hex> provide explicit atqa (2 bytes, overrides option t)",
                "--sak <hex> provide explicit sak (1 bytes, overrides option t)",
                "-n, --num <dec> automatically exit simulation after <numreads> blocks have been read by reader. 0 = infinite",
                "-i, --interactive console will not be returned until simulation finishes or is aborted",
                "-x performs the 'reader attack', nr/ar attack against a reader",
                "-e, --emukeys fill simulator keys from found keys",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf sim --mini -> mifare mini",
                "hf mf sim --1k -> mifare classic 1k (default)",
                "hf mf sim --1k -u 0a0a0a0a -> mifare classic 1k with 4b uid",
                "hf mf sim --1k -u 11223344556677 -> mifare classic 1k with 7b uid",
                "hf mf sim --1k -u 11223344 -i --crack -> perform reader attack in interactive mode",
                "hf mf sim --2k -> mifare 2k",
                "hf mf sim --4k -> mifare 4k"
            ]
        },
        "hf mf ecfill": {
            "command": "hf mf ecfill",
            "offline": false,
            "description": "dump card and transfer the data to emulator memory. keys must be laid in the emulator memory",
            "usage": "hf mf ecfill [-hab] [--mini] [--1k] [--2k] [--4k]",
            "options": [
                "-h, --help this help",
                "-a input key type is key a(def)",
                "-b input key type is key b",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70"
            ],
            "notes": [
                "hf mf ecfill -> use key type a",
                "hf mf ecfill --4k -b -> target 4k card with key type b"
            ]
        },
        "hf mf eclr": {
            "command": "hf mf eclr",
            "offline": false,
            "description": "it set card emulator memory to empty data blocks and key a/b ffffffffffff",
            "usage": "hf mf eclr [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mf eclr"
            ]
        },
        "hf mf egetblk": {
            "command": "hf mf egetblk",
            "offline": false,
            "description": "get emulator memory block",
            "usage": "hf mf egetblk [-hv] -b <dec>",
            "options": [
                "-h, --help this help",
                "-b, --blk <dec> block number",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf egetblk --blk 0 -> get block 0 (manufacturer)",
                "hf mf egetblk --blk 3 -v -> get block 3, decode sector trailer"
            ]
        },
        "hf mf egetsc": {
            "command": "hf mf egetsc",
            "offline": false,
            "description": "get emulator memory sector",
            "usage": "hf mf egetsc [-hv] -s <dec>",
            "options": [
                "-h, --help this help",
                "-s, --sec <dec> sector number",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf egetsc -s 0"
            ]
        },
        "hf mf ekeyprn": {
            "command": "hf mf ekeyprn",
            "offline": false,
            "description": "download and print the keys from emulator memory",
            "usage": "hf mf ekeyprn [-hw] [--mini] [--1k] [--2k] [--4k]",
            "options": [
                "-h, --help this help",
                "-w, --write write keys to binary file `hf-mf-<uid>-key.bin`",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70"
            ],
            "notes": [
                "hf mf ekeyprn --1k -> print mfc 1k keyset",
                "hf mf ekeyprn -w -> write keys to binary file"
            ]
        },
        "hf mf eload": {
            "command": "hf mf eload",
            "offline": false,
            "description": "load emulator memory with data from (bin/eml/json) dump file",
            "usage": "hf mf eload [-h] -f <fn> [--mini] [--1k] [--2k] [--4k] [--ul] [-q <dec>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--ul mifare ultralight family",
                "-q, --qty <dec> manually set number of blocks (overrides)"
            ],
            "notes": [
                "hf mf eload -f hf-mf-01020304.bin",
                "hf mf eload --4k -f hf-mf-01020304.eml"
            ]
        },
        "hf mf esave": {
            "command": "hf mf esave",
            "offline": false,
            "description": "save emulator memory into three files (bin/eml/json)",
            "usage": "hf mf esave [-h] [-f <fn>] [--mini] [--1k] [--2k] [--4k]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70"
            ],
            "notes": [
                "hf mf esave",
                "hf mf esave --4k",
                "hf mf esave --4k -f hf-mf-01020304.eml"
            ]
        },
        "hf mf esetblk": {
            "command": "hf mf esetblk",
            "offline": false,
            "description": "set emulator memory block",
            "usage": "hf mf esetblk [-h] -b <dec> [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-b, --blk <dec> block number",
                "-d, --data <hex> bytes to write, 16 hex bytes"
            ],
            "notes": [
                "hf mf esetblk --blk 1 -d 000102030405060708090a0b0c0d0e0f"
            ]
        },
        "hf mf eview": {
            "command": "hf mf eview",
            "offline": false,
            "description": "it displays emulator memory",
            "usage": "hf mf eview [-h] [--mini] [--1k] [--2k] [--4k]",
            "options": [
                "-h, --help this help",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70"
            ],
            "notes": [
                "hf mf eview",
                "hf mf eview --4k"
            ]
        },
        "hf mf cgetblk": {
            "command": "hf mf cgetblk",
            "offline": false,
            "description": "get block data from magic chinese card. only works with magic gen1a cards",
            "usage": "hf mf cgetblk [-hv] -b <dec>",
            "options": [
                "-h, --help this help",
                "-b, --blk <dec> block number",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf cgetblk --blk 0 -> get block 0 (manufacturer)",
                "hf mf cgetblk --blk 3 -v -> get block 3, decode sector trailer"
            ]
        },
        "hf mf cgetsc": {
            "command": "hf mf cgetsc",
            "offline": false,
            "description": "get sector data from magic chinese card. only works with magic gen1a cards",
            "usage": "hf mf cgetsc [-hv] -s <dec>",
            "options": [
                "-h, --help this help",
                "-s, --sec <dec> sector number",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mf cgetsc -s 0"
            ]
        },
        "hf mf cload": {
            "command": "hf mf cload",
            "offline": false,
            "description": "load magic gen1a card with data from (bin/eml/json) dump file or from emulator memory.",
            "usage": "hf mf cload [-h] -f <fn> [--emu]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump",
                "--emu from emulator memory"
            ],
            "notes": [
                "hf mf cload --emu",
                "hf mf cload -f hf-mf-01020304.eml"
            ]
        },
        "hf mf csave": {
            "command": "hf mf csave",
            "offline": false,
            "description": "save magic gen1a card memory into three files (bin/eml/json)or into emulator memory",
            "usage": "hf mf csave [-h] [-f <fn>] [--mini] [--1k] [--2k] [--4k] [--emu]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70",
                "--emu from emulator memory"
            ],
            "notes": [
                "hf mf csave",
                "hf mf csave --4k"
            ]
        },
        "hf mf csetblk": {
            "command": "hf mf csetblk",
            "offline": false,
            "description": "set block data on a magic gen1a card",
            "usage": "hf mf csetblk [-hw] -b <dec> [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-b, --blk <dec> block number",
                "-d, --data <hex> bytes to write, 16 hex bytes",
                "-w, --wipe wipes card with backdoor cmd before writing"
            ],
            "notes": [
                "hf mf csetblk --blk 1 -d 000102030405060708090a0b0c0d0e0f"
            ]
        },
        "hf mf csetuid": {
            "command": "hf mf csetuid",
            "offline": false,
            "description": "set uid, atqa, and sak for magic gen1a card",
            "usage": "hf mf csetuid [-hw] [-u <hex>] [-a <hex>] [-s <hex>]",
            "options": [
                "-h, --help this help",
                "-w, --wipe wipes card with backdoor cmd`",
                "-u, --uid <hex> uid, 4/7 hex bytes",
                "-a, --atqa <hex> atqa, 2 hex bytes",
                "-s, --sak <hex> sak, 1 hex byte"
            ],
            "notes": [
                "hf mf csetuid -u 01020304",
                "hf mf csetuid -w -u 01020304 --atqa 0004 --sak 08"
            ]
        },
        "hf mf cview": {
            "command": "hf mf cview",
            "offline": false,
            "description": "view `magic gen1a` card memory",
            "usage": "hf mf cview [-h] [--mini] [--1k] [--2k] [--4k]",
            "options": [
                "-h, --help this help",
                "--mini mifare classic mini / s20",
                "--1k mifare classic 1k / s50 (def)",
                "--2k mifare classic/plus 2k",
                "--4k mifare classic 4k / s70"
            ],
            "notes": [
                "hf mf cview",
                "hf mf cview --4k"
            ]
        },
        "hf mf cwipe": {
            "command": "hf mf cwipe",
            "offline": false,
            "description": "wipe gen1 magic chinese card. set uid / atqa / sak / data / keys / access to default values",
            "usage": "hf mf cwipe [-h] [-u <hex>] [-a <hex>] [-s <hex>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> uid, 4 hex bytes",
                "-a, --atqa <hex> atqa, 2 hex bytes",
                "-s, --sak <hex> sak, 1 hex byte"
            ],
            "notes": [
                "hf mf cwipe",
                "hf mf cwipe -u 09080706 -a 0004 -s 18 -> set uid, atqa and sak and wipe card"
            ]
        },
        "hf mf gen3uid": {
            "command": "hf mf gen3uid",
            "offline": false,
            "description": "set uid for magic gen3 card _without_ changes to manufacturer block 0",
            "usage": "hf mf gen3uid [-h] [-u <hex>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> uid 4/7 hex bytes"
            ],
            "notes": [
                "hf mf gen3uid --uid 01020304 -> set 4 byte uid",
                "hf mf gen3uid --uid 01020304050607 -> set 7 byte uid"
            ]
        },
        "hf mf gen3blk": {
            "command": "hf mf gen3blk",
            "offline": false,
            "description": "overwrite full manufacturer block for magic gen3 card - you can specify part of manufacturer block as 4/7-bytes for uid change only note: bcc, sak, atqa will be calculated automatically",
            "usage": "hf mf gen3blk [-h] [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> manufacturer block data up to 16 hex bytes"
            ],
            "notes": [
                "hf mf gen3blk -> print current data",
                "hf mf gen3blk -d 01020304 -> set 4 byte uid",
                "hf mf gen3blk -d 01020304050607 -> set 7 byte uid",
                "hf mf gen3blk -d 01020304ffffffff0102030405060708"
            ]
        },
        "hf mf gen3freeze": {
            "command": "hf mf gen3freeze",
            "offline": false,
            "description": "perma lock further uid changes. no more uid changes available after operation completed note: operation is ! irreversible !",
            "usage": "hf mf gen3freeze -y[h]",
            "options": [
                "-h, --help this help",
                "-y, --yes confirm uid lock operation"
            ],
            "notes": [
                "hf mf gen3freeze -y"
            ]
        },
        "hf mfp help": {
            "command": "hf mfp help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- hf mfp info available offline: no get info from mifare plus tags",
            "usage": "hf mfp info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mfp info"
            ]
        },
        "hf mfp wrp": {
            "command": "hf mfp wrp",
            "offline": false,
            "description": "executes write perso command. can be used in sl0 mode only.",
            "usage": "hf mfp wrp [-hv] -i <hex> [--key <hex>]...",
            "options": [
                "-h, --help this help",
                "-v, --verbose show internal data.",
                "-i, --ki <hex> key number, 2 hex bytes",
                "--key <hex> key, 16 hex bytes"
            ],
            "notes": [
                "hf mfp wrp --ki 4000 --key 000102030405060708090a0b0c0d0e0f -> write key (00..0f) to key number 4000",
                "hf mfp wrp --ki 4000 -> write default key(0xff..0xff) to key number 4000"
            ]
        },
        "hf mfp initp": {
            "command": "hf mfp initp",
            "offline": false,
            "description": "executes write perso command for all card's keys. can be used in sl0 mode only.",
            "usage": "hf mfp initp [-hv] [-k <hex>]...",
            "options": [
                "-h, --help this help",
                "-v, --verbose show internal data.",
                "-k, --key <hex> key, 16 hex bytes"
            ],
            "notes": [
                "hf mfp initp --key 000102030405060708090a0b0c0d0e0f -> fill all the keys with key (00..0f)",
                "hf mfp initp -vv -> fill all the keys with default key(0xff..0xff) and show all the data exchange"
            ]
        },
        "hf mfp commitp": {
            "command": "hf mfp commitp",
            "offline": false,
            "description": "executes commit perso command. can be used in sl0 mode only.",
            "usage": "hf mfp commitp [-hv]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show internal data."
            ],
            "notes": [
                "hf mfp commitp"
            ]
        },
        "hf mfp auth": {
            "command": "hf mfp auth",
            "offline": false,
            "description": "executes aes authentication command for mifare plus card",
            "usage": "hf mfp auth [-hv] --ki <hex> --key <hex>",
            "options": [
                "-h, --help this help",
                "-v, --verbose show internal data.",
                "--ki <hex> key number, 2 hex bytes",
                "--key <hex> key, 16 hex bytes"
            ],
            "notes": [
                "hf mfp auth --ki 4000 --key 000102030405060708090a0b0c0d0e0f -> executes authentication",
                "hf mfp auth --ki 9003 --key ffffffffffffffffffffffffffffffff -v -> executes authentication and shows all the system data"
            ]
        },
        "hf mfp rdbl": {
            "command": "hf mfp rdbl",
            "offline": false,
            "description": "reads several blocks from mifare plus card",
            "usage": "hf mfp rdbl [-hvbp] [-n <dec>] --blk <dec> [--key <hex>]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show internal data",
                "-n, --count <dec> blocks count (by default 1)",
                "-b, --keyb use key b (by default keya)",
                "-p, --plain plain communication mode between reader and card",
                "--blk <dec> block number (0..255)",
                "--key <hex> key, 16 hex bytes"
            ],
            "notes": [
                "hf mfp rdbl --blk 0 --key 000102030405060708090a0b0c0d0e0f -> executes authentication and read block 0 data",
                "hf mfp rdbl --blk 1 -v -> executes authentication and shows sector 1 data with default key 0xff..0xff"
            ]
        },
        "hf mfp rdsc": {
            "command": "hf mfp rdsc",
            "offline": false,
            "description": "reads one sector from mifare plus card",
            "usage": "hf mfp rdsc [-hvbp] --sn <dec> [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show internal data.",
                "-b, --keyb use key b (by default keya).",
                "-p, --plain plain communication mode between reader and card.",
                "--sn <dec> sector number (0..255)",
                "-k, --key <hex> key, 16 hex bytes"
            ],
            "notes": [
                "hf mfp rdsc --sn 0 --key 000102030405060708090a0b0c0d0e0f -> executes authentication and read sector 0 data",
                "hf mfp rdsc --sn 1 -v -> executes authentication and shows sector 1 data with default key"
            ]
        },
        "hf mfp wrbl": {
            "command": "hf mfp wrbl",
            "offline": false,
            "description": "writes one block to mifare plus card",
            "usage": "hf mfp wrbl [-hvb] --blk <dec> -d <hex> [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show internal data.",
                "-b, --keyb use key b (by default keya).",
                "--blk <dec> block number (0..255)",
                "-d, --data <hex> data, 16 hex bytes",
                "-k, --key <hex> key, 16 hex bytes"
            ],
            "notes": [
                "hf mfp wrbl --blk 1 -d ff0000000000000000000000000000ff --key 000102030405060708090a0b0c0d0e0f -> writes block 1 data",
                "hf mfp wrbl --blk 2 -d ff0000000000000000000000000000ff -v -> writes block 2 data with default key 0xff..0xff"
            ]
        },
        "hf mfp chk": {
            "command": "hf mfp chk",
            "offline": false,
            "description": "checks keys with mifare plus card.",
            "usage": "hf mfp chk [-habv] [-s start sector num (0..255)] [-e end sector num (0..255)] [-k <key>] [-d <file>] [--pattern1b] [--pattern2b] [--startp2b <pattern>] [-j <file>]",
            "options": [
                "-h, --help this help",
                "-a, --keya check only key a (by default check all keys).",
                "-b, --keyb check only key b (by default check all keys).",
                "-k, --key <key> key for checking (hex 16 bytes)",
                "-d, --dict <file> file with keys dictionary",
                "--pattern1b check all 1-byte combinations of key (0000...0000, 0101...0101, 0202...0202, ...)",
                "--pattern2b check all 2-byte combinations of key (0000...0000, 0001...0001, 0002...0002, ...)",
                "--startp2b <pattern> start key (2-byte hex) for 2-byte search (use with `--pattern2b`)",
                "-j, --json <file> json file to save keys",
                "-v, --verbose verbose mode."
            ],
            "notes": [
                "hf mfp chk -k 000102030405060708090a0b0c0d0e0f -> check key on sector 0 as key a and b",
                "hf mfp chk -s 2 -a -> check default key list on sector 2, key a",
                "hf mfp chk -d mfp_default_keys -s0 -e6 -> check keys from dictionary against sectors 0-6",
                "hf mfp chk --pattern1b -j keys -> check all 1-byte keys pattern and save found keys to json",
                "hf mfp chk --pattern2b --startp2b fa00 -> check all 2-byte keys pattern. start from key fa00fa00...fa00"
            ]
        },
        "hf mfp mad": {
            "command": "hf mfp mad",
            "offline": false,
            "description": "checks and prints mifare application directory (mad)",
            "usage": "hf mfp mad [-hvb] [--aid <aid>] [-k <key>] [--be] [--dch]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show technical data",
                "--aid <aid> print all sectors with aid",
                "-k, --key <key> key for printing sectors",
                "-b, --keyb use key b for access printing sectors (by default: key a)",
                "--be (optional, bigendian)",
                "--dch decode card holder information"
            ],
            "notes": [
                "hf mfp mad -> shows mad if exists",
                "hf mfp mad -a e103 -k d3f7d3f7d3f7d3f7d3f7d3f7d3f7d3f7 -> shows ndef data if exists"
            ]
        },
        "hf mfp ndef": {
            "command": "hf mfp ndef",
            "offline": false,
            "description": "prints nfc data exchange format (ndef)",
            "usage": "hf mfp ndef [-hvb] [--aid <aid>] [-k <key>]",
            "options": [
                "-h, --help this help",
                "-v, --verbose show technical data",
                "--aid <aid> replace default aid for ndef",
                "-k, --key <key> replace default key for ndef",
                "-b, --keyb use key b for access sectors (by default: key a)"
            ],
            "notes": [
                "hf mfp ndef -> shows ndef data",
                "hf mfp ndef -vv -> shows ndef parsed and raw data",
                "hf mfp ndef -a e103 -k d3f7d3f7d3f7d3f7d3f7d3f7d3f7d3f7 -> shows ndef data with custom aid and key"
            ]
        },
        "hf mfu help": {
            "command": "hf mfu help",
            "offline": true,
            "description": "help this help keygen generate 3des mifare diversified keys pwdgen generate pwd from known algos --------------------------------------------------------------------------------------- hf mfu keygen available offline: yes set the 3des key on mifare ultralight-c tag.",
            "usage": "hf mfu keygen [-hr] [-u <hex>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> <4|7> hex byte uid",
                "-r read uid from tag"
            ],
            "notes": [
                "hf mfu keygen -r",
                "hf mfu keygen --uid 11223344556677"
            ]
        },
        "hf mfu pwdgen": {
            "command": "hf mfu pwdgen",
            "offline": true,
            "description": "generate different passwords from known pwdgen algos",
            "usage": "hf mfu pwdgen [-hrt] [-u <hex>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> uid (7 bytes)",
                "-r read uid from tag",
                "-t selftest"
            ],
            "notes": [
                "hf mfu pwdgen -r",
                "hf mfu pwdgen -t",
                "hf mfu pwdgen --uid 11223344556677"
            ]
        },
        "hf mfu otptear": {
            "command": "hf mfu otptear",
            "offline": false,
            "description": "tear-off test against otp block",
            "usage": "hf mfu otptear [-h] [-b <dec>] [-i <dec>] [-e <dec>] [-s <dec>] [-d <hex>] [-t <hex>] [-m <hex>]",
            "options": [
                "-h, --help this help",
                "-b, --blk <dec> target block (def 8)",
                "-i, --inc <dec> increase time steps (def 500 us)",
                "-e, --end <dec> end time (def 3000 us)",
                "-s, --start <dec> start time (def 0 us)",
                "-d, --data <hex> initialise data before run (4 bytes)",
                "-t, --test <hex> test write data (4 bytes, 00000000 by default)",
                "-m, --match <hex> exit criteria, if block matches this value (4 bytes)"
            ],
            "notes": [
                "hf mfu otptear -b 3",
                "hf mfu otptear -b 3 -i 100 -s 1000",
                "hf mfu otptear -b 3 -i 1 -e 200",
                "hf mfu otptear -b 3 -i 100 -s 200 -e 2500 -d ffffffff -t eeeeeeee",
                "hf mfu otptear -b 3 -i 100 -s 200 -e 2500 -d ffffffff -t eeeeeeee -m 00000000 -> quit when otp is reset"
            ]
        },
        "hf mfu cauth": {
            "command": "hf mfu cauth",
            "offline": false,
            "description": "tests 3des password on mifare ultralight-c tag. if password is not specified, a set of known defaults will be tested.",
            "usage": "hf mfu cauth [-hlk] [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key for authentication (ul-c 16 bytes)",
                "-l swap entered key's endianness",
                "-k keep field on (only if a password is provided too)"
            ],
            "notes": [
                "hf mfu cauth",
                "hf mfu cauth --key 000102030405060708090a0b0c0d0e0f"
            ]
        },
        "hf mfu dump": {
            "command": "hf mfu dump",
            "offline": false,
            "description": "reads all pages from ultralight, ultralight-c, ultralight ev1 ntag 203, ntag 210, ntag 212, ntag 213, ntag 215, ntag 216 and saves data into binary/json files. it autodetects card type.",
            "usage": "hf mfu dump [-hl] [-f <fn>] [-k <hex>] [-p <dec>] [-q <dec>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> specify a filename for dump file",
                "-k, --key <hex> key for authentication (ul-c 16 bytes, ev1/ntag 4 bytes)",
                "-l swap entered key's endianness",
                "-p, --page <dec> manually set start page number to start from",
                "-q, --qty <dec> manually set number of pages to dump"
            ],
            "notes": [
                "hf mfu dump -f myfile -> dump whole tag, save to `myfile.bin`",
                "hf mfu dump -k aabbccdd -> dump whole tag using pwd aabbccdd",
                "hf mfu dump -p 10 -> start at page 10 and dump rest of blocks",
                "hf mfu dump -p 10 -q 2 -> start at page 10 and dump two blocks",
                "hf mfu dump --key 00112233445566778899aabbccddeeff"
            ]
        },
        "hf mfu info": {
            "command": "hf mfu info",
            "offline": false,
            "description": "get info about mifare ultralight family styled tag. sometimes the tags are locked down, and you may need a key to be able to read the information",
            "usage": "hf mfu info [-hl] [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key for authentication (ul-c 16 bytes, ev1/ntag 4 bytes)",
                "-l swap entered key's endianness"
            ],
            "notes": [
                "hf mfu info",
                "hf mfu info -k aabbccdd",
                "hf mfu info --key 00112233445566778899aabbccddeeff"
            ]
        },
        "hf mfu ndef": {
            "command": "hf mfu ndef",
            "offline": false,
            "description": "prints nfc data exchange format (ndef)",
            "usage": "hf mfu ndef [-hl] [-k replace default key for ndef]",
            "options": [
                "-h, --help this help",
                "-l swap entered key's endianness"
            ],
            "notes": [
                "hf mfu ndef -> shows ndef data",
                "hf mfu ndef -k ffffffff -> shows ndef data with key"
            ]
        },
        "hf mfu rdbl": {
            "command": "hf mfu rdbl",
            "offline": false,
            "description": "read a block and print. it autodetects card type.",
            "usage": "hf mfu rdbl [-hl] [-k <hex>] -b <dec>",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key for authentication (ul-c 16 bytes, ev1/ntag 4 bytes)",
                "-l swap entered key's endianness",
                "-b, --block <dec> block number to write"
            ],
            "notes": [
                "hf mfu rdbl -b 0",
                "hf mfu rdbl -b 0 -k aabbccdd",
                "hf mfu rdbl -b 0 --key 00112233445566778899aabbccddeeff"
            ]
        },
        "hf mfu restore": {
            "command": "hf mfu restore",
            "offline": false,
            "description": "restore dumpfile onto card.",
            "usage": "hf mfu restore [-hlserv] -f <fn> [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> specify a filename to restore",
                "-k, --key <hex> key for authentication (ul-c 16 bytes, ev1/ntag 4 bytes)",
                "-l swap entered key's endianness",
                "-s enable special write uid -magic tag only-",
                "-e enable special write version/signature -magic ntag 21* only-",
                "-r use the password found in dumpfile to configure tag. requires '-e' parameter to work",
                "-v, --verbose verbose"
            ],
            "notes": [
                "hf mfu restore -f myfile -s -> user specified filename and special write",
                "hf mfu restore -f myfile -k aabbccdd -s -> user specified filename, special write and use key",
                "hf mfu restore -f myfile -k aabbccdd -ser -> user specified filename, special write, use key, ..."
            ]
        },
        "hf mfu wrbl": {
            "command": "hf mfu wrbl",
            "offline": false,
            "description": "write a block. it autodetects card type.",
            "usage": "hf mfu wrbl [-hl] [-k <hex>] -b <dec> -d <hex>",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> key for authentication (ul-c 16 bytes, ev1/ntag 4 bytes)",
                "-l swap entered key's endianness",
                "-b, --block <dec> block number to write",
                "-d, --data <hex> block data (4 or 16 hex bytes, 16 hex bytes will do a compatibility write)"
            ],
            "notes": [
                "hf mfu wrbl -b 0 -d 01234567",
                "hf mfu wrbl -b 0 -d 01234567 -k aabbccdd",
                "hf mfu wrbl -b 0 -d 01234567 -k 00112233445566778899aabbccddeeff"
            ]
        },
        "hf mfu eload": {
            "command": "hf mfu eload",
            "offline": false,
            "description": "load emulator memory with data from `filename.eml` dump file see `script run data_mfu_bin2eml` to convert the .bin to .eml",
            "usage": "hf mfu eload [-h] -f <fn> --ul [-q <dec>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump",
                "--ul mifare ultralight family",
                "-q, --qty <dec> number of blocks to load from eml file"
            ],
            "notes": [
                "hf mfu eload --ul -f hf-mfu-04010203040506.eml",
                "hf mfu eload --ul -f hf-mfu-04010203040506.eml -q 57 -> load 57 blocks from myfile"
            ]
        },
        "hf mfu eview": {
            "command": "hf mfu eview",
            "offline": false,
            "description": "it displays emulator memory",
            "usage": "hf mfu eview [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mfu eview"
            ]
        },
        "hf mfu sim": {
            "command": "hf mfu sim",
            "offline": false,
            "description": "simulate mifare ultralight family type based upon iso/iec 14443 type a tag with 4,7 or 10 byte uid from emulator memory. see `hf mfu eload` first. see `hf 14a sim -h` to see available types. you want 2 or 7 usually.",
            "usage": "hf mfu sim [-hv] -t <1-10> [-u <hex>] [-n <dec>]",
            "options": [
                "-h, --help this help",
                "-t, --type <1-10> simulation type to use",
                "-u, --uid <hex> 4, 7 or 10 byte uid",
                "-n, --num <dec> exit simulation after <numreads> blocks have been read by reader. 0 = infinite",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf mfu sim -t 2 --uid 1122344556677 -> mifare ultralight",
                "hf mfu sim -t 7 --uid 1122344556677 -n 5 -> amiibo (ntag 215), pack 0x8080"
            ]
        },
        "hf mfu setpwd": {
            "command": "hf mfu setpwd",
            "offline": false,
            "description": "set the 3des key on mifare ultralight-c tag.",
            "usage": "hf mfu setpwd [-h] [-k <hex>]",
            "options": [
                "-h, --help this help",
                "-k, --key <hex> new key (16 bytes)"
            ],
            "notes": [
                "hf mfu setpwd --key 000102030405060708090a0b0c0d0e0f"
            ]
        },
        "hf mfu setuid": {
            "command": "hf mfu setuid",
            "offline": false,
            "description": "set uid on mifare ultralight tag. this only works for `magic ultralight` tags.",
            "usage": "hf mfu setuid [-h] [-u <hex>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> new uid (7 bytes)"
            ],
            "notes": [
                "hf mfu setuid --uid 11223344556677"
            ]
        },
        "hf mfdes help": {
            "command": "hf mfdes help",
            "offline": true,
            "description": "help this help list list desfire (iso 14443a) history --------------------------------------------------------------------------------------- hf mfdes auth available offline: no authenticates mifare desfire using key",
            "usage": "hf mfdes auth [-h] [-m <type>] [-t <algo>] [-a <aid>]... [-n <keyno>] [-k <key>] [-d <kdf>] [-i <kdfi>]",
            "options": [
                "-h, --help this help",
                "-m, --type <type> auth type (1=normal, 2=iso, 3=aes)",
                "-t, --algo <algo> crypt algo (1=des, 2=3des(2k2des), 3=3k3des, 4=aes)",
                "-a, --aid <aid> aid used for authentification (hex 3 bytes)",
                "-n, --keyno <keyno> key number used for authentification",
                "-k, --key <key> key for checking (hex 8-24 bytes)",
                "-d, --kdf <kdf> key derivation function (kdf) (0=none, 1=an10922, 2=gallagher)",
                "-i, --kdfi <kdfi> kdf input (hex 1-31 bytes)"
            ],
            "notes": [
                "hf mfdes auth -m 3 -t 4 -a 808301 -n 0 -k 00000000000000000000000000000000 -> aes,keynumber 0, aid 0x803201",
                "hf mfdes auth -m 2 -t 2 -a 000000 -n 1 -k 00000000000000000000000000000000 -> 3des,keynumber 1, aid 0x000000",
                "hf mfdes auth -m 1 -t 1 -a 000000 -n 2 -k 0000000000000000 -> des,keynumber 2, aid 0x000000",
                "hf mfdes auth -m 1 -t 1 -a 000000 -n 0 -> des, defaultkey, aid 0x000000",
                "hf mfdes auth -m 2 -t 2 -a 000000 -n 0 -> 3des, defaultkey, aid 0x000000",
                "hf mfdes auth -m 3 -t 4 -a 000000 -n 0 -> 3k3des, defaultkey, aid 0x000000",
                "hf mfdes auth -m 3 -t 4 -a 000000 -n 0 -> aes, defaultkey, aid 0x000000"
            ]
        },
        "hf mfdes changekey": {
            "command": "hf mfdes changekey",
            "offline": false,
            "description": "changes mifare desfire key make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes changekey [-h] [-n <keyno>] [-t <algo>] [-k <key>] [-u <newalgo>] [-j <newkey>] [-v <aesversion>]",
            "options": [
                "-h, --help this help",
                "-n, --keyno <keyno> key number used for authentification",
                "-t, --algo <algo> current key algo (1=des, 2=3des(2k2des), 3=3k3des, 4=aes)",
                "-k, --key <key> current key (hex 8-24 bytes)",
                "-u, --newalgo <newalgo> new key algo (1=des, 2=3des(2k2des), 3=3k3des, 4=aes)",
                "-j, --newkey <newkey> new key (hex 8-24 bytes)",
                "-v, --aesversion <aesversion> aes version (if aes is used)"
            ],
            "notes": [
                "hf mfdes changekey -n 0 -t 1 -k 0000000000000000 -u 1 -j 0102030405060708 -> des,keynumber 0"
            ]
        },
        "hf mfdes chk": {
            "command": "hf mfdes chk",
            "offline": false,
            "description": "checks keys with mifare desfire card.",
            "usage": "hf mfdes chk [-hv] [-a <aid>]... [-k <key>] [-d <file>] [--pattern1b] [--pattern2b] [--startp2b <pattern>] [-j <file>] [-f <kdf>] [-i <kdfi>]",
            "options": [
                "-h, --help this help",
                "-a, --aid <aid> use specific aid (3 hex bytes, big endian)",
                "-k, --key <key> key for checking (hex 16 bytes)",
                "-d, --dict <file> file with keys dictionary",
                "--pattern1b check all 1-byte combinations of key (0000...0000, 0101...0101, 0202...0202, ...)",
                "--pattern2b check all 2-byte combinations of key (0000...0000, 0001...0001, 0002...0002, ...)",
                "--startp2b <pattern> start key (2-byte hex) for 2-byte search (use with `--pattern2b`)",
                "-j, --json <file> json file to save keys",
                "-v, --verbose verbose mode.",
                "-f, --kdf <kdf> key derivation function (kdf) (0=none, 1=an10922, 2=gallagher)",
                "-i, --kdfi <kdfi> kdf input (hex 1-31 bytes)"
            ],
            "notes": [
                "hf mfdes chk -a 123456 -k 000102030405060708090a0b0c0d0e0f -> check key on aid 0x123456",
                "hf mfdes chk -d mfdes_default_keys -> check keys from dictionary against all existing aid on card",
                "hf mfdes chk -d mfdes_default_keys -a 123456 -> check keys from dictionary against aid 0x123456",
                "hf mfdes chk -a 123456 --pattern1b -j keys -> check all 1-byte keys pattern on aid 0x123456 and save found keys to json",
                "hf mfdes chk -a 123456 --pattern2b --startp2b fa00 -> check all 2-byte keys pattern on aid 0x123456. start from key fa00fa00...fa00"
            ]
        },
        "hf mfdes enum": {
            "command": "hf mfdes enum",
            "offline": false,
            "description": "enumerate all aid's on mifare desfire tag",
            "usage": "hf mfdes enum [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mfdes enum"
            ]
        },
        "hf mfdes formatpicc": {
            "command": "hf mfdes formatpicc",
            "offline": false,
            "description": "formats mifare desfire picc to factory state make sure to authenticate picc before running this command.",
            "usage": "hf mfdes formatpicc [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mfdes formatpicc"
            ]
        },
        "hf mfdes getuid": {
            "command": "hf mfdes getuid",
            "offline": false,
            "description": "get uid from a mifare desfire tag",
            "usage": "hf mfdes getuid [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mfdes getuid"
            ]
        },
        "hf mfdes info": {
            "command": "hf mfdes info",
            "offline": false,
            "description": "get info from mifare desfire tags",
            "usage": "hf mfdes info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mfdes info"
            ]
        },
        "hf mfdes list": {
            "command": "hf mfdes list",
            "offline": true,
            "description": "alias of `trace list -t des` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf mfdes list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf mfdes list -f -> show frame delay times",
                "hf mfdes list -1 -> use trace buffer"
            ]
        },
        "hf mfdes bruteaid": {
            "command": "hf mfdes bruteaid",
            "offline": false,
            "description": "recover aids by bruteforce. warning: this command takes a long time",
            "usage": "hf mfdes bruteaid [-hm] [-s <hex>]... [-e <hex>]... [-i <dec>]",
            "options": [
                "-h, --help this help",
                "-s, --start <hex> starting app id as hex bytes (3 bytes,big endian)",
                "-e, --end <hex> last app id as hex bytes (3 bytes,big endian)",
                "-i, --step <dec> increment step when bruteforcing (decimal integer)",
                "-m, --mad only bruteforce the mad range"
            ],
            "notes": [
                "hf mfdes bruteaid -> search all apps",
                "hf mfdes bruteaid -s f0000f -i 16 -> search mad range manually"
            ]
        },
        "hf mfdes createaid": {
            "command": "hf mfdes createaid",
            "offline": false,
            "description": "create application id",
            "usage": "hf mfdes createaid [-h] [-a <aid>]... [-f <fid>]... [-k <keysetting1>]... [-l <keysetting2>]... [--name <name>]",
            "options": [
                "-h, --help this help",
                "-a, --aid <aid> app id to create as hex bytes (3 hex bytes)",
                "-f, --fid <fid> file id to create (optional)",
                "-k, --ks1 <keysetting1> key setting 1 (application master key settings)",
                "-l, --ks2 <keysetting2> key setting 2",
                "--name <name> app iso-4 name (optional)"
            ],
            "notes": [
                "hf mfdes createaid -a 123456 -f 1111 -k 0e -l 2e --name test"
            ]
        },
        "hf mfdes deleteaid": {
            "command": "hf mfdes deleteaid",
            "offline": false,
            "description": "delete application id",
            "usage": "hf mfdes deleteaid [-h] [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-a, --aid <aid> app id (3 hex bytes, big endian) to delete"
            ],
            "notes": [
                "hf mfdes deleteaid -a 123456"
            ]
        },
        "hf mfdes selectaid": {
            "command": "hf mfdes selectaid",
            "offline": false,
            "description": "select application id",
            "usage": "hf mfdes selectaid [-h] [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian)"
            ],
            "notes": [
                "hf mfdes selectaid -a 123456"
            ]
        },
        "hf mfdes changevalue": {
            "command": "hf mfdes changevalue",
            "offline": false,
            "description": "change value (credit/limitedcredit/debit) make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes changevalue [-h] [-n <fileno>]... [-d <value>]... [-m <mode>] [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-d, --value <value> value to increase (4 hex bytes, big endian)",
                "-m, --mode <mode> mode (0=credit, 1=limitedcredit, 2=debit)",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian)"
            ],
            "notes": [
                "hf mfdes changevalue -n 03 -m 0 -d 00000001"
            ]
        },
        "hf mfdes clearfile": {
            "command": "hf mfdes clearfile",
            "offline": false,
            "description": "clear record file make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes clearfile [-h] [-n <fileno>]... [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes, big endian, optional)"
            ],
            "notes": [
                "hf mfdes clearfile -n 01"
            ]
        },
        "hf mfdes createfile": {
            "command": "hf mfdes createfile",
            "offline": false,
            "description": "create standard/backup file",
            "usage": "hf mfdes createfile [-hb] [-n <fileno>]... [-f <fileid>]... [-c <comset>] [-r <accessrights>]... [-s <filesize>]... [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-f, --fileid <fileid> iso fid (2 hex bytes, big endian)",
                "-c, --com.set <comset> communication setting (0=plain,1=plain+mac,3=enciphered)",
                "-r, --rights <accessrights> access rights (2 hex bytes -> rw/chg/r/w, 0-d key, e free, f denied)",
                "-s, --filesize <filesize> file size (3 hex bytes, big endian)",
                "-b, --backup create backupfile instead of standard file",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian)"
            ],
            "notes": [
                "hf mfdes createfile -f 0001 -n 01 -c 0 -r eeee -s 000100 -a 123456"
            ]
        },
        "hf mfdes createvaluefile": {
            "command": "hf mfdes createvaluefile",
            "offline": false,
            "description": "create value file make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes createvaluefile [-h] [-n <fileno>]... [-c <comset>] [-r <accessrights>]... [-l <lowerlimit>]... [-u <upperlimit>]... [-v <value>]... [-m <limitcredit>]... [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-c, --com.set <comset> communication setting (0=plain,1=plain+mac,3=enciphered)",
                "-r, --rights <accessrights> access rights (2 hex bytes -> rw/chg/r/w, 0-d key, e free, f denied)",
                "-l, --lowerlimit <lowerlimit> lower limit (4 hex bytes, big endian)",
                "-u, --upperlimit <upperlimit> upper limit (4 hex bytes, big endian)",
                "-v, --value <value> value (4 hex bytes, big endian)",
                "-m, --limitcredit <limitcredit> limited credit enabled (1 hex byte [bit 0=limitedcredit, 1=freevalue])",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian,optional)"
            ],
            "notes": [
                "hf mfdes createvaluefile -n 03 -c 0 -r eeee -l 00000000 -u 00002000 -v 00000001 -m 02 -a 123456"
            ]
        },
        "hf mfdes createrecordfile": {
            "command": "hf mfdes createrecordfile",
            "offline": false,
            "description": "create linear/cyclic record file make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes createrecordfile [-hb] [-n <fileno>]... [-f <fileid>]... [-c <comset>] [-r <accessrights>]... [-s <recordsize>]... [-m <maxrecord>]... [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-f, --fileid <fileid> iso fid (2 hex bytes, big endian)",
                "-c, --com.set <comset> communication setting (0=plain,1=plain+mac,3=enciphered)",
                "-r, --rights <accessrights> access rights (2 hex bytes -> rw/chg/r/w, 0-d key, e free, f denied)",
                "-s, --size <recordsize> record size (3 hex bytes, big endian, 000001 to ffffff)",
                "-m, --maxrecord <maxrecord> max. number of records (3 hex bytes, big endian)",
                "-b, --cyclic create cyclic record file instead of linear record file",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian,optional)"
            ],
            "notes": [
                "hf mfdes createrecordfile -f 1122 -n 02 -c 0 -r eeee -s 000010 -m 000005 -a 123456"
            ]
        },
        "hf mfdes deletefile": {
            "command": "hf mfdes deletefile",
            "offline": false,
            "description": "delete file",
            "usage": "hf mfdes deletefile [-h] [-n <fileno>]... [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian,optional)"
            ],
            "notes": [
                "hf mfdes deletefile -n 01 -> make sure to select aid or authenticate aid before running this command."
            ]
        },
        "hf mfdes dump": {
            "command": "hf mfdes dump",
            "offline": false,
            "description": "tries to dump all files on a desfire tag",
            "usage": "hf mfdes dump [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf mfdes dump"
            ]
        },
        "hf mfdes getvalue": {
            "command": "hf mfdes getvalue",
            "offline": false,
            "description": "get value from value file make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes getvalue [-h] [-n <fileno>]... [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian)"
            ],
            "notes": [
                "hf mfdes getvalue -n 03"
            ]
        },
        "hf mfdes readdata": {
            "command": "hf mfdes readdata",
            "offline": false,
            "description": "read data from file make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes readdata [-h] [-n <fileno>]... [-o <offset>]... [-l <length>]... [-t <type>] [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-o, --offset <offset> file offset (3 hex bytes, big endian), optional",
                "-l, --length <length> length to read (3 hex bytes, big endian -> 000000 = read all data),optional",
                "-t, --type <type> file type (0=standard/backup, 1=record)",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes,big endian,optional)"
            ],
            "notes": [
                "hf mfdes readdata -n 01 -t 0 -o 000000 -l 000000 -a 123456",
                "hf mfdes readdata -n 01 -t 0 -> read all data from standard file, fileno 01"
            ]
        },
        "hf mfdes writedata": {
            "command": "hf mfdes writedata",
            "offline": false,
            "description": "write data to file make sure to select aid or authenticate aid before running this command.",
            "usage": "hf mfdes writedata [-h] [-n <fileno>]... [-o <offset>]... [-d <data>]... [-t <type>] [-a <aid>]...",
            "options": [
                "-h, --help this help",
                "-n, --fileno <fileno> file number (1 hex byte, 0x00 - 0x1f)",
                "-o, --offset <offset> file offset (3 hex bytes, big endian), optional",
                "-d, --data <data> data to write (hex bytes, 256 bytes max)",
                "-t, --type <type> file type (0=standard/backup, 1=record)",
                "-a, --aid <aid> app id to select as hex bytes (3 bytes, big endian, optional)"
            ],
            "notes": [
                "hf mfdes writedata -n 01 -t 0 -o 000000 -d 3132333435363738"
            ]
        },
        "hf st help": {
            "command": "hf st help",
            "offline": true,
            "description": "help this help list list iso 14443a/7816 history ndef read ndef file on tag --------------------------------------------------------------------------------------- hf st info available offline: no get info about st25ta tag",
            "usage": "hf st info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf st info"
            ]
        },
        "hf st list": {
            "command": "hf st list",
            "offline": true,
            "description": "alias of `trace list -t 7816` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf st list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf st list -f -> show frame delay times",
                "hf st list -1 -> use trace buffer"
            ]
        },
        "hf st ndef": {
            "command": "hf st ndef",
            "offline": true,
            "description": "read nfc data exchange format (ndef) file on st25ta",
            "usage": "hf st ndef [-h] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-p, --pwd <hex> 16 byte read password"
            ],
            "notes": [
                "hf st ndef -p 82e80053d4ca5c0b656d852cc696c8a1"
            ]
        },
        "hf st protect": {
            "command": "hf st protect",
            "offline": false,
            "description": "change read or write protection for nfc data exchange format (ndef) file on st25ta",
            "usage": "hf st protect [-hedrw] -p <hex>",
            "options": [
                "-h, --help this help",
                "-e, --enable enable protection",
                "-d, --disable disable protection (default)",
                "-r, --read change read protection",
                "-w, --write change write protection (default)",
                "-p, --password <hex> 16 byte write password"
            ],
            "notes": [
                "hf st protect -p 82e80053d4ca5c0b656d852cc696c8a1 -r -e -> enable read protection",
                "hf st protect -p 82e80053d4ca5c0b656d852cc696c8a1 -w -d -> disable write protection"
            ]
        },
        "hf st pwd": {
            "command": "hf st pwd",
            "offline": false,
            "description": "change read or write password for nfc data exchange format (ndef) file on st25ta",
            "usage": "hf st pwd [-hrw] -p <hex> -n <hex>",
            "options": [
                "-h, --help this help",
                "-r, --read change the read password (default)",
                "-w, --write change the write password",
                "-p, --password <hex> current 16 byte write password",
                "-n, --new <hex> new 16 byte password"
            ],
            "notes": [
                "hf st pwd -p 82e80053d4ca5c0b656d852cc696c8a1 -r -n 00000000000000000000000000000000 -> change read password",
                "hf st pwd -p 82e80053d4ca5c0b656d852cc696c8a1 -w -n 00000000000000000000000000000000 -> change write password"
            ]
        },
        "hf st sim": {
            "command": "hf st sim",
            "offline": false,
            "description": "emulating st25ta512b tag with 7 byte uid",
            "usage": "hf st sim [-h] -u <hex>",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> 7 byte uid"
            ],
            "notes": [
                "hf st sim -u 02e2007d0fca4c"
            ]
        },
        "hf thinfilm help": {
            "command": "hf thinfilm help",
            "offline": true,
            "description": "help this help list list nfc barcode / thinfilm history - not correct --------------------------------------------------------------------------------------- hf thinfilm info available offline: no get info from thinfilm tags",
            "usage": "hf thinfilm info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf thinfilm info"
            ]
        },
        "hf thinfilm list": {
            "command": "hf thinfilm list",
            "offline": true,
            "description": "alias of `trace list -t thinfilm` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf thinfilm list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf thinfilm list -f -> show frame delay times",
                "hf thinfilm list -1 -> use trace buffer"
            ]
        },
        "hf thinfilm sim": {
            "command": "hf thinfilm sim",
            "offline": false,
            "description": "simulate thinfilm tag",
            "usage": "hf thinfilm sim [-h] -d <hex> [--raw]",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to send",
                "--raw raw, provided bytes should include crc"
            ],
            "notes": [
                "hf thinfilm sim -d b70470726f786d61726b2e636f6d"
            ]
        },
        "hf topaz help": {
            "command": "hf topaz help",
            "offline": true,
            "description": "help this help list list topaz history --------------------------------------------------------------------------------------- hf topaz list available offline: yes alias of `trace list -t topaz` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "hf topaz list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "hf topaz list -f -> show frame delay times",
                "hf topaz list -1 -> use trace buffer"
            ]
        },
        "hf topaz info": {
            "command": "hf topaz info",
            "offline": false,
            "description": "get info from topaz tags",
            "usage": "hf topaz info [-hv]",
            "options": [
                "-h, --help this help",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf topaz info"
            ]
        },
        "hf topaz reader": {
            "command": "hf topaz reader",
            "offline": false,
            "description": "read uid from topaz tags",
            "usage": "hf topaz reader [-hv]",
            "options": [
                "-h, --help this help",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "hf topaz reader"
            ]
        },
        "hf topaz sim": {
            "command": "hf topaz sim",
            "offline": false,
            "description": "simulate a topaz tag",
            "usage": "hf topaz sim [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf topaz sim -> not yet implemented"
            ]
        },
        "hf topaz sniff": {
            "command": "hf topaz sniff",
            "offline": false,
            "description": "sniff topaz reader-tag communication",
            "usage": "hf topaz sniff [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf topaz sniff"
            ]
        },
        "hf topaz raw": {
            "command": "hf topaz raw",
            "offline": false,
            "description": "send raw hex data to topaz tags",
            "usage": "hf topaz raw [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hf topaz raw -> not yet implemented"
            ]
        },
        "hf waveshare help": {
            "command": "hf waveshare help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- hf waveshare loadbmp available offline: no load bmp file to waveshare nfc epaper.",
            "usage": "hf waveshare loadbmp [-hs] -m <nr> -f <filename>",
            "options": [
                "-h, --help this help",
                "-m <nr> model number [0 - 7] of your tag",
                "-s, --save save dithered version in filename-[n].bmp, only for rgb bmp",
                "-f, --file <filename> filename[.bmp] to upload to tag"
            ],
            "notes": [
                "hf waveshare loadbmp -f myfile -m 0 -> 2.13 inch e-paper ( 122, 250 )",
                "hf waveshare loadbmp -f myfile -m 1 -> 2.9 inch e-paper ( 296, 128 )",
                "hf waveshare loadbmp -f myfile -m 2 -> 4.2 inch e-paper ( 400, 300 )",
                "hf waveshare loadbmp -f myfile -m 3 -> 7.5 inch e-paper ( 800, 480 )",
                "hf waveshare loadbmp -f myfile -m 4 -> 2.7 inch e-paper ( 176, 276 )",
                "hf waveshare loadbmp -f myfile -m 5 -> 2.13 inch e-paper b (with red) ( 104, 212 )",
                "hf waveshare loadbmp -f myfile -m 6 -> 1.54 inch e-paper b (with red) ( 200, 200 )",
                "hf waveshare loadbmp -f myfile -m 7 -> 7.5 inch e-paper hd ( 880, 528 )"
            ]
        },
        "hw help": {
            "command": "hw help",
            "offline": true,
            "description": "------------- ----------------------- hardware ----------------------- help this help connect connect proxmark3 to serial port --------------------------------------------------------------------------------------- hw break available offline: no send break loop package",
            "usage": "hw break [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw break"
            ]
        },
        "hw connect": {
            "command": "hw connect",
            "offline": true,
            "description": "connects to a proxmark3 device via specified serial port. baudrate here is only for physical uart or uart-bt, not for usb-cdc or blue shark add-on",
            "usage": "hw connect [-h] [-p <string>] [-b <dec>]",
            "options": [
                "-h, --help this help",
                "-p, --port <string> serial port to connect to, else retry the last used one",
                "-b, --baud <dec> baudrate"
            ],
            "notes": [
                "hw connect -p /dev/ttyacm0",
                "hw connect -p /dev/ttyacm0 -b 115200"
            ]
        },
        "hw dbg": {
            "command": "hw dbg",
            "offline": false,
            "description": "set device side debug level output. note: option -4, this option may cause malfunction itself",
            "usage": "hw dbg [-h01234]",
            "options": [
                "-h, --help this help",
                "-0 no debug messages",
                "-1 error messages",
                "-2 plus information messages",
                "-3 plus debug messages",
                "-4 print even debug messages in timing critical functions"
            ],
            "notes": [
                "hw dbg -1"
            ]
        },
        "hw detectreader": {
            "command": "hw detectreader",
            "offline": false,
            "description": "start to detect presences of reader field",
            "usage": "hw detectreader [-hlh]",
            "options": [
                "-h, --help this help",
                "-l, --lf detect low frequence 125/134 khz",
                "-h, --hf detect high frequence 13.56 mhz"
            ],
            "notes": [
                "hw detectreader -l"
            ]
        },
        "hw fpgaoff": {
            "command": "hw fpgaoff",
            "offline": false,
            "description": "turn of fpga and antenna field",
            "usage": "hw fpgaoff [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw fpgaoff"
            ]
        },
        "hw lcd": {
            "command": "hw lcd",
            "offline": false,
            "description": "send command/data to lcd",
            "usage": "hw lcd [-h] -r <hex> -c <dec>",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> data",
                "-c, --cnt <dec> number of times to send"
            ],
            "notes": [
                "hw lcd -r aa -c 03 -> sends 0xaa three times"
            ]
        },
        "hw lcdreset": {
            "command": "hw lcdreset",
            "offline": false,
            "description": "hardware reset lcd",
            "usage": "hw lcdreset [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw lcdreset"
            ]
        },
        "hw ping": {
            "command": "hw ping",
            "offline": false,
            "description": "test if the proxmark3 is responsive",
            "usage": "hw ping [-h] [-l <dec>]",
            "options": [
                "-h, --help this help",
                "-l, --len <dec> length of payload to send"
            ],
            "notes": [
                "hw ping",
                "hw ping --len 32"
            ]
        },
        "hw readmem": {
            "command": "hw readmem",
            "offline": false,
            "description": "read memory at decimal address from arm chip flash.",
            "usage": "hw readmem [-h] -a <dec>",
            "options": [
                "-h, --help this help",
                "-a, --adr <dec> address to read"
            ],
            "notes": [
                "hw readmem -a 10000"
            ]
        },
        "hw reset": {
            "command": "hw reset",
            "offline": false,
            "description": "reset the proxmark3 device.",
            "usage": "hw reset [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw reset"
            ]
        },
        "hw setlfdivisor": {
            "command": "hw setlfdivisor",
            "offline": false,
            "description": "drive lf antenna at 12 mhz / (divisor + 1).",
            "usage": "hw setlfdivisor [-h] -d <dec>",
            "options": [
                "-h, --help this help",
                "-d, --div <dec> 19 - 255 divisor value (def 95)"
            ],
            "notes": [
                "hw setlfdivisor -d 88"
            ]
        },
        "hw setmux": {
            "command": "hw setmux",
            "offline": false,
            "description": "set the adc mux to a specific value",
            "usage": "hw setmux [-h] [--lopkd] [--loraw] [--hipkd] [--hiraw]",
            "options": [
                "-h, --help this help",
                "--lopkd low peak",
                "--loraw low raw",
                "--hipkd high peak",
                "--hiraw high raw"
            ],
            "notes": [
                "hw setmux --hiraw -> set high raw"
            ]
        },
        "hw standalone": {
            "command": "hw standalone",
            "offline": false,
            "description": "start standalone mode",
            "usage": "hw standalone [-h] [-a <dec>]",
            "options": [
                "-h, --help this help",
                "-a, --arg <dec> argument byte"
            ],
            "notes": [
                "hw standalone -> start",
                "hw standalone -a 1 -> start and send arg 1"
            ]
        },
        "hw status": {
            "command": "hw status",
            "offline": false,
            "description": "show runtime status information about the connected proxmark3",
            "usage": "hw status [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw status"
            ]
        },
        "hw tearoff": {
            "command": "hw tearoff",
            "offline": false,
            "description": "configure a tear-off hook for the next write command supporting tear-off after having been triggered by a write command, the tear-off hook is deactivated delay (in us) must be between 1 and 43000 (43ms). precision is about 1/3us.",
            "usage": "hw tearoff [-hs] [--delay <dec>] [--on] [--off]",
            "options": [
                "-h, --help this help",
                "--delay <dec> delay in us before triggering tear-off, must be between 1 and 43000",
                "--on activate tear-off hook",
                "--off deactivate tear-off hook",
                "-s, --silent less verbose output"
            ],
            "notes": [
                "hw tearoff --delay 1200 -> define delay of 1200us",
                "hw tearoff --on -> (re)activate a previously defined delay",
                "hw tearoff --off -> deactivate a previously activated but not yet triggered hook"
            ]
        },
        "hw tia": {
            "command": "hw tia",
            "offline": false,
            "description": "trigger a timing interval acquisition to re-adjust the realtimecounter divider",
            "usage": "hw tia [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw tia"
            ]
        },
        "hw tune": {
            "command": "hw tune",
            "offline": false,
            "description": "measure antenna tuning",
            "usage": "hw tune [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw tune"
            ]
        },
        "hw version": {
            "command": "hw version",
            "offline": false,
            "description": "show version information about the connected proxmark3",
            "usage": "hw version [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "hw version"
            ]
        },
        "lf help": {
            "command": "lf help",
            "offline": true,
            "description": "help this help ----------- -------------- low frequency -------------- awid { awid rfids... } cotag { cotag chips... } destron { fdx-a destron rfids... } em { em chips & rfids... } fdxb { fdx-b rfids... } gallagher { gallagher rfids... } gproxii { guardall prox ii rfids... } hid { hid prox rfids... } hitag { hitag chips... } idteck { idteck rfids... } indala { indala rfids... } io { ioprox rfids... } jablotron { jablotron rfids... } keri { keri rfids... } motorola { motorola rfids... } nedap { nedap rfids... } nexwatch { nexwatch rfids... } noralsy { noralsy rfids... } pac { pac/stanley rfids... } paradox { paradox rfids... } pcf7931 { pcf7931 chips... } presco { presco rfids... } pyramid { farpointe/pyramid rfids... } securakey { securakey rfids... } ti { ti chips... } t55xx { t55xx chips... } viking { viking rfids... } visa2000 { visa2000 rfids... } ----------- --------------------- general --------------------- search read and search for valid known tag --------------------------------------------------------------------------------------- lf config available offline: no get/set config for lf sampling, bit/sample, decimation, frequency these changes are temporary, will be reset after a power cycle. - use `lf read` performs a read (active field) - use `lf sniff` performs a sniff (no active field)",
            "usage": "lf config [-hr] [--125] [--134] [-a <0|1>] [-b <1-8>] [--dec <1-8>] [--divisor <19-255>] [-f <47-600>] [-s <dec>] [-t <0-128>]",
            "options": [
                "-h, --help this help",
                "--125 125 khz frequency",
                "--134 134 khz frequency",
                "-a, --avg <0|1> averaging - if set, will average the stored sample value when decimating (default 1)",
                "-b, --bps <1-8> sets resolution of bits per sample (default 8)",
                "--dec <1-8> sets decimation. a value of n saves only 1 in n samples (default 1)",
                "--divisor <19-255> manually set freq divisor. 88 -> 134 khz, 95 -> 125 khz",
                "-f, --freq <47-600> manually set frequency in khz",
                "-r, --reset reset values to defaults",
                "-s, --skip <dec> sets a number of samples to skip before capture (default 0)",
                "-t, --trig <0-128> sets trigger threshold. 0 means no threshold"
            ],
            "notes": [
                "lf config -> shows current config",
                "lf config -b 8 --125 -> samples at 125 khz, 8 bps",
                "lf config -b 4 --134 --dec 3 -> samples at 134 khz, averages three samples into one, stored with a resolution of 4 bits per sample",
                "lf config --trig 20 -s 10000 -> trigger sampling when above 20, skip 10 000 first samples after triggered"
            ]
        },
        "lf cmdread": {
            "command": "lf cmdread",
            "offline": false,
            "description": "modulate lf reader field to send command before read. all periods in microseconds. - use `lf config` to set parameters",
            "usage": "lf cmdread [-hv@] [-d <us>] [-c <0|1|...>] [-e <us>]... [-o <us>] [-z <us>] [-s <dec>]",
            "options": [
                "-h, --help this help",
                "-d, --duration <us> delay off period, (0 for bitbang mode)",
                "-c, --cmd <0|1|...> command symbols",
                "-e, --extra <us> extra symbol definition and duration (up to 4)",
                "-o, --one <us> one time period",
                "-z, --zero <us> zero time period",
                "-s, --samples <dec> number of samples to collect",
                "-v, --verbose verbose output",
                "-@ continuous mode"
            ],
            "notes": [
                "lf cmdread -d 50 -z 116 -o 166 -e w3000 -c w00110 -> probing for hitag 1/s",
                "lf cmdread -d 50 -z 116 -o 166 -e w3000 -c w11000 -> probing for hitag 2",
                "lf cmdread -d 50 -z 116 -o 166 -e w3000 -c w11000 -q -s 2000 -@ -> probing for hitag 2, oscilloscope style",
                "lf cmdread -d 48 -z 112 -o 176 -e w3000 -e s240 -e e336 -c w0s00000010000e -> probing for hitag (us)"
            ]
        },
        "lf read": {
            "command": "lf read",
            "offline": false,
            "description": "sniff low frequency signal. - use `lf config` to set parameters. - use `data plot` to look at it",
            "usage": "lf read [-hv@] [-s <dec>]",
            "options": [
                "-h, --help this help",
                "-s, --samples <dec> number of samples to collect",
                "-v, --verbose verbose output",
                "-@ continuous reading mode"
            ],
            "notes": [
                "lf read -v -s 12000 -> collect 12000 samples",
                "lf read -s 3000 -@ -> oscilloscope style"
            ]
        },
        "lf search": {
            "command": "lf search",
            "offline": true,
            "description": "read and search for valid known tag. for offline mode, you can `data load` first then search.",
            "usage": "lf search [-h1cu]",
            "options": [
                "-h, --help this help",
                "-1 use data from graphbuffer to search",
                "-c continue searching even after a first hit",
                "-u search for unknown tags. if not set, reads only known tags"
            ],
            "notes": [
                "lf search -> try reading data from tag & search for known tag",
                "lf search -1 -> use data from graphbuffer & search for known tag",
                "lf search -u -> try reading data from tag & search for known and unknown tag",
                "lf search -1u -> use data from graphbuffer & search for known and unknown tag"
            ]
        },
        "lf sim": {
            "command": "lf sim",
            "offline": false,
            "description": "simulate low frequency tag from graphbuffer use `lf config` to set parameters",
            "usage": "lf sim [-h] [-g <ms>]",
            "options": [
                "-h, --help this help",
                "-g, --gap <ms> start gap in microseconds"
            ],
            "notes": [
                "lf sim",
                "lf sim --gap 240 -> start simulating with 240ms gap"
            ]
        },
        "lf simask": {
            "command": "lf simask",
            "offline": false,
            "description": "simulate ask tag from demodbuffer or input",
            "usage": "lf simask [-hiv] [-c <dec>] [--bi] [--am] [--ar] [--stt] [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-i, --inv invert data",
                "-c, --clk <dec> manually set clock - can autodetect if using demodbuffer (default 64)",
                "--bi ask/biphase encoding",
                "--am ask/manchester encoding (default)",
                "--ar ask/raw encoding",
                "--stt add t55xx sequence terminator gap - default: no gaps (only manchester)",
                "-d, --data <hex> data to sim - omit to use demodbuffer",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "lf simask --clk 32 --am -d 0102030405 -> simulate ask/man rf/32",
                "lf simask --clk 32 --bi -d 0102030405 -> simulate ask/biphase rf/32",
                "",
                "lf simask --clk 64 --am -d ffbd8001686f1924 -> simulate a em410x tag",
                "lf simask --clk 64 --am --stt -d 5649533200003f340000001b -> simulate a visa2k tag"
            ]
        },
        "lf simfsk": {
            "command": "lf simfsk",
            "offline": false,
            "description": "simulate fsk tag from demodbuffer or input. there are about four fsk modulations to know of. fsk1 - where fc/8 = high and fc/5 = low fsk1a - is inverted fsk1, ie: fc/5 = high and fc/8 = low fsk2 - where fc/10 = high and fc/8 = low fsk2a - is inverted fsk2, ie: fc/10 = high and fc/8 = low note: if you set one clock manually set them all manually",
            "usage": "lf simfsk [-hv] [-c <dec>] [--low <dec>] [--high <dec>] [--stt] [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-c, --clk <dec> manually set clock - can autodetect if using demodbuffer (default 64)",
                "--low <dec> manually set larger field clock",
                "--high <dec> manually set smaller field clock",
                "--stt tbd! - stt to enable a gap between playback repetitions (default: no gap)",
                "-d, --data <hex> data to sim - omit to use demodbuffer",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "lf simfsk -c 40 --high 8 --low 5 -d 010203 -> fsk1 rf/40 data 010203",
                "lf simfsk -c 40 --high 5 --low 8 -d 010203 -> fsk1a rf/40 data 010203",
                "lf simfsk -c 64 --high 10 --low 8 -d 010203 -> fsk2 rf/64 data 010203",
                "lf simfsk -c 64 --high 8 --low 10 -d 010203 -> fsk2a rf/64 data 010203",
                "",
                "lf simfsk -c 50 --high 10 --low 8 -d 1d5559555569a9a555a59569 -> simulate hid prox tag manually",
                "lf simfsk -c 50 --high 10 --low 8 --stt -d 011db2487e8d811111111111 -> simulate awid tag manually"
            ]
        },
        "lf simpsk": {
            "command": "lf simpsk",
            "offline": false,
            "description": "simulate psk tag from demodbuffer or input",
            "usage": "lf simpsk [-h123iv] [-c <dec>] [--fc <dec>] [-d <hex>]",
            "options": [
                "-h, --help this help",
                "-1, --psk1 set psk1 (default)",
                "-2, --psk2 set psk2",
                "-3, --psk3 set psk3",
                "-i, --inv invert data",
                "-c, --clk <dec> manually set clock - can autodetect if using demodbuffer (default 32)",
                "--fc <dec> 2|4|8 are valid carriers (default 2)",
                "-d, --data <hex> data to sim - omit to use demodbuffer",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "lf simpsk -1 --clk 40 --fc 4 -d 01020304 -> simulate psk1 rf/40 psksub fc/4, data 01020304",
                "",
                "lf simpsk -1 --clk 32 --fc 2 -d a0000000bd989a11 -> simulate a indala tag manually"
            ]
        },
        "lf simbidir": {
            "command": "lf simbidir",
            "offline": false,
            "description": "simulate lf tag with bidirectional data transmission between reader and tag",
            "usage": "lf simbidir [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf simbidir"
            ]
        },
        "lf sniff": {
            "command": "lf sniff",
            "offline": false,
            "description": "sniff low frequency signal. - use `lf config` to set parameters. - use `data plot` to look at it",
            "usage": "lf sniff [-hv@] [-s <dec>]",
            "options": [
                "-h, --help this help",
                "-s, --samples <dec> number of samples to collect",
                "-v, --verbose verbose output",
                "-@ continuous sniffing mode"
            ],
            "notes": [
                "lf sniff -v",
                "lf sniff -s 3000 -@ -> oscilloscope style"
            ]
        },
        "lf tune": {
            "command": "lf tune",
            "offline": false,
            "description": "continuously measure lf antenna tuning. press button or <enter> to interrupt.",
            "usage": "lf tune [-h] [-n <dec>] [-q <dec>] [-f <float>] [--bar] [--mix] [--value]",
            "options": [
                "-h, --help this help",
                "-n, --iter <dec> number of iterations (default: 0=infinite)",
                "-q, --divisor <dec> frequency divisor. 88 -> 134 khz, 95 -> 125 khz",
                "-f, --freq <float> frequency in khz",
                "--bar bar style",
                "--mix mixed style",
                "--value values style"
            ],
            "notes": [
                "lf tune",
                "lf tune --mix"
            ]
        },
        "lf awid help": {
            "command": "lf awid help",
            "offline": true,
            "description": "help this help demod demodulate an awid fsk tag from the graphbuffer --------------------------------------------------------------------------------------- lf awid demod available offline: yes try to find awid prox preamble, if found decode / descramble data",
            "usage": "lf awid demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf awid demod"
            ]
        },
        "lf awid reader": {
            "command": "lf awid reader",
            "offline": false,
            "description": "read a awid prox tag",
            "usage": "lf awid reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf awid reader -@ -> continuous reader mode"
            ]
        },
        "lf awid clone": {
            "command": "lf awid clone",
            "offline": false,
            "description": "clone a awid prox tag to a t55x7, q5/t5555 or em4305/4469 tag",
            "usage": "lf awid clone [-h] --fmt <dec> --fc <dec> --cn <dec> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--fmt <dec> format length 26|34|37|50",
                "--fc <dec> 8|16bit value facility code",
                "--cn <dec> 16|32-bit value card number",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf awid clone --fmt 26 --fc 123 --cn 1337",
                "lf awid clone --fmt 50 --fc 2001 --cn 13371337",
                "lf awid clone --q5 --fmt 26 --fc 123 --cn 1337 -> encode for q5/t5555 tag",
                "lf awid clone --em --fmt 26 --fc 123 --cn 1337 -> encode for em4305/4469"
            ]
        },
        "lf awid sim": {
            "command": "lf awid sim",
            "offline": false,
            "description": "enables simulation of awid card with specified facility-code and card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf awid sim [-h] --fmt <dec> --fc <dec> --cn <dec>",
            "options": [
                "-h, --help this help",
                "--fmt <dec> format length 26|32|36|40",
                "--fc <dec> 8-bit value facility code",
                "--cn <dec> 16-bit value card number"
            ],
            "notes": [
                "lf awid sim --fmt 26 --fc 123 --cn 1337",
                "lf awid sim --fmt 50 --fc 2001 --cn 13371337"
            ]
        },
        "lf awid brute": {
            "command": "lf awid brute",
            "offline": false,
            "description": "enables bruteforce of awid reader with specified facility-code. this is a attack against reader. if cardnumber is given, it starts with it and goes up / down one step if cardnumber is not given, it starts with 1 and goes up to 65535",
            "usage": "lf awid brute [-hv] --fmt <dec> --fc <dec> [--cn <dec>] [--delay <dec>]",
            "options": [
                "-h, --help this help",
                "--fmt <dec> format length 26|50",
                "--fc <dec> 8|16bit value facility code",
                "--cn <dec> optional - card number to start with, max 65535",
                "--delay <dec> optional - delay betweens attempts in ms. default 1000ms",
                "-v, --verbose verbose logging, show all tries"
            ],
            "notes": [
                "lf awid brute --fmt 26 --fc 224",
                "lf awid brute --fmt 50 --fc 2001 --delay 2000",
                "lf awid brute --fmt 50 --fc 2001 --cn 200 --delay 2000 -v"
            ]
        },
        "lf awid watch": {
            "command": "lf awid watch",
            "offline": false,
            "description": "enables awid compatible reader mode printing details of scanned awid26 or awid50 tags. run until the button is pressed or another usb command is issued.",
            "usage": "lf awid watch [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf awid watch"
            ]
        },
        "lf cotag help": {
            "command": "lf cotag help",
            "offline": true,
            "description": "help this help demod demodulate an cotag tag --------------------------------------------------------------------------------------- lf cotag demod available offline: yes try to find cotag preamble, if found decode / descramble data",
            "usage": "lf cotag demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf cotag demod"
            ]
        },
        "lf cotag reader": {
            "command": "lf cotag reader",
            "offline": false,
            "description": "read a cotag tag, the current support for cotag is limited.",
            "usage": "lf cotag reader [-h123]",
            "options": [
                "-h, --help this help",
                "-1 high/low signal; maxlength bigbuff",
                "-2 translation of high/low into bytes with manchester 0,1",
                "-3 raw signal; maxlength bigbuff"
            ],
            "notes": [
                "lf cotag reader -2"
            ]
        },
        "lf destron help": {
            "command": "lf destron help",
            "offline": true,
            "description": "help this help demod demodulate an destron tag from the graphbuffer --------------------------------------------------------------------------------------- lf destron demod available offline: yes try to find destron preamble, if found decode / descramble data",
            "usage": "lf destron demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf destron demod"
            ]
        },
        "lf destron reader": {
            "command": "lf destron reader",
            "offline": false,
            "description": "read a destron tag",
            "usage": "lf destron reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf destron reader -@ -> continuous reader mode"
            ]
        },
        "lf destron clone": {
            "command": "lf destron clone",
            "offline": false,
            "description": "clone a destron tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf destron clone [-h] -u <hex> [-u <hex>]... [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> 5 bytes max",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf destron clone --uid 1a2b3c4d5e",
                "lf destron clone --q5 --uid 1a2b3c4d5e -> encode for q5/t5555 tag",
                "lf destron clone --em --uid 1a2b3c4d5e -> encode for em4305/4469"
            ]
        },
        "lf destron sim": {
            "command": "lf destron sim",
            "offline": false,
            "description": "try to find destron preamble, if found decode / descramble data",
            "usage": "lf destron sim [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf destron sim"
            ]
        },
        "lf em help": {
            "command": "lf em help",
            "offline": true,
            "description": "help this help 410x { em 4102 commands... } 4x05 { em 4205 / 4305 / 4369 / 4469 commands... } 4x50 { em 4350 / 4450 commands... } 4x70 { em 4070 / 4170 commands... } ======================================================================================= lf em 410x { em 4102 commands... } --------------------------------------------------------------------------------------- lf em 410x help available offline: yes help this help demod demodulate a em410x tag from the graphbuffer --------------------------------------------------------------------------------------- lf em 410x demod available offline: yes try to find em 410x preamble, if found decode / descramble data",
            "usage": "lf em 410x demod [-hia] [--clk <dec>] [--err <dec>] [--len <dec>]",
            "options": [
                "-h, --help this help",
                "--clk <dec> clock (default autodetect)",
                "--err <dec> maximum allowed errors (default 100)",
                "--len <dec> maximum length",
                "-i, --invert invert output",
                "-a, --amp amplify signal"
            ],
            "notes": [
                "lf em 410x demod -> demod an em410x tag id from graphbuffer",
                "lf em 410x demod --clk 32 -> demod an em410x tag id from graphbuffer using a clock of rf/32",
                "lf em 410x demod --clk 32 -i -> demod an em410x tag id from graphbuffer using a clock of rf/32 and inverting data",
                "lf em 410x demod -i -> demod an em410x tag id from graphbuffer while inverting data",
                "lf em 410x demod --clk 64 -i --err 0 -> demod an em410x tag id from graphbuffer using a clock of rf/64 and inverting data and allowing 0 demod errors"
            ]
        },
        "lf em 410x reader": {
            "command": "lf em 410x reader",
            "offline": false,
            "description": "read em 410x tag",
            "usage": "lf em 410x reader [-hiab@v] [--clk <dec>] [--err <dec>] [--len <dec>]",
            "options": [
                "-h, --help this help",
                "--clk <dec> clock (default autodetect)",
                "--err <dec> maximum allowed errors (default 100)",
                "--len <dec> maximum length",
                "-i, --invert invert output",
                "-a, --amp amplify signal",
                "-b break on first found",
                "-@ continuous reader mode",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "lf em 410x reader -> reader",
                "lf em 410x reader -@ -> continuous reader mode",
                "lf em 410x reader --clk 32 -> reader using a clock of rf/32",
                "lf em 410x reader --clk 32 -i -> reader using a clock of rf/32 and inverting data",
                "lf em 410x reader -i -> reader while inverting data",
                "lf em 410x reader --clk 64 -i --err 0 -> reader using a clock of rf/64 and inverting data and allowing 0 demod errors"
            ]
        },
        "lf em 410x sim": {
            "command": "lf em 410x sim",
            "offline": false,
            "description": "enables simulation of em 410x card. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf em 410x sim [-h] [--clk <dec>] --id <hex>",
            "options": [
                "-h, --help this help",
                "--clk <dec> <32|64> clock (default 64)",
                "--id <hex> id number (5 hex bytes)"
            ],
            "notes": [
                "lf em 410x sim --id 0f0368568b",
                "lf em 410x sim --id 0f0368568b --clk 32"
            ]
        },
        "lf em 410x brute": {
            "command": "lf em 410x brute",
            "offline": false,
            "description": "bruteforcing by emulating em 410x tag",
            "usage": "lf em 410x brute [-h] [--clk <dec>] [--delay <dec>] -f <hex>",
            "options": [
                "-h, --help this help",
                "--clk <dec> <32|64> clock (default 64)",
                "--delay <dec> pause delay in milliseconds between uids simulation (default 1000ms)",
                "-f, --file <hex> file with uids in hex format, one per line"
            ],
            "notes": [
                "lf em 410x brute -f ids.txt",
                "lf em 410x brute -f ids.txt --clk 32",
                "lf em 410x brute -f ids.txt --delay 3000",
                "lf em 410x brute -f ids.txt --delay 3000 --clk 32"
            ]
        },
        "lf em 410x watch": {
            "command": "lf em 410x watch",
            "offline": false,
            "description": "enables electro marine (em) compatible reader mode printing details of scanned tags. run until the button is pressed or another usb command is issued.",
            "usage": "lf em 410x watch [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf em 410x watch"
            ]
        },
        "lf em 410x spoof": {
            "command": "lf em 410x spoof",
            "offline": false,
            "description": "watch 'nd spoof, activates reader waits until a em 410x tag gets presented then proxmark3 starts simulating the found uid",
            "usage": "lf em 410x spoof [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf em 410x spoof"
            ]
        },
        "lf em 410x clone": {
            "command": "lf em 410x clone",
            "offline": false,
            "description": "writes em410x id to a t55x7 or q5/t5555 tag",
            "usage": "lf em 410x clone [-h] [--clk <dec>] --id <hex> [--q5]",
            "options": [
                "-h, --help this help",
                "--clk <dec> <16|32|40|64> clock (default 64)",
                "--id <hex> id number (5 hex bytes)",
                "--q5 specify writing to q5/t5555 tag"
            ],
            "notes": [
                "lf em 410x clone --id 0f0368568b -> write id to t55x7 tag",
                "lf em 410x clone --id 0f0368568b --q5 -> write id to q5/t5555 tag"
            ]
        },
        "lf em 4x05 help": {
            "command": "lf em 4x05 help",
            "offline": true,
            "description": "help this help demod demodulate a em4x05/em4x69 tag from the graphbuffer sniff attempt to recover em4x05 commands from sample buffer --------------------------------------------------------------------------------------- lf em 4x05 brute available offline: no this command tries to bruteforce the password of a em4205/4305/4469/4569",
            "usage": "lf em 4x05 brute [-h] [-s <pwd>] [-n <digits>]",
            "options": [
                "-h, --help this help",
                "-s, --start <pwd> start bruteforce enumeration from this password value",
                "-n <digits> stop after having found n candidates. default: 0 => infinite"
            ],
            "notes": [
                "note: if you get many false positives, change position on the antennalf em 4x05 brute",
                "lf em 4x05 brute -n 1 -> stop after first candidate found",
                "lf em 4x05 brute -s 000022b8 -> remember to use 0x for hex"
            ]
        },
        "lf em 4x05 chk": {
            "command": "lf em 4x05 chk",
            "offline": false,
            "description": "this command uses a dictionary attack against em4205/4305/4469/4569",
            "usage": "lf em 4x05 chk [-h] [-f <*.dic>]... [-e <em4100>]",
            "options": [
                "-h, --help this help",
                "-f, --file <*.dic> loads a default keys dictionary file <*.dic>",
                "-e, --em <em4100> try the calculated password from some cloners based on em4100 id"
            ],
            "notes": [
                "lf em 4x05 chk",
                "lf em 4x05 chk -e 000022b8 -> remember to use 0x for hex",
                "lf em 4x05 chk -f t55xx_default_pwds -> use t55xx default dictionary"
            ]
        },
        "lf em 4x05 demod": {
            "command": "lf em 4x05 demod",
            "offline": true,
            "description": "try to find em 4x05 preamble, if found decode / descramble data",
            "usage": "lf em 4x05 demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf em 4x05 demod"
            ]
        },
        "lf em 4x05 dump": {
            "command": "lf em 4x05 dump",
            "offline": false,
            "description": "dump em4x05/em4x69. tag must be on antenna.",
            "usage": "lf em 4x05 dump [-h] [-p <hex>] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-p, --pwd <hex> password (00000000)",
                "-f, --file <fn> override filename prefix (optional). default is based on uid"
            ],
            "notes": [
                "lf em 4x05 dump",
                "lf em 4x05 dump -p 11223344",
                "lf em 4x05 dump -f myfile -p 11223344"
            ]
        },
        "lf em 4x05 info": {
            "command": "lf em 4x05 info",
            "offline": false,
            "description": "tag information em4205/4305/4469//4569 tags. tag must be on antenna.",
            "usage": "lf em 4x05 info [-h] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-p, --pwd <hex> optional - password, 4 hex bytes"
            ],
            "notes": [
                "lf em 4x05 info",
                "lf em 4x05 info -p 11223344"
            ]
        },
        "lf em 4x05 read": {
            "command": "lf em 4x05 read",
            "offline": false,
            "description": "read em4x05/em4x69. tag must be on antenna.",
            "usage": "lf em 4x05 read [-h] -a <dec> [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-a, --addr <dec> memory address to read. (0-15)",
                "-p, --pwd <hex> optional - password, 4 bytes hex"
            ],
            "notes": [
                "lf em 4x05 read -a 1",
                "lf em 4x05 read --addr 1 --pwd 11223344"
            ]
        },
        "lf em 4x05 sniff": {
            "command": "lf em 4x05 sniff",
            "offline": true,
            "description": "sniff em4x05 commands sent from a programmer",
            "usage": "lf em 4x05 sniff [-h1r]",
            "options": [
                "-h, --help this help",
                "-1, --buf use the data in the buffer",
                "-r, --rev reverse the bit order for data blocks"
            ],
            "notes": [
                "lf em 4x05 sniff -> sniff via lf sniff",
                "lf em 4x05 sniff -1 -> sniff from data loaded into the buffer",
                "lf em 4x05 sniff -r -> reverse the bit order when showing block data"
            ]
        },
        "lf em 4x05 unlock": {
            "command": "lf em 4x05 unlock",
            "offline": false,
            "description": "execute tear off against em4205/4305/4469/4569",
            "usage": "lf em 4x05 unlock [-hv] [-n <int>] [-s <us>] [-e <us>] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-n <int> steps to skip",
                "-s, --start <us> start scan from delay (us)",
                "-e, --end <us> end scan at delay (us)",
                "-p, --pwd <hex> password (def 00000000)",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "lf em 4x05 unlock",
                "lf em 4x05 unlock -s 4100 -e 4100 -> lock on and autotune at 4100us",
                "lf em 4x05 unlock -n 10 -s 3000 -e 4400 -> scan delays 3000us -> 4400us"
            ]
        },
        "lf em 4x05 wipe": {
            "command": "lf em 4x05 wipe",
            "offline": false,
            "description": "wipe em4x05/em4x69. tag must be on antenna.",
            "usage": "lf em 4x05 wipe [-h] [--4205] [--4305] [--4369] [--4369] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "--4205 target chip type em 4205",
                "--4305 target chip type em 4305 (default)",
                "--4369 target chip type em 4369",
                "--4369 target chip type em 4469",
                "-p, --pwd <hex> optional - password, 4 bytes hex"
            ],
            "notes": [
                "lf em 4x05 wipe --4305 -p 11223344 -> wipe em 4305 w pwd",
                "lf em 4x05 wipe --4205 -> wipe em 4205",
                "lf em 4x05 wipe --4369 -> wipe em 4369"
            ]
        },
        "lf em 4x05 write": {
            "command": "lf em 4x05 write",
            "offline": false,
            "description": "write em4x05/em4x69. tag must be on antenna.",
            "usage": "lf em 4x05 write [-h] [-a <dec>] -d <hex> [-p <hex>] [--po]",
            "options": [
                "-h, --help this help",
                "-a, --addr <dec> memory address to write to. (0-13)",
                "-d, --data <hex> data to write (4 hex bytes)",
                "-p, --pwd <hex> password (4 hex bytes)",
                "--po protect operation"
            ],
            "notes": [
                "lf em 4x05 write -a 1 -d deadc0de",
                "lf em 4x05 write --addr 1 --pwd 11223344 --data deadc0de",
                "lf em 4x05 write --po --pwd 11223344 --data deadc0de"
            ]
        },
        "lf em 4x50 help": {
            "command": "lf em 4x50 help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- lf em 4x50 brute available offline: no tries to bruteforce the password of a em4x50. function can be stopped by pressing pm3 button.",
            "usage": "lf em 4x50 brute [-h] --first <hex> --last <hex>",
            "options": [
                "-h, --help this help",
                "--first <hex> first password (start), 4 bytes, lsb",
                "--last <hex> last password (stop), 4 bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 brute --first 12330000 --last 12340000 -> tries pwds from 0x12330000 to 0x1234000000"
            ]
        },
        "lf em 4x50 chk": {
            "command": "lf em 4x50 chk",
            "offline": false,
            "description": "dictionary attack against em4x50.",
            "usage": "lf em 4x50 chk [-h] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-f, --filename <fn> dictionary filename"
            ],
            "notes": [
                "lf em 4x50 chk -> uses t55xx default dictionary",
                "lf em 4x50 chk -f my.dic"
            ]
        },
        "lf em 4x50 dump": {
            "command": "lf em 4x50 dump",
            "offline": false,
            "description": "reads all blocks/words from em4x50 tag and saves dump in bin/eml/json format",
            "usage": "lf em 4x50 dump [-h] [-f <fn>] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-f, --filename <fn> dump filename (bin/eml/json)",
                "-p, --pwd <hex> password, 4 hex bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 dump",
                "lf em 4x50 dump -f mydump",
                "lf em 4x50 dump -p 12345678",
                "lf em 4x50 dump -f mydump -p 12345678"
            ]
        },
        "lf em 4x50 info": {
            "command": "lf em 4x50 info",
            "offline": false,
            "description": "tag information em4x50.",
            "usage": "lf em 4x50 info [-hv] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-p, --pwd <hex> password, 4 hex bytes, lsb",
                "-v, --verbose additional output of data section"
            ],
            "notes": [
                "lf em 4x50 info",
                "lf em 4x50 info -v -> show data section",
                "lf em 4x50 info -p 12345678 -> uses pwd 0x12345678"
            ]
        },
        "lf em 4x50 login": {
            "command": "lf em 4x50 login",
            "offline": false,
            "description": "login into em4x50 tag.",
            "usage": "lf em 4x50 login [-h] -p <hex>",
            "options": [
                "-h, --help this help",
                "-p, --passsword <hex> password, 4 bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 login -p 12345678 -> login with password 12345678"
            ]
        },
        "lf em 4x50 rdbl": {
            "command": "lf em 4x50 rdbl",
            "offline": false,
            "description": "reads single em4x50 block/word.",
            "usage": "lf em 4x50 rdbl [-h] -b <dec> [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-b, --block <dec> block/word address",
                "-p, --pwd <hex> password, 4 hex bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 rdbl -b 3",
                "lf em 4x50 rdbl -b 32 -p 12345678 -> reads block 32 with pwd 0x12345678"
            ]
        },
        "lf em 4x50 wrbl": {
            "command": "lf em 4x50 wrbl",
            "offline": false,
            "description": "writes single block/word to em4x50 tag.",
            "usage": "lf em 4x50 wrbl [-h] -b <dec> -d <hex> [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-b, --block <dec> block/word address, dec",
                "-d, --data <hex> data, 4 bytes, lsb",
                "-p, --pwd <hex> password, 4 bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 wrbl -b 3 -d 4f22e7ff",
                "lf em 4x50 wrbl -b 3 -d 4f22e7ff -p 12345678"
            ]
        },
        "lf em 4x50 writepwd": {
            "command": "lf em 4x50 writepwd",
            "offline": false,
            "description": "writes em4x50 password.",
            "usage": "lf em 4x50 writepwd [-h] -p <hex> -n <hex>",
            "options": [
                "-h, --help this help",
                "-p, --pwd <hex> password, 4 hex bytes, lsb",
                "-n, --new <hex> new password, 4 hex bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 writepwd -p 4f22e7ff -n 12345678"
            ]
        },
        "lf em 4x50 wipe": {
            "command": "lf em 4x50 wipe",
            "offline": false,
            "description": "wipes em4x50 tag by filling it with zeros, including the new password must give a password.",
            "usage": "lf em 4x50 wipe [-h] -p <hex>",
            "options": [
                "-h, --help this help",
                "-p, --passsword <hex> password, 4 bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 wipe -p 12345678"
            ]
        },
        "lf em 4x50 reader": {
            "command": "lf em 4x50 reader",
            "offline": false,
            "description": "shows standard read data of em4x50 tag.",
            "usage": "lf em 4x50 reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf em 4x50 reader",
                "lf em 4x50 reader -@ -> continuous reader mode"
            ]
        },
        "lf em 4x50 restore": {
            "command": "lf em 4x50 restore",
            "offline": false,
            "description": "restores data from dumpfile (bin/eml/json) onto a em4x50 tag. if used with -u, the filetemplate `lf-4x50-uid-dump.bin` is used as filename",
            "usage": "lf em 4x50 restore [-h] [-u <hex>] [-f <fn>] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-u, --uid <hex> uid, 4 hex bytes, msb",
                "-f, --filename <fn> dump filename (bin/eml/json)",
                "-p, --pwd <hex> password, 4 hex bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 restore -u 1b5aff5c -> uses lf-4x50-1b5aff5c-dump.bin",
                "lf em 4x50 restore -f mydump.eml",
                "lf em 4x50 restore -u 1b5aff5c -p 12345678",
                "lf em 4x50 restore -f mydump.eml -p 12345678"
            ]
        },
        "lf em 4x50 sim": {
            "command": "lf em 4x50 sim",
            "offline": false,
            "description": "simulates a em4x50 tag first upload to device using `lf em 4x50 eload`",
            "usage": "lf em 4x50 sim [-h] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-p, --passsword <hex> password, 4 bytes, lsb"
            ],
            "notes": [
                "lf em 4x50 simlf em 4x50 sim -p 27182818 -> uses password for eload data"
            ]
        },
        "lf em 4x50 eload": {
            "command": "lf em 4x50 eload",
            "offline": false,
            "description": "loads em4x50 tag dump (bin/eml/json) into emulator memory on device",
            "usage": "lf em 4x50 eload [-h] -f <fn>",
            "options": [
                "-h, --help this help",
                "-f, --filename <fn> dump filename (bin/eml/json)"
            ],
            "notes": [
                "lf em 4x50 eload -f mydump.bin"
            ]
        },
        "lf em 4x50 esave": {
            "command": "lf em 4x50 esave",
            "offline": false,
            "description": "saves bin/eml/json dump file of emulator memory.",
            "usage": "lf em 4x50 esave [-h] [-f <fn>]",
            "options": [
                "-h, --help this help",
                "-f, --filename <fn> data filename"
            ],
            "notes": [
                "lf em 4x50 esave -> use uid as filename",
                "lf em 4x50 esave -f mydump"
            ]
        },
        "lf em 4x50 eview": {
            "command": "lf em 4x50 eview",
            "offline": false,
            "description": "displays em4x50 content of emulator memory.",
            "usage": "lf em 4x50 eview [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf em 4x50 eview"
            ]
        },
        "lf em 4x70 help": {
            "command": "lf em 4x70 help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- lf em 4x70 info available offline: no tag information em4x70 tag variants include id48 automotive transponder. id48 does not use command parity (default). v4070 and em4170 do require parity bit.",
            "usage": "lf em 4x70 info [-h] [--par]",
            "options": [
                "-h, --help this help",
                "--par add parity bit when sending commands"
            ],
            "notes": [
                "lf em 4x70 info",
                "lf em 4x70 info --par -> adds parity bit to command"
            ]
        },
        "lf em 4x70 write": {
            "command": "lf em 4x70 write",
            "offline": false,
            "description": "write em4x70",
            "usage": "lf em 4x70 write [-h] [--par] -b <dec> -d <hex>",
            "options": [
                "-h, --help this help",
                "--par add parity bit when sending commands",
                "-b, --block <dec> block/word address, dec",
                "-d, --data <hex> data, 2 bytes"
            ],
            "notes": [
                "lf em 4x70 write -b 15 -d c0de -> write 'c0de' to block 15",
                "lf em 4x70 write -b 15 -d c0de --par -> adds parity bit to commands"
            ]
        },
        "lf em 4x70 unlock": {
            "command": "lf em 4x70 unlock",
            "offline": false,
            "description": "unlock em4x70 by sending pin default pin may be: aaaaaaaa 00000000",
            "usage": "lf em 4x70 unlock [-h] [--par] -p <hex>",
            "options": [
                "-h, --help this help",
                "--par add parity bit when sending commands",
                "-p, --pin <hex> pin, 4 bytes"
            ],
            "notes": [
                "lf em 4x70 unlock -p 11223344 -> unlock with pin",
                "lf em 4x70 unlock -p 11223344 --par -> unlock with pin using parity commands"
            ]
        },
        "lf em 4x70 auth": {
            "command": "lf em 4x70 auth",
            "offline": false,
            "description": "authenticate against an em4x70 by sending random number (rn) and f(rn) if f(rn) is incorrect based on the tag crypt key, the tag will not respond",
            "usage": "lf em 4x70 auth [-h] [--par] --rnd <hex> --frn <hex>",
            "options": [
                "-h, --help this help",
                "--par add parity bit when sending commands",
                "--rnd <hex> random 56-bit",
                "--frn <hex> f(rn) 28-bit as 4 hex bytes"
            ],
            "notes": [
                "lf em 4x70 auth --rnd 45f54ada252aac --frn 4866bb70 -> test authentication, tag will respond if successful"
            ]
        },
        "lf em 4x70 writepin": {
            "command": "lf em 4x70 writepin",
            "offline": false,
            "description": "write pin",
            "usage": "lf em 4x70 writepin [-h] [--par] -p <hex>",
            "options": [
                "-h, --help this help",
                "--par add parity bit when sending commands",
                "-p, --pin <hex> pin, 4 bytes"
            ],
            "notes": [
                "lf em 4x70 writepin -p 11223344 -> write pin",
                "lf em 4x70 writepin -p 11223344 --par -> write pin using parity commands"
            ]
        },
        "lf em 4x70 writekey": {
            "command": "lf em 4x70 writekey",
            "offline": false,
            "description": "write new 96-bit key to tag",
            "usage": "lf em 4x70 writekey [-h] [--par] -k <hex>",
            "options": [
                "-h, --help this help",
                "--par add parity bit when sending commands",
                "-k, --key <hex> crypt key as 12 hex bytes"
            ],
            "notes": [
                "lf em 4x70 writekey -k f32aa98cf5be4adfa6d3480b"
            ]
        },
        "lf fdxb help": {
            "command": "lf fdxb help",
            "offline": true,
            "description": "help this help demod demodulate a fdx-b iso11784/85 tag from the graphbuffer --------------------------------------------------------------------------------------- lf fdxb demod available offline: yes try to find fdx-b preamble, if found decode / descramble data",
            "usage": "lf fdxb demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf fdxb demod"
            ]
        },
        "lf fdxb reader": {
            "command": "lf fdxb reader",
            "offline": false,
            "description": "read a fdx-b animal tag note that the continuous mode is less verbose",
            "usage": "lf fdxb reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf fdxb reader -@ -> continuous reader mode"
            ]
        },
        "lf fdxb clone": {
            "command": "lf fdxb clone",
            "offline": false,
            "description": "clone a fdx-b tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf fdxb clone [-ha] -c <dec> -n <dec> [--extended <hex>] [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-c, --country <dec> country code",
                "-n, --national <dec> national code",
                "--extended <hex> extended data",
                "-a, --animal optional - set animal bit",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf fdxb clone --country 999 --national 1337 --animal",
                "lf fdxb clone --country 999 --national 1337 --extended 016a",
                "lf fdxb clone --q5 --country 999 --national 1337 -> encode for q5/t5555 tag",
                "lf fdxb clone --em --country 999 --national 1337 -> encode for em4305/4469"
            ]
        },
        "lf fdxb sim": {
            "command": "lf fdxb sim",
            "offline": false,
            "description": "enables simulation of fdx-b animal tag. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf fdxb sim [-ha] -c <dec> -n <dec> [--extended <hex>]",
            "options": [
                "-h, --help this help",
                "-c, --country <dec> country code",
                "-n, --national <dec> national code",
                "--extended <hex> extended data",
                "-a, --animal optional - set animal bit"
            ],
            "notes": [
                "lf fdxb sim --country 999 --national 1337 --animal",
                "lf fdxb sim --country 999 --national 1337 --extended 016a"
            ]
        },
        "lf gallagher help": {
            "command": "lf gallagher help",
            "offline": true,
            "description": "help this help demod demodulate an gallagher tag from the graphbuffer --------------------------------------------------------------------------------------- lf gallagher demod available offline: yes try to find gallagher preamble, if found decode / descramble data",
            "usage": "lf gallagher demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf gallagher demod"
            ]
        },
        "lf gallagher reader": {
            "command": "lf gallagher reader",
            "offline": false,
            "description": "read a gallagher tag",
            "usage": "lf gallagher reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf gallagher reader -@ -> continuous reader mode"
            ]
        },
        "lf gallagher clone": {
            "command": "lf gallagher clone",
            "offline": false,
            "description": "clone a gallagher tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf gallagher clone [-h] [-r <hex>] [--q5] [--em] [--rc <decimal>] [--fc <decimal>] [--cn <decimal>] [--il <decimal>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes max",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag",
                "--rc <decimal> region code. 4 bits max",
                "--fc <decimal> facility code. 2 bytes max",
                "--cn <decimal> card number. 3 bytes max",
                "--il <decimal> issue level. 4 bits max"
            ],
            "notes": [
                "lf gallagher clone --raw 0ffd5461a9da1346b2d1ac32",
                "lf gallagher clone --q5 --raw 0ffd5461a9da1346b2d1ac32 -> encode for q5/t5555 tag",
                "lf gallagher clone --em --raw 0ffd5461a9da1346b2d1ac32 -> encode for em4305/4469",
                "lf gallagher clone --rc 0 --fc 9876 --cn 1234 --il 1"
            ]
        },
        "lf gallagher sim": {
            "command": "lf gallagher sim",
            "offline": false,
            "description": "enables simulation of gallagher card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf gallagher sim [-h] [-r <hex>] [--rc <decimal>] [--fc <decimal>] [--cn <decimal>] [--il <decimal>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes max",
                "--rc <decimal> region code. 4 bits max",
                "--fc <decimal> facility code. 2 bytes max",
                "--cn <decimal> card number. 3 bytes max",
                "--il <decimal> issue level. 4 bits max"
            ],
            "notes": [
                "lf gallagher sim --raw 0ffd5461a9da1346b2d1ac32",
                "lf gallagher sim --rc 0 --fc 9876 --cn 1234 --il 1"
            ]
        },
        "lf gproxii help": {
            "command": "lf gproxii help",
            "offline": true,
            "description": "help this help demod demodulate a g prox ii tag from the graphbuffer --------------------------------------------------------------------------------------- lf gproxii demod available offline: yes try to find guardall prox-ii preamble, if found decode / descramble data",
            "usage": "lf gproxii demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf gproxii demod"
            ]
        },
        "lf gproxii reader": {
            "command": "lf gproxii reader",
            "offline": false,
            "description": "read a guardall tag",
            "usage": "lf gproxii reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf gproxii reader -@ -> continuous reader mode"
            ]
        },
        "lf gproxii clone": {
            "command": "lf gproxii clone",
            "offline": false,
            "description": "clone a guardall tag to a t55x7, q5/t5555 or em4305/4469 tag. the facility-code is 8-bit and the card number is 16-bit. larger values are truncated. currently work only on 26bit",
            "usage": "lf gproxii clone [-h] --fmt <dec> --fc <dec> --cn <dec> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--fmt <dec> format length 26|32|36|40",
                "--fc <dec> 8-bit value facility code",
                "--cn <dec> 16-bit value card number",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf gproxii clone --fmt 26 --fc 123 --cn 1337",
                "lf gproxii clone --q5 --fmt 26 --fc 123 --cn 1337 -> encode for q5/t5555 tag",
                "lf gproxii clone --em --fmt 26 --fc 123 --cn 1337 -> encode for em4305/4469"
            ]
        },
        "lf gproxii sim": {
            "command": "lf gproxii sim",
            "offline": false,
            "description": "enables simulation of guardall card with specified card number. simulation runs until the button is pressed or another usb command is issued. the facility-code is 8-bit and the card number is 16-bit. larger values are truncated. currently work only on 26bit",
            "usage": "lf gproxii sim [-h] --fmt <dec> --fc <dec> --cn <dec>",
            "options": [
                "-h, --help this help",
                "--fmt <dec> format length 26|32|36|40",
                "--fc <dec> 8-bit value facility code",
                "--cn <dec> 16-bit value card number"
            ],
            "notes": [
                "lf gproxii sim --fmt 26 --fc 123 --cn 1337"
            ]
        },
        "lf hid help": {
            "command": "lf hid help",
            "offline": true,
            "description": "help this help demod demodulate hid prox tag from the graphbuffer --------------------------------------------------------------------------------------- lf hid demod available offline: yes try to find hid prox preamble, if found decode / descramble data",
            "usage": "lf hid demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf hid demod"
            ]
        },
        "lf hid reader": {
            "command": "lf hid reader",
            "offline": false,
            "description": "read a hid prox tag",
            "usage": "lf hid reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf hid reader -@ -> continuous reader mode"
            ]
        },
        "lf hid clone": {
            "command": "lf hid clone",
            "offline": false,
            "description": "clone a hid prox tag to a t55x7, q5/t5555 or em4305/4469 tag. tag must be on the antenna when issuing this command.",
            "usage": "lf hid clone [-h] [-w <format>] [--fc <dec>] [--cn <dec>] [-i <dec>] [-o <dec>] [-r <hex>]... [--q5] [--em] [--bin <bin>]",
            "options": [
                "-h, --help this help",
                "-w, --wiegand <format> see `wiegand list` for available formats",
                "--fc <dec> facility code",
                "--cn <dec> card number",
                "-i <dec> issue level",
                "-o, --oem <dec> oem code",
                "-r, --raw <hex> raw bytes",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag",
                "--bin <bin> binary string i.e 0001001001"
            ],
            "notes": [
                "lf hid clone -r 2006ec0c86 -> write raw value (hid 10301 26 bit)",
                "lf hid clone -r 2e0ec00c87 -> write raw value (hid corporate 35 bit)",
                "lf hid clone -r 01f0760643c3 -> write raw value (hid p10001 40 bit)",
                "lf hid clone -r 01400076000c86 -> write raw value (hid corporate 48 bit)",
                "lf hid clone -w h10301 --fc 118 --cn 1603 -> write raw value (hid 10301 26 bit)",
                "lf hid clone -w h10301 --fc 118 --cn 1603 --q5 -> hid 10301 26 bit, encode for q5/t5555 tag",
                "lf hid clone -w h10301 --fc 118 --cn 1603 --em -> hid 10301 26 bit, encode for em4305/4469"
            ]
        },
        "lf hid sim": {
            "command": "lf hid sim",
            "offline": false,
            "description": "enables simulation of hid card with card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf hid sim [-h] [-w <format>] [--fc <dec>] [--cn <dec>] [-i <dec>] [-o <dec>] [-r <hex>]...",
            "options": [
                "-h, --help this help",
                "-w, --wiegand <format> see `wiegand list` for available formats",
                "--fc <dec> facility code",
                "--cn <dec> card number",
                "-i <dec> issue level",
                "-o, --oem <dec> oem code",
                "-r, --raw <hex> raw bytes"
            ],
            "notes": [
                "lf hid sim -r 2006ec0c86 -> hid 10301 26 bit",
                "lf hid sim -r 2e0ec00c87 -> hid corporate 35 bit",
                "lf hid sim -r 01f0760643c3 -> hid p10001 40 bit",
                "lf hid sim -r 01400076000c86 -> hid corporate 48 bit",
                "lf hid sim -w h10301 --fc 118 --cn 1603 -> hid 10301 26 bit"
            ]
        },
        "lf hid brute": {
            "command": "lf hid brute",
            "offline": false,
            "description": "enables bruteforce of hid readers with specified facility code. this is a attack against reader. if cardnumber is given, it starts with it and goes up / down one step if cardnumber is not given, it starts with 1 and goes up to 65535",
            "usage": "lf hid brute [-hv] -w <format> [--fc <dec>] [--cn <dec>] [-i <dec>] [-o <dec>] [-d <dec>] [--up] [--down]",
            "options": [
                "-h, --help this help",
                "-v, --verbose verbose logging, show all tries",
                "-w, --wiegand <format> see `wiegand list` for available formats",
                "--fc <dec> facility code",
                "--cn <dec> card number to start with",
                "-i, --issue <dec> issue level",
                "-o, --oem <dec> oem code",
                "-d, --delay <dec> delay betweens attempts in ms. default 1000ms",
                "--up direction to increment card number. (default is both directions)",
                "--down direction to decrement card number. (default is both directions)"
            ],
            "notes": [
                "lf hid brute -w h10301 --fc 224",
                "lf hid brute -w h10301 --fc 21 -d 2000",
                "lf hid brute -v -w h10301 --fc 21 --cn 200 -d 2000",
                "lf hid brute -v -w h10301 --fc 21 --cn 200 -d 2000 --up"
            ]
        },
        "lf hid watch": {
            "command": "lf hid watch",
            "offline": false,
            "description": "enables hid compatible reader mode printing details. by default, values are printed and logged until the button is pressed or another usb command is issued.",
            "usage": "lf hid watch [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf hid watch"
            ]
        },
        "lf hitag help": {
            "command": "lf hitag help",
            "offline": true,
            "description": "help this help list list hitag trace history --------------------------------------------------------------------------------------- lf hitag eload available offline: no loads hitag tag dump into emulator memory on device",
            "usage": "lf hitag eload [-h12s] -f <filename>",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> filename of dump",
                "-1 simulate hitag1",
                "-2 simulate hitag2",
                "-s simulate hitags"
            ],
            "notes": [
                "lf hitag eload -f lf-hitag-11223344-dump.bin"
            ]
        },
        "lf hitag list": {
            "command": "lf hitag list",
            "offline": true,
            "description": "alias of `trace list -t hitag2` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "lf hitag list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "lf hitag list -f -> show frame delay times",
                "lf hitag list -1 -> use trace buffer"
            ]
        },
        "lf hitag info": {
            "command": "lf hitag info",
            "offline": false,
            "description": "sniff traffic between hitag reader and tag.",
            "usage": "lf hitag info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf hitag info"
            ]
        },
        "lf hitag reader": {
            "command": "lf hitag reader",
            "offline": false,
            "description": "act like a hitag reader",
            "usage": "lf hitag reader [-h] [--01] [--02] [--21] [--22] [--23] [--25] [--26] [-k <hex>] [--nrar <hex>]",
            "options": [
                "-h, --help this help",
                "--01 hitags, read all pages, challenge mode",
                "--02 hitags, read all pages, crypto mode. set key=0 for no auth",
                "--21 hitag2, read all pages, password mode. def 4d494b52 (mikr)",
                "--22 hitag2, read all pages, challenge mode",
                "--23 hitag2, read all pages, crypto mode. key isk high + isk low. def 4f4e4d494b52 (onmikr)",
                "--25 hitag2, test recorded authentications (replay?)",
                "--26 hitag2, read uid",
                "-k, --key <hex> key, 4 or 6 hex bytes",
                "--nrar <hex> nonce / answer reader, 8 hex bytes"
            ],
            "notes": [
                "hitag s",
                "lf hitag reader --01 --nrar 0102030411223344",
                "lf hitag reader --02 -k 4f4e4d494b52",
                "hitag 2",
                "lf hitag reader --21 -k 4d494b52",
                "lf hitag reader --22 --nrar 0102030411223344",
                "lf hitag reader --23 -k 4f4e4d494b52",
                "lf hitag reader --26"
            ]
        },
        "lf hitag sim": {
            "command": "lf hitag sim",
            "offline": false,
            "description": "simulate hitag2 / hitags transponder you need to `lf hitag eload` first",
            "usage": "lf hitag sim [-h12s]",
            "options": [
                "-h, --help this help",
                "-1 simulate hitag1",
                "-2 simulate hitag2",
                "-s simulate hitags"
            ],
            "notes": [
                "lf hitag sim -2"
            ]
        },
        "lf hitag sniff": {
            "command": "lf hitag sniff",
            "offline": false,
            "description": "sniff traffic between hitag reader and tag. use `lf hitag list` to view collected data.",
            "usage": "lf hitag sniff [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf hitag sniff"
            ]
        },
        "lf hitag writer": {
            "command": "lf hitag writer",
            "offline": false,
            "description": "act like a hitag writerin password mode the default key is 4d494b52 (mikr) in crypto mode the default key is 4f4e4d494b52 (onmikr) format: isk high + isk low.",
            "usage": "lf hitag writer [-h] [--03] [--04] [--24] [--27] -p <dec> [-d <hex>] [-k <hex>] [--nrar <hex>]",
            "options": [
                "-h, --help this help",
                "--03 hitags, write page, challenge mode",
                "--04 hitags, write page, crypto mode. set key=0 for no auth",
                "--24 hitag2, write page, crypto mode.",
                "--27 hitag2, write page, password mode",
                "-p, --page <dec> page address to write to",
                "-d, --data <hex> data, 4 hex bytes",
                "-k, --key <hex> key, 4 or 6 hex bytes",
                "--nrar <hex> nonce / answer writer, 8 hex bytes"
            ],
            "notes": [
                "hitag s",
                "lf hitag writer --03 --nrar 0102030411223344 -p 3 -d 01020304",
                "lf hitag writer --04 -k 4f4e4d494b52 -p 3 -d 01020304",
                "hitag 2",
                "lf hitag writer --24 -k 4f4e4d494b52 -p 3 -d 01020304",
                "lf hitag writer --27 -k 4d494b52 -p 3 -d 01020304"
            ]
        },
        "lf hitag dump": {
            "command": "lf hitag dump",
            "offline": false,
            "description": "read all card memory and save to filein password mode the default key is 4d494b52 (mikr) in crypto mode the default key is 4f4e4d494b52 (onmikr) format: isk high + isk low.",
            "usage": "lf hitag dump [-h] [-f <fn>] [-k <hex>] [--nrar <hex>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> file name",
                "-k, --key <hex> key, 4 or 6 hex bytes",
                "--nrar <hex> nonce / answer reader, 8 hex bytes"
            ],
            "notes": [
                "lf hitag dump -k 4f4e4d494b52",
                "lf hitag dump -k 4d494b52"
            ]
        },
        "lf hitag cc": {
            "command": "lf hitag cc",
            "offline": false,
            "description": "check challenges, load a file with saved hitag crypto challenges and test them all. the file should be 8 * 60 bytes long, the file extension defaults to `.cc`",
            "usage": "lf hitag cc [-h] [-f <fn w/o ext>]",
            "options": [
                "-h, --help this help",
                "-f, --filename <fn w/o ext> filename to load from"
            ],
            "notes": [
                "lf hitag cc -f my_hitag_challenges"
            ]
        },
        "lf idteck help": {
            "command": "lf idteck help",
            "offline": true,
            "description": "help this help demod demodulate an idteck tag from the graphbuffer --------------------------------------------------------------------------------------- lf idteck demod available offline: yes try to find idteck preamble, if found decode / descramble data",
            "usage": "lf idteck demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf idteck demod"
            ]
        },
        "lf idteck reader": {
            "command": "lf idteck reader",
            "offline": false,
            "description": "read a idteck tag",
            "usage": "lf idteck reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf idteck reader -@ -> continuous reader mode"
            ]
        },
        "lf idteck clone": {
            "command": "lf idteck clone",
            "offline": false,
            "description": "clone a idteck tag to t55x7 or q5/t5555 tag tag must be on the antenna when issuing this command.",
            "usage": "lf idteck clone [-h] [-r <hex>]... [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw bytes",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf idteck clone --raw 4944544b351fbe4b"
            ]
        },
        "lf idteck sim": {
            "command": "lf idteck sim",
            "offline": false,
            "description": "enables simulation of idteck card. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf idteck sim [-h] [-r <hex>]...",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw bytes"
            ],
            "notes": [
                "lf idteck sim --raw 4944544b351fbe4b"
            ]
        },
        "lf indala help": {
            "command": "lf indala help",
            "offline": true,
            "description": "help this help demod demodulate an indala tag (psk1) from graphbuffer altdemod alternative method to demodulate samples for indala 64 bit uid (option '224' for 224 bit) --------------------------------------------------------------------------------------- lf indala demod available offline: yes tries to psk demodulate the graphbuffer as indala",
            "usage": "lf indala demod [-hi] [--clock <dec>] [--maxerr <dec>]",
            "options": [
                "-h, --help this help",
                "--clock <dec> optional - set clock (as integer), if not set, autodetect.",
                "--maxerr <dec> optional - set maximum allowed errors, default = 100",
                "-i, --invert optional - invert output"
            ],
            "notes": [
                "lf indala demod",
                "lf indala demod --clock 32 -> demod a indala tag from graphbuffer using a clock of rf/32",
                "lf indala demod --clock 32 -i -> demod a indala tag from graphbuffer using a clock of rf/32 and inverting data",
                "lf indala demod --clock 64 -i --maxerror 0 -> demod a indala tag from graphbuffer using a clock of rf/64, inverting data and allowing 0 demod errors"
            ]
        },
        "lf indala altdemod": {
            "command": "lf indala altdemod",
            "offline": true,
            "description": "tries to psk demodulate the graphbuffer as indala this is uses a alternative way to demodulate and was used from the beginning in the pm3 client. it's now considered obsolete but remains because it has sometimes its advantages.",
            "usage": "lf indala altdemod [-hl]",
            "options": [
                "-h, --help this help",
                "-l, --long optional - demod as 224b long format"
            ],
            "notes": [
                "lf indala altdemod",
                "lf indala altdemod --long -> demod a indala tag from graphbuffer as 224 bit long format"
            ]
        },
        "lf indala reader": {
            "command": "lf indala reader",
            "offline": false,
            "description": "read a indala tag",
            "usage": "lf indala reader [-hi@] [--clock <dec>] [--maxerr <dec>]",
            "options": [
                "-h, --help this help",
                "--clock <dec> optional - set clock (as integer), if not set, autodetect.",
                "--maxerr <dec> optional - set maximum allowed errors, default = 100",
                "-i, --invert optional - invert output",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf indala reader -@ -> continuous reader mode"
            ]
        },
        "lf indala clone": {
            "command": "lf indala clone",
            "offline": false,
            "description": "clone indala uid to t55x7 or q5/t5555 tag warning, encoding with fc/cn doesn't always work",
            "usage": "lf indala clone [-h] [-r <hex>]... [--heden <decimal>] [--fc <decimal>] [--cn <decimal>] [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw bytes",
                "--heden <decimal> cardnumber for heden 2l format",
                "--fc <decimal> facility code (26 bit h10301 format)",
                "--cn <decimal> cardnumber (26 bit h10301 format)",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf indala clone --heden 888",
                "lf indala clone --fc 123 --cn 1337",
                "lf indala clone -r a0000000a0002021",
                "lf indala clone -r 80000001b23523a6c2e31eba3cbee4afb3c6ad1fcf649393928c14e5"
            ]
        },
        "lf indala sim": {
            "command": "lf indala sim",
            "offline": false,
            "description": "enables simulation of indala card with specified facility-code and card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf indala sim [-h] [-r <hex>]... [--heden <decimal>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw bytes",
                "--heden <decimal> cardnumber for heden 2l format"
            ],
            "notes": [
                "lf indala sim --heden 888",
                "lf indala sim --raw a0000000a0002021",
                "lf indala sim --raw 80000001b23523a6c2e31eba3cbee4afb3c6ad1fcf649393928c14e5"
            ]
        },
        "lf io help": {
            "command": "lf io help",
            "offline": true,
            "description": "help this help demod demodulate an ioprox tag from the graphbuffer --------------------------------------------------------------------------------------- lf io demod available offline: yes try to find ioprox preamble, if found decode / descramble data",
            "usage": "lf io demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf io demod"
            ]
        },
        "lf io reader": {
            "command": "lf io reader",
            "offline": false,
            "description": "read a ioprox tag",
            "usage": "lf io reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf io reader -@ -> continuous reader mode"
            ]
        },
        "lf io clone": {
            "command": "lf io clone",
            "offline": false,
            "description": "clone a ioprox card with specified facility-code and card number to a t55x7, q5/t5555 or em4305/4469 tag. tag must be on the antenna when issuing this command.",
            "usage": "lf io clone [-h] --vn <dec> --fc <dec> --cn <dec> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--vn <dec> 8bit version",
                "--fc <dec> 8bit facility code",
                "--cn <dec> 16bit card number",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf io clone --vn 1 --fc 101 --cn 1337"
            ]
        },
        "lf io sim": {
            "command": "lf io sim",
            "offline": false,
            "description": "enables simulation of ioprox card with specified facility-code and card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf io sim [-h] --vn <dec> --fc <dec> --cn <dec>",
            "options": [
                "-h, --help this help",
                "--vn <dec> 8bit version",
                "--fc <dec> 8bit facility code",
                "--cn <dec> 16bit card number"
            ],
            "notes": [
                "lf io sim --vn 1 --fc 101 --cn 1337"
            ]
        },
        "lf io watch": {
            "command": "lf io watch",
            "offline": false,
            "description": "enables ioprox compatible reader mode printing details. by default, values are printed and logged until the button is pressed or another usb command is issued.",
            "usage": "lf io watch [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf io watch"
            ]
        },
        "lf jablotron help": {
            "command": "lf jablotron help",
            "offline": true,
            "description": "help this help demod demodulate an jablotron tag from the graphbuffer --------------------------------------------------------------------------------------- lf jablotron demod available offline: yes try to find jablotron preamble, if found decode / descramble data",
            "usage": "lf jablotron demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf jablotron demod"
            ]
        },
        "lf jablotron reader": {
            "command": "lf jablotron reader",
            "offline": false,
            "description": "read a jablotron tag",
            "usage": "lf jablotron reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf jablotron reader -@ -> continuous reader mode"
            ]
        },
        "lf jablotron clone": {
            "command": "lf jablotron clone",
            "offline": false,
            "description": "clone a jablotron tag to a t55x7, q5/t5555 or em4305/4469 tag. tag must be on the antenna when issuing this command.",
            "usage": "lf jablotron clone [-h] --cn <hex> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--cn <hex> jablotron card id - 5 bytes max",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf jablotron clone --cn 01b669",
                "lf jablotron clone --q5 --cn 01b669 -> encode for q5/t5555 tag",
                "lf jablotron clone --em --cn 01b669 -> encode for em4305/4469"
            ]
        },
        "lf jablotron sim": {
            "command": "lf jablotron sim",
            "offline": false,
            "description": "enables simulation of jablotron card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf jablotron sim [-h] --cn <hex>",
            "options": [
                "-h, --help this help",
                "--cn <hex> jablotron card id - 5 bytes max"
            ],
            "notes": [
                "lf jablotron sim --cn 01b669"
            ]
        },
        "lf keri help": {
            "command": "lf keri help",
            "offline": true,
            "description": "help this help demod demodulate an keri tag from the graphbuffer --------------------------------------------------------------------------------------- lf keri demod available offline: yes try to find keri preamble, if found decode / descramble data",
            "usage": "lf keri demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf keri demod"
            ]
        },
        "lf keri reader": {
            "command": "lf keri reader",
            "offline": false,
            "description": "read a keri tag",
            "usage": "lf keri reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf keri reader -@ -> continuous reader mode"
            ]
        },
        "lf keri clone": {
            "command": "lf keri clone",
            "offline": false,
            "description": "clone a keri tag to a t55x7, q5/t5555 or em4305/4469 tag",
            "usage": "lf keri clone [-h] [-t <m|i>] [--fc <dec>] --cn <dec> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-t, --type <m|i> type m - ms, i - internal id",
                "--fc <dec> facility code",
                "--cn <dec> keri card id",
                "--q5 specify writing to q5/t5555 tag",
                "--em specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf keri clone -t i --cn 12345 -> internal id",
                "lf keri clone -t m --fc 6 --cn 12345 -> ms id"
            ]
        },
        "lf keri sim": {
            "command": "lf keri sim",
            "offline": false,
            "description": "enables simulation of keri card with internal id. you supply a keri card id and it will converted to a keri internal id.",
            "usage": "lf keri sim [-h] --id <dec>",
            "options": [
                "-h, --help this help",
                "--id <dec> keri card id"
            ],
            "notes": [
                "lf keri sim --cn 112233"
            ]
        },
        "lf motorola help": {
            "command": "lf motorola help",
            "offline": true,
            "description": "help this help demod demodulate an motorola tag from the graphbuffer --------------------------------------------------------------------------------------- lf motorola demod available offline: yes try to find motorola preamble, if found decode / descramble data",
            "usage": "lf motorola demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf motorola demod"
            ]
        },
        "lf motorola reader": {
            "command": "lf motorola reader",
            "offline": false,
            "description": "read a motorola tag",
            "usage": "lf motorola reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf motorola reader -@ -> continuous reader mode"
            ]
        },
        "lf motorola clone": {
            "command": "lf motorola clone",
            "offline": false,
            "description": "clone motorola uid to a t55x7, q5/t5555 or em4305/4469 tag. defaults to 64 bit format",
            "usage": "lf motorola clone [-h] -r <hex> [-r <hex>]... [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex bytes. 8 bytes",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf motorola clone --raw a0000000a0002021",
                "lf motorola clone --q5 --raw a0000000a0002021 -> encode for q5/t5555 tag",
                "lf motorola clone --em --raw a0000000a0002021 -> encode for em4305/4469"
            ]
        },
        "lf motorola sim": {
            "command": "lf motorola sim",
            "offline": false,
            "description": "enables simulation of motorola card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf motorola sim [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf motorola sim"
            ]
        },
        "lf nedap help": {
            "command": "lf nedap help",
            "offline": true,
            "description": "help this help demod demodulate nedap tag from the graphbuffer --------------------------------------------------------------------------------------- lf nedap demod available offline: yes try to find nedap preamble, if found decode / descramble data",
            "usage": "lf nedap demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf nedap demod"
            ]
        },
        "lf nedap reader": {
            "command": "lf nedap reader",
            "offline": false,
            "description": "read a nedap tag",
            "usage": "lf nedap reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf nedap reader -@ -> continuous reader mode"
            ]
        },
        "lf nedap clone": {
            "command": "lf nedap clone",
            "offline": false,
            "description": "clone a nedap tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf nedap clone [-hl] [--st <dec>] --cc <dec> --id <dec> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--st <dec> optional - sub type (default 5)",
                "--cc <dec> customer code (0-4095)",
                "--id <dec> id (0-99999)",
                "-l, --long optional - long (128), default to short (64)",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf nedap clone --st 1 --cc 101 --id 1337"
            ]
        },
        "lf nedap sim": {
            "command": "lf nedap sim",
            "offline": false,
            "description": "enables simulation of nedap card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf nedap sim [-hl] [--st <dec>] --cc <dec> --id <dec>",
            "options": [
                "-h, --help this help",
                "--st <dec> optional - sub type (default 5)",
                "--cc <dec> customer code (0-4095)",
                "--id <dec> id (0-99999)",
                "-l, --long optional - long (128), default to short (64)"
            ],
            "notes": [
                "lf nedap sim --st 1 --cc 101 --id 1337"
            ]
        },
        "lf nexwatch help": {
            "command": "lf nexwatch help",
            "offline": true,
            "description": "help this help demod demodulate a nexwatch tag (nexkey, quadrakey) from the graphbuffer --------------------------------------------------------------------------------------- lf nexwatch demod available offline: yes try to find nexwatch preamble, if found decode / descramble data",
            "usage": "lf nexwatch demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf nexwatch demod"
            ]
        },
        "lf nexwatch reader": {
            "command": "lf nexwatch reader",
            "offline": false,
            "description": "read a nexwatch tag",
            "usage": "lf nexwatch reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf nexwatch reader -@ -> continuous reader mode"
            ]
        },
        "lf nexwatch clone": {
            "command": "lf nexwatch clone",
            "offline": false,
            "description": "clone a nexwatch tag to a t55x7, q5/t5555 or em4305/4469 tag. you can use raw hex values or create a credential based on id, mode and type of credential (nexkey / quadrakey)",
            "usage": "lf nexwatch clone [-hnq] [-r <hex>] [--cn <dec>] [-m <dec>] [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes",
                "--cn <dec> card id",
                "-m, --mode <dec> mode (decimal) (0-15, defaults to 1)",
                "-n nexkey credential",
                "-q quadrakey credential",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf nexwatch clone --raw 5600000000213c9f8f150c00",
                "lf nexwatch clone --cn 521512301 -m 1 -n -> nexkey credential",
                "lf nexwatch clone --cn 521512301 -m 1 -q -> quadrakey credential"
            ]
        },
        "lf nexwatch sim": {
            "command": "lf nexwatch sim",
            "offline": false,
            "description": "enables simulation of secura card with specified card number. simulation runs until the button is pressed or another usb command is issued. you can use raw hex values or create a credential based on id, mode and type of credential (nexkey/quadrakey)",
            "usage": "lf nexwatch sim [-hnq] [-r <hex>] [--cn <dec>] [-m <dec>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes",
                "--cn <dec> card id",
                "-m, --mode <dec> mode (decimal) (0-15, defaults to 1)",
                "-n nexkey credential",
                "-q quadrakey credential"
            ],
            "notes": [
                "lf nexwatch sim --raw 5600000000213c9f8f150c00",
                "lf nexwatch sim --cn 521512301 -m 1 -n -> nexkey credential",
                "lf nexwatch sim --cn 521512301 -m 1 -q -> quadrakey credential"
            ]
        },
        "lf noralsy help": {
            "command": "lf noralsy help",
            "offline": true,
            "description": "help this help demod demodulate an noralsy tag from the graphbuffer --------------------------------------------------------------------------------------- lf noralsy demod available offline: yes try to find noralsy preamble, if found decode / descramble data",
            "usage": "lf noralsy demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf noralsy demod"
            ]
        },
        "lf noralsy reader": {
            "command": "lf noralsy reader",
            "offline": false,
            "description": "read a noralsy tag",
            "usage": "lf noralsy reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf noralsy reader -@ -> continuous reader mode"
            ]
        },
        "lf noralsy clone": {
            "command": "lf noralsy clone",
            "offline": false,
            "description": "clone a noralsy tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf noralsy clone [-h] --cn <dec> [-y <dec>] [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--cn <dec> noralsy card id",
                "-y, --year <dec> tag allocation year",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf noralsy clone --cn 112233",
                "lf noralsy clone --cn 112233 --q5 -> encode for q5/t5555 tag",
                "lf noralsy clone --cn 112233 --em -> encode for em4305/4469"
            ]
        },
        "lf noralsy sim": {
            "command": "lf noralsy sim",
            "offline": false,
            "description": "enables simulation of noralsy card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf noralsy sim [-h] --cn <dec> [-y <dec>]",
            "options": [
                "-h, --help this help",
                "--cn <dec> noralsy card id",
                "-y, --year <dec> tag allocation year"
            ],
            "notes": [
                "lf noralsy sim --cn 1337",
                "lf noralsy sim --cn 1337 --year 2010"
            ]
        },
        "lf pac help": {
            "command": "lf pac help",
            "offline": true,
            "description": "help this help demod demodulate a pac tag from the graphbuffer --------------------------------------------------------------------------------------- lf pac demod available offline: yes try to find pac/stanley preamble, if found decode / descramble data",
            "usage": "lf pac demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf pac demod"
            ]
        },
        "lf pac reader": {
            "command": "lf pac reader",
            "offline": false,
            "description": "read a pac/stanley tag",
            "usage": "lf pac reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf pac reader -@ -> continuous reader mode"
            ]
        },
        "lf pac clone": {
            "command": "lf pac clone",
            "offline": false,
            "description": "clone a pac/stanley tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf pac clone [-h] [--cn <dec>] [-r <hex>] [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--cn <dec> 8 byte pac/stanley card id",
                "-r, --raw <hex> raw hex data. 16 bytes max",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf pac clone --cn cd4f5552",
                "lf pac clone --cn cd4f5552 --q5 -> encode for q5/t5555 tag",
                "lf pac clone --cn cd4f5552 --em -> encode for em4305/4469",
                "lf pac clone --raw ff2049906d8511c593155b56d5b2649f"
            ]
        },
        "lf pac sim": {
            "command": "lf pac sim",
            "offline": false,
            "description": "enables simulation of pac/stanley card with specified card number. simulation runs until the button is pressed or another usb command is issued. the card id is 8 byte number. larger values are truncated.",
            "usage": "lf pac sim [-h] [--cn <dec>] [-r <hex>]",
            "options": [
                "-h, --help this help",
                "--cn <dec> 8 byte pac/stanley card id",
                "-r, --raw <hex> raw hex data. 16 bytes max"
            ],
            "notes": [
                "lf pac sim --cn cd4f5552",
                "lf pac sim --raw ff2049906d8511c593155b56d5b2649f"
            ]
        },
        "lf paradox help": {
            "command": "lf paradox help",
            "offline": true,
            "description": "help this help demod demodulate a paradox fsk tag from the graphbuffer --------------------------------------------------------------------------------------- lf paradox demod available offline: yes try to find paradox preamble, if found decode / descramble data",
            "usage": "lf paradox demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf paradox demod"
            ]
        },
        "lf paradox reader": {
            "command": "lf paradox reader",
            "offline": false,
            "description": "read a paradox tag",
            "usage": "lf paradox reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf paradox reader -@ -> continuous reader mode"
            ]
        },
        "lf paradox clone": {
            "command": "lf paradox clone",
            "offline": false,
            "description": "clone a paradox tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf paradox clone [-h] [-r <hex>] [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes max",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf paradox clone --raw 0f55555695596a6a9999a59a",
                "lf paradox clone -r 0f55555695596a6a9999a59a --q5 -> encode for q5/t5555 tag",
                "lf paradox clone -r 0f55555695596a6a9999a59a --em -> encode for em4305/4469"
            ]
        },
        "lf paradox sim": {
            "command": "lf paradox sim",
            "offline": false,
            "description": "enables simulation of paradox card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf paradox sim [-h] [-r <hex>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes"
            ],
            "notes": [
                "lf paradox sim --raw 0f55555695596a6a9999a59a"
            ]
        },
        "lf pcf7931 help": {
            "command": "lf pcf7931 help",
            "offline": true,
            "description": "help this help config configure the password, the tags initialization delay and time offsets (optional) --------------------------------------------------------------------------------------- lf pcf7931 reader available offline: no read a pcf7931 tag",
            "usage": "lf pcf7931 reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf pcf7931 reader -@ -> continuous reader mode"
            ]
        },
        "lf pcf7931 write": {
            "command": "lf pcf7931 write",
            "offline": false,
            "description": "this command tries to write a pcf7931 tag.",
            "usage": "lf pcf7931 write [-h] -b <dec> -i <dec> -d <hex>",
            "options": [
                "-h, --help this help",
                "-b, --blk <dec> [0-7] block number",
                "-i, --idx <dec> [0-15] index of byte inside block",
                "-d, --data <hex> one byte to be written"
            ],
            "notes": [
                "lf pcf7931 write --blk 2 --idx 1 -d ff -> write 0xff to block 2, index 1"
            ]
        },
        "lf pcf7931 config": {
            "command": "lf pcf7931 config",
            "offline": true,
            "description": "this command tries to set the configuration used with pcf7931 commands the time offsets could be useful to correct slew rate generated by the antenna caling without some parameter will print the current configuration.",
            "usage": "lf pcf7931 config [-hr] [-p <hex>] [-d <dec>] [--lw <dec>] [--lp <dec>]",
            "options": [
                "-h, --help this help",
                "-r, --reset reset configuration to default values",
                "-p, --pwd <hex> password, 7bytes, lsb-order",
                "-d, --delay <dec> tag initialization delay (in us)",
                "--lw <dec> offset, low pulses width (in us)",
                "--lp <dec> offset, low pulses position (in us)"
            ],
            "notes": [
                "lf pcf7931 config --reset",
                "lf pcf7931 config --pwd 11223344556677 -d 20000",
                "lf pcf7931 config --pwd 11223344556677 -d 17500 --lw -10 --lp 30"
            ]
        },
        "lf presco help": {
            "command": "lf presco help",
            "offline": true,
            "description": "help this help demod demodulate presco tag from the graphbuffer --------------------------------------------------------------------------------------- lf presco demod available offline: yes try to find presco preamble, if found decode / descramble data",
            "usage": "lf presco demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf presco demod"
            ]
        },
        "lf presco reader": {
            "command": "lf presco reader",
            "offline": false,
            "description": "read a presco tag",
            "usage": "lf presco reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf presco reader -@ -> continuous reader mode"
            ]
        },
        "lf presco clone": {
            "command": "lf presco clone",
            "offline": false,
            "description": "clone a presco tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf presco clone [-h] [-c <hex>] [-d <digits>] [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-c <hex> 8 digit hex card number",
                "-d <digits> 9 digit presco card id",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf presco clone -d 018363467",
                "lf presco clone -d 018363467 --q5 -> encode for q5/t5555 tag",
                "lf presco clone -d 018363467 --em -> encode for em4305/4469"
            ]
        },
        "lf presco sim": {
            "command": "lf presco sim",
            "offline": false,
            "description": "enables simulation of presco card with specified card number. simulation runs until the button is pressed or another usb command is issued. per presco format, the card number is 9 digit number and can contain *# chars. larger values are truncated.",
            "usage": "lf presco sim [-h] [-c <hex>] [-d <digits>]",
            "options": [
                "-h, --help this help",
                "-c <hex> 8 digit hex card number",
                "-d <digits> 9 digit presco card id"
            ],
            "notes": [
                "lf presco sim -d 018363467"
            ]
        },
        "lf pyramid help": {
            "command": "lf pyramid help",
            "offline": true,
            "description": "help this help demod demodulate a pyramid fsk tag from the graphbuffer --------------------------------------------------------------------------------------- lf pyramid demod available offline: yes try to find farpoint/pyramid preamble, if found decode / descramble data",
            "usage": "lf pyramid demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf pyramid demod"
            ]
        },
        "lf pyramid reader": {
            "command": "lf pyramid reader",
            "offline": false,
            "description": "read a farpointe/pyramid tag",
            "usage": "lf pyramid reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf pyramid reader -@ -> continuous reader mode"
            ]
        },
        "lf pyramid clone": {
            "command": "lf pyramid clone",
            "offline": false,
            "description": "clone a farpointe/pyramid tag to a t55x7, q5/t5555 or em4305/4469 tag. the facility-code is 8-bit and the card number is 16-bit. larger values are truncated. currently only works on 26bit",
            "usage": "lf pyramid clone [-h] --fc <dec> --cn <dec> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--fc <dec> 8-bit value facility code",
                "--cn <dec> 16-bit value card number",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf pyramid clone --fc 123 --cn 11223",
                "lf pyramid clone --fc 123 --cn 11223 --q5 -> encode for q5/t5555 tag",
                "lf pyramid clone --fc 123 --cn 11223 --em -> encode for em4305/4469"
            ]
        },
        "lf pyramid sim": {
            "command": "lf pyramid sim",
            "offline": false,
            "description": "enables simulation of farpointe/pyramid card with specified card number. simulation runs until the button is pressed or another usb command is issued. the facility-code is 8-bit and the card number is 16-bit. larger values are truncated. currently work only on 26bit",
            "usage": "lf pyramid sim [-h] --fc <dec> --cn <dec>",
            "options": [
                "-h, --help this help",
                "--fc <dec> 8-bit value facility code",
                "--cn <dec> 16-bit value card number"
            ],
            "notes": [
                "lf pyramid sim --fc 123 --cn 1337"
            ]
        },
        "lf securakey help": {
            "command": "lf securakey help",
            "offline": true,
            "description": "help this help demod demodulate an securakey tag from the graphbuffer --------------------------------------------------------------------------------------- lf securakey demod available offline: yes try to find securakey preamble, if found decode / descramble data",
            "usage": "lf securakey demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf securakey demod"
            ]
        },
        "lf securakey reader": {
            "command": "lf securakey reader",
            "offline": false,
            "description": "read a securakey tag",
            "usage": "lf securakey reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf securakey reader -@ -> continuous reader mode"
            ]
        },
        "lf securakey clone": {
            "command": "lf securakey clone",
            "offline": false,
            "description": "clone a securakey tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf securakey clone [-h] -r <hex> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf securakey clone --raw 7fcb400001adea5344300000",
                "lf securakey clone --q5 --raw 7fcb400001adea5344300000 -> encode for q5/t5555 tag",
                "lf securakey clone --em --raw 7fcb400001adea5344300000 -> encode for em4305/4469"
            ]
        },
        "lf securakey sim": {
            "command": "lf securakey sim",
            "offline": false,
            "description": "enables simulation of secura card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf securakey sim [-h] [-r <hex>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 12 bytes"
            ],
            "notes": [
                "lf securakey sim --raw 7fcb400001adea5344300000"
            ]
        },
        "lf ti help": {
            "command": "lf ti help",
            "offline": true,
            "description": "help this help demod demodulate raw bits for ti lf tag from the graphbuffer --------------------------------------------------------------------------------------- lf ti demod available offline: yes try to find ti preamble, if found decode / descramble data",
            "usage": "lf ti demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf ti demod"
            ]
        },
        "lf ti reader": {
            "command": "lf ti reader",
            "offline": false,
            "description": "read a ti tag",
            "usage": "lf ti reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf ti reader -@ -> continuous reader mode"
            ]
        },
        "lf ti write": {
            "command": "lf ti write",
            "offline": false,
            "description": "write to a r/w ti tag.",
            "usage": "lf ti write [-h] -r <hex> [--crc <hex>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex data. 8 bytes max",
                "--crc <hex> optional - crc"
            ],
            "notes": [
                "lf ti write --raw 1122334455667788",
                "lf ti write --raw 1122334455667788 --crc 1122"
            ]
        },
        "lf t55xx help": {
            "command": "lf t55xx help",
            "offline": true,
            "description": "----------- ---------------------------- notice ----------------------------- remember to run `lf t55xx detect` first whenever a new card is placed on the proxmark3 or the config block changed. help this help ----------- --------------------- operations --------------------- config set/get t55xx configuration (modulation, inverted, offset, rate) detect try detecting the tag modulation from reading the configuration block info show t55x7 configuration data (page 0/ blk 0) trace show t55x7 traceability data (page 1/ blk 0-1) ----------- --------------------- recovery --------------------- sniff attempt to recover t55xx commands from sample buffer --------------------------------------------------------------------------------------- lf t55xx clonehelp available offline: no display a list of available commands for cloning specific techs on t5xx tags",
            "usage": "lf t55xx clonehelp [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf t55xx clonehelp"
            ]
        },
        "lf t55xx config": {
            "command": "lf t55xx config",
            "offline": true,
            "description": "set/get t55xx configuration of the pm3 client. like modulation, inverted, offset, rate etc. offset is start position to decode data.",
            "usage": "lf t55xx config [-hi] [--fsk] [--fsk1] [--fsk1a] [--fsk2] [--fsk2a] [--ask] [--psk1] [--psk2] [--psk3] [--nrz] [--bi] [--bia] [--q5] [--st] [--rate <dec>] [-c <hex>] [-o <0-255>] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "--fsk set demodulation fsk",
                "--fsk1 set demodulation fsk 1",
                "--fsk1a set demodulation fsk 1a (inv)",
                "--fsk2 set demodulation fsk 2",
                "--fsk2a set demodulation fsk 2a (inv)",
                "--ask set demodulation ask",
                "--psk1 set demodulation psk 1",
                "--psk2 set demodulation psk 2",
                "--psk3 set demodulation psk 3",
                "--nrz set demodulation nrz",
                "--bi set demodulation biphase",
                "--bia set demodulation diphase (inverted biphase)",
                "-i, --inv set/reset data signal inversion",
                "--q5 set/reset as q5/t5555 chip instead of t55x7",
                "--st set/reset sequence terminator on",
                "--rate <dec> set bitrate <8|16|32|40|50|64|100|128>",
                "-c, --blk0 <hex> set configuration from a block0 (4 hex bytes)",
                "-o, --offset <0-255> set offset, where data should start decode in bitstream",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx config --fsk -> fsk demodulation",
                "lf t55xx config --fsk -i -> fsk demodulation, inverse data",
                "lf t55xx config --fsk -i -o 3 -> fsk demodulation, inverse data, offset 3"
            ]
        },
        "lf t55xx dangerraw": {
            "command": "lf t55xx dangerraw",
            "offline": false,
            "description": "this command allows to emit arbitrary raw commands on t5577 and cut the field after arbitrary duration. uncontrolled usage can easily write an invalid configuration, activate lock bits, otp bit, password protection bit, deactivate test-mode, lock your card forever. warning: this may lock definitively the tag in an unusable state!",
            "usage": "lf t55xx dangerraw [-h] -d <string> -t <us>",
            "options": [
                "-h, --help this help",
                "-d, --data <string> raw bit string",
                "-t, --time <us> <0 - 200000> time in microseconds before dropping the field"
            ],
            "notes": [
                "lf t55xx dangerraw -d 01000000000000010000100000000100000000 -t 3200"
            ]
        },
        "lf t55xx detect": {
            "command": "lf t55xx detect",
            "offline": true,
            "description": "try detecting the tag modulation from reading the configuration block",
            "usage": "lf t55xx detect [-h1] [-p <hex>] [--r0] [--r1] [--r2] [--r3] [--all]",
            "options": [
                "-h, --help this help",
                "-1 extract using data from graphbuffer",
                "-p, --pwd <hex> password (4 hex bytes)",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference",
                "--all try all downlink modes"
            ],
            "notes": [
                "lf t55xx detect",
                "lf t55xx detect -1",
                "lf t55xx detect -p 11223344"
            ]
        },
        "lf t55xx deviceconfig": {
            "command": "lf t55xx deviceconfig",
            "offline": false,
            "description": "sets t55x7 timings for direct commands. the timings are set here in field clocks (fc) which is converted to (us) on device.",
            "usage": "lf t55xx deviceconfig [-hpz] [-a <8..255>] [-b <8..255>] [-c <8..255>] [-d <8..255>] [-e <8..255>] [-f <8..255>] [-g <8..255>] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-a <8..255> set start gap",
                "-b <8..255> set write gap",
                "-c <8..255> set write zero gap",
                "-d <8..255> set write one gap",
                "-e <8..255> set read gap",
                "-f <8..255> set write two gap (1 of 4 only)",
                "-g <8..255> set write three gap (1 of 4 only)",
                "-p, --persist persist to flash memory (rdv4)",
                "-z set default t55x7 timings (use `-p` to save if required)",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx deviceconfig -a 29 -b 17 -c 15 -d 47 -e 15 -> default t55xx",
                "lf t55xx deviceconfig -a 55 -b 14 -c 21 -d 30 -> default em4305"
            ]
        },
        "lf t55xx dump": {
            "command": "lf t55xx dump",
            "offline": false,
            "description": "this command dumps a t55xx card page 0 block 0-7. it will create three files (bin/eml/json)",
            "usage": "lf t55xx dump [-ho] [-f <fn>] [-p <hex>] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-f, --filename <fn> filename (default is generated on blk 0)",
                "-o, --override override, force pwd read despite danger to card",
                "-p, --pwd <hex> password (4 hex bytes)",
                "--r0 downlink - fixed bit length",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx dump",
                "lf t55xx dump -p aabbccdd --override",
                "lf t55xx dump -f my_lf_dump"
            ]
        },
        "lf t55xx info": {
            "command": "lf t55xx info",
            "offline": true,
            "description": "show t55x7 configuration data (page 0/ blk 0) from reading the configuration block from tag. use `-c` to specify a config block data to be used instead of reading tag.",
            "usage": "lf t55xx info [-h1] [-p <hex>] [-c <hex>] [--q5] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-1 extract using data from graphbuffer",
                "-p, --pwd <hex> password (4 hex bytes)",
                "-c, --blk0 <hex> use these data instead (4 hex bytes)",
                "--q5 interprete provided data as t5555/q5 config",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx info",
                "lf t55xx info -1",
                "lf t55xx info -p 11223344",
                "lf t55xx info -c 00083040",
                "lf t55xx info -c 6001805a --q5"
            ]
        },
        "lf t55xx p1detect": {
            "command": "lf t55xx p1detect",
            "offline": false,
            "description": "detect page 1 of a t55xx chip",
            "usage": "lf t55xx p1detect [-h1] [-p <hex>] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-1 extract using data from graphbuffer",
                "-p, --pwd <hex> password (4 hex bytes)",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx p1detect",
                "lf t55xx p1detect -1",
                "lf t55xx p1detect -p 11223344 --r3"
            ]
        },
        "lf t55xx read": {
            "command": "lf t55xx read",
            "offline": false,
            "description": "read t55xx block data. this commands defaults to page 0. * * * warning * * * use of read with password on a tag not configured for a password can damage the tag * * * * * * * * * *",
            "usage": "lf t55xx read [-ho] -b <0-7> [-p <hex>] [--pg1] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-b, --blk <0-7> block number to read",
                "-p, --pwd <hex> password (4 hex bytes)",
                "-o, --override override safety check",
                "--pg1 read page 1",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx read -b 0 -> read data from block 0",
                "lf t55xx read -b 0 --pwd 01020304 -> read data from block 0, pwd 01020304",
                "lf t55xx read -b 0 --pwd 01020304 -o -> read data from block 0, pwd 01020304, override"
            ]
        },
        "lf t55xx resetread": {
            "command": "lf t55xx resetread",
            "offline": false,
            "description": "send reset cmd then `lf read` the stream to attempt to identify the start of it (needs a demod and/or plot after)",
            "usage": "lf t55xx resetread [-h1] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-1 extract using data from graphbuffer",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx resetread"
            ]
        },
        "lf t55xx restore": {
            "command": "lf t55xx restore",
            "offline": false,
            "description": "restore t55xx card page 0/1 n blocks from (bin/eml/json) dump file",
            "usage": "lf t55xx restore [-h] [-f <fn>] [-p <hex>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> filename of dump file",
                "-p, --pwd <hex> password if target card has password set (4 hex bytes)"
            ],
            "notes": [
                "lf t55xx restore -f lf-t55xx-00148040-dump.bin"
            ]
        },
        "lf t55xx trace": {
            "command": "lf t55xx trace",
            "offline": true,
            "description": "show t55x7 configuration data (page 0/ blk 0) from reading the configuration block",
            "usage": "lf t55xx trace [-h1] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-1 extract using data from graphbuffer",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx trace",
                "lf t55xx trace -1"
            ]
        },
        "lf t55xx wakeup": {
            "command": "lf t55xx wakeup",
            "offline": false,
            "description": "this commands sends the answer-on-request command and leaves the readerfield on afterwards",
            "usage": "lf t55xx wakeup [-hv] [-p <hex>] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-p, --pwd <hex> password (4 hex bytes)",
                "-v, --verbose verbose output",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx wakeup -p 11223344 -> send wakeup with password"
            ]
        },
        "lf t55xx write": {
            "command": "lf t55xx write",
            "offline": false,
            "description": "write t55xx block data",
            "usage": "lf t55xx write [-ht] -b <0-7> [-d <hex>] [-p <hex>] [--pg1] [--verify] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-b, --blk <0-7> block number to write",
                "-d, --data <hex> data to write (4 hex bytes)",
                "-p, --pwd <hex> password (4 hex bytes)",
                "-t, --tm test mode write ( danger )",
                "--pg1 write page 1",
                "--verify try validate data afterward",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx write -b 3 -d 11223344 -> write 11223344 to block 3",
                "lf t55xx write -b 3 -d 11223344 --pwd 01020304 -> write 11223344 to block 3, pwd 01020304",
                "lf t55xx write -b 3 -d 11223344 --pwd 01020304 --verify -> write 11223344 to block 3 and try validating write"
            ]
        },
        "lf t55xx bruteforce": {
            "command": "lf t55xx bruteforce",
            "offline": false,
            "description": "this command uses bruteforce to scan a number range. try reading page 0, block 7 before. warning this may brick non-password protected chips!",
            "usage": "lf t55xx bruteforce [-h] -s <hex> -e <hex> [--r0] [--r1] [--r2] [--r3] [--all]",
            "options": [
                "-h, --help this help",
                "-s, --start <hex> search start password (4 hex bytes)",
                "-e, --end <hex> search end password (4 hex bytes)",
                "--r0 downlink - fixed bit length",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference",
                "--all try all downlink modes (def)"
            ],
            "notes": [
                "lf t55xx bruteforce --r2 -s aaaaaa77 -e aaaaaa99"
            ]
        },
        "lf t55xx chk": {
            "command": "lf t55xx chk",
            "offline": false,
            "description": "this command uses a dictionary attack. for some cloners, try '--em' for known pwdgen algo. try to reading page 0 block 7 before. warning: this may brick non-password protected chips!",
            "usage": "lf t55xx chk [-hm] [-f <fn>] [--em <hex>] [--r0] [--r1] [--r2] [--r3] [--all]",
            "options": [
                "-h, --help this help",
                "-m, --fm use dictionary from flash memory (rdv4)",
                "-f, --file <fn> file name",
                "--em <hex> em4100 id (5 hex bytes)",
                "--r0 downlink - fixed bit length",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference",
                "--all try all downlink modes (def)"
            ],
            "notes": [
                "lf t55xx chk -m -> use dictionary from flash memory (rdv4)",
                "lf t55xx chk -f my_dictionary_pwds -> loads a default keys dictionary file",
                "lf t55xx chk --em aa11223344 -> try known pwdgen algo from some cloners based on em4100 id"
            ]
        },
        "lf t55xx protect": {
            "command": "lf t55xx protect",
            "offline": false,
            "description": "this command sets the pwd bit on t5577. warning this locks the tag!",
            "usage": "lf t55xx protect [-ho] [-p <hex>] -n <hex> [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-o, --override override safety check",
                "-p, --pwd <hex> password (4 hex bytes)",
                "-n, --new <hex> new password (4 hex bytes)",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx protect -n 01020304 -> sets new pwd 01020304",
                "lf t55xx protect -p 11223344 -n 00000000 -> use pwd 11223344, sets new pwd 00000000"
            ]
        },
        "lf t55xx recoverpw": {
            "command": "lf t55xx recoverpw",
            "offline": false,
            "description": "this command uses a few tricks to try to recover mangled password. try reading page 0, block 7 before. warning this may brick non-password protected chips!",
            "usage": "lf t55xx recoverpw [-h] [-p <hex>] [--r0] [--r1] [--r2] [--r3] [--all]",
            "options": [
                "-h, --help this help",
                "-p, --pwd <hex> password (4 hex bytes)",
                "--r0 downlink - fixed bit length",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference",
                "--all try all downlink modes (def)"
            ],
            "notes": [
                "lf t55xx recoverpw",
                "lf t55xx recoverpw -p 11223344",
                "lf t55xx recoverpw -p 11223344 --r3"
            ]
        },
        "lf t55xx sniff": {
            "command": "lf t55xx sniff",
            "offline": true,
            "description": "sniff lf t55xx based trafic and decode possible cmd / blocks. lower tolerance means tighter pulses.",
            "usage": "lf t55xx sniff [-h1] [-t <dec>] [-o <dec>] [-z <dec>]",
            "options": [
                "-h, --help this help",
                "-1 extract using data from graphbuffer",
                "-t, --tol <dec> set tolerance level (default 5)",
                "-o, --one <dec> set samples width for one pulse (default auto)",
                "-z, --zero <dec> set samples width for zero pulse (default auto)"
            ],
            "notes": [
                "lf t55xx sniff",
                "lf t55xx sniff -1 -t 2 -> use buffer with tolerance of 2",
                "lf t55xx sniff -1 --zero 7 --one 14 -> use buffer, zero pulse width 7, one pulse width 15"
            ]
        },
        "lf t55xx special": {
            "command": "lf t55xx special",
            "offline": false,
            "description": "show block changes with 64 different offsets, data taken from demod buffer.",
            "usage": "lf t55xx special [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf t55xx special"
            ]
        },
        "lf t55xx wipe": {
            "command": "lf t55xx wipe",
            "offline": false,
            "description": "this commands wipes a tag, fills blocks 1-7 with zeros and a default configuration block",
            "usage": "lf t55xx wipe [-h] [-c <hex>] [-p <hex>] [--q5] [--r0] [--r1] [--r2] [--r3]",
            "options": [
                "-h, --help this help",
                "-c, --cfg <hex> configuration block0 (4 hex bytes)",
                "-p, --pwd <hex> password (4 hex bytes)",
                "--q5 specify writing to q5/t5555 tag using dedicated config block",
                "--r0 downlink - fixed bit length (detected def)",
                "--r1 downlink - long leading reference",
                "--r2 downlink - leading zero",
                "--r3 downlink - 1 of 4 coding reference"
            ],
            "notes": [
                "lf t55xx wipe -> wipes a t55x7 tag, config block 0x000880e0",
                "lf t55xx wipe --q5 -> wipes a q5/t5555 tag, config block 0x6001f004",
                "lf t55xx wipe -p 11223344 -> wipes a t55x7 tag, config block 0x000880e0, using pwd"
            ]
        },
        "lf viking help": {
            "command": "lf viking help",
            "offline": true,
            "description": "help this help demod demodulate a viking tag from the graphbuffer --------------------------------------------------------------------------------------- lf viking demod available offline: yes try to find viking am preamble, if found decode / descramble data",
            "usage": "lf viking demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf viking demod"
            ]
        },
        "lf viking reader": {
            "command": "lf viking reader",
            "offline": false,
            "description": "read a viking am tag",
            "usage": "lf viking reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf viking reader -@ -> continuous reader mode"
            ]
        },
        "lf viking clone": {
            "command": "lf viking clone",
            "offline": false,
            "description": "clone a viking am tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf viking clone [-h] [--cn <hex>]... [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--cn <hex> 8 digit hex viking card number",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf viking clone --cn 01a337",
                "lf viking clone --cn 01a337 --q5 -> encode for q5/t5555 tag",
                "lf viking clone --cn 112233 --em -> encode for em4305/4469"
            ]
        },
        "lf viking sim": {
            "command": "lf viking sim",
            "offline": false,
            "description": "enables simulation of viking card with specified card number. simulation runs until the button is pressed or another usb command is issued. per viking format, the card number is 8 digit hex number. larger values are truncated.",
            "usage": "lf viking sim [-h] [--cn <hex>]...",
            "options": [
                "-h, --help this help",
                "--cn <hex> 8 digit hex viking card number"
            ],
            "notes": [
                "lf viking sim --cn 01a337"
            ]
        },
        "lf visa2000 help": {
            "command": "lf visa2000 help",
            "offline": true,
            "description": "help this help demod demodulate an visa2000 tag from the graphbuffer --------------------------------------------------------------------------------------- lf visa2000 demod available offline: yes try to find visa2000 preamble, if found decode / descramble data",
            "usage": "lf visa2000 demod [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "lf visa2000 demod"
            ]
        },
        "lf visa2000 reader": {
            "command": "lf visa2000 reader",
            "offline": false,
            "description": "read a visa2000 tag",
            "usage": "lf visa2000 reader [-h@]",
            "options": [
                "-h, --help this help",
                "-@ optional - continuous reader mode"
            ],
            "notes": [
                "lf visa2000 reader -@ -> continuous reader mode"
            ]
        },
        "lf visa2000 clone": {
            "command": "lf visa2000 clone",
            "offline": false,
            "description": "clone a visa2000 tag to a t55x7, q5/t5555 or em4305/4469 tag.",
            "usage": "lf visa2000 clone [-h] --cn <dec> [--q5] [--em]",
            "options": [
                "-h, --help this help",
                "--cn <dec> visa2k card id",
                "--q5 optional - specify writing to q5/t5555 tag",
                "--em optional - specify writing to em4305/4469 tag"
            ],
            "notes": [
                "lf visa2000 clone --cn 112233",
                "lf visa2000 clone --cn 112233 --q5 -> encode for q5/t5555 tag",
                "lf visa2000 clone --cn 112233 --em -> encode for em4305/4469"
            ]
        },
        "lf visa2000 sim": {
            "command": "lf visa2000 sim",
            "offline": false,
            "description": "enables simulation of visa2k card with specified card number. simulation runs until the button is pressed or another usb command is issued.",
            "usage": "lf visa2000 sim [-h] --cn <dec>",
            "options": [
                "-h, --help this help",
                "--cn <dec> visa2k card id"
            ],
            "notes": [
                "lf visa2000 sim --cn 1337"
            ]
        },
        "mem help": {
            "command": "mem help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- mem baudrate available offline: no set the baudrate for the spi flash memory communications. reading flash id will virtually always fail under 48mhz setting. unless you know what you are doing, please stay at 24mhz. if >= 24mhz, fastreads instead of reads instruction will be used.",
            "usage": "mem baudrate [-h] --mhz <24|48>",
            "options": [
                "-h, --help this help",
                "--mhz <24|48> spi baudrate in mhz"
            ],
            "notes": [
                "mem baudrate --mhz 48"
            ]
        },
        "mem dump": {
            "command": "mem dump",
            "offline": false,
            "description": "dumps flash memory on device into a file or view in console",
            "usage": "mem dump [-hv] [-o <dec>] [-l <dec>] [-f <filename>]... [-c <dec>]",
            "options": [
                "-h, --help this help",
                "-o, --offset <dec> offset in memory",
                "-l, --len <dec> length",
                "-v, --view view dump",
                "-f, --file <filename> file name",
                "-c, --cols <dec> column breaks (def 32)"
            ],
            "notes": [
                "mem dump -f myfile -> download all flashmem to file",
                "mem dump --view -o 262015 --len 128 -> display 128 bytes from offset 262015 (rsa sig)",
                "mem dump --view -f myfile -o 241664 --len 58 -> display 58 bytes from offset 241664 and save to file"
            ]
        },
        "mem info": {
            "command": "mem info",
            "offline": false,
            "description": "collect signature and verify it from flash memory",
            "usage": "mem info [-hsv] [-d <hex>] [-p <fn>]",
            "options": [
                "-h, --help this help",
                "-s, --sign create a signature",
                "-d <hex> flash memory id, 8 hex bytes",
                "-p, --pem <fn> key in pem format",
                "-v, --verbose verbose output"
            ],
            "notes": [
                "mem info"
            ]
        },
        "mem load": {
            "command": "mem load",
            "offline": false,
            "description": "loads binary file into flash memory on device warning: mem area to be written must have been wiped first ( this is already taken care when loading dictionaries )",
            "usage": "mem load [-hmit] [-o <dec>] [-f <filename>]...",
            "options": [
                "-h, --help this help",
                "-o, --offset <dec> offset in memory",
                "-m, --mifare, --mfc upload 6 bytes keys (mifare key dictionary)",
                "-i, --iclass upload 8 bytes keys (iclass key dictionary)",
                "-t, --t55xx upload 4 bytes keys (password dictionary)",
                "-f, --file <filename> file name"
            ],
            "notes": [
                "mem load -f myfile -> upload file myfile values at default offset 0",
                "mem load -f myfile -o 1024 -> upload file myfile values at offset 1024",
                "mem load -f mfc_default_keys -m -> upload mfc keys",
                "mem load -f t55xx_default_pwds -t -> upload t55xx passwords",
                "mem load -f iclass_default_keys -i -> upload iclass keys"
            ]
        },
        "mem wipe": {
            "command": "mem wipe",
            "offline": false,
            "description": "wipe flash memory on device, which fills it with 0xff [ !!! obs ] use with caution",
            "usage": "mem wipe [-h] [-p <dec>]",
            "options": [
                "-h, --help this help",
                "-p <dec> 0,1,2 page memory"
            ],
            "notes": [
                "mem wipe -p 0 -> wipes first page"
            ]
        },
        "mem spiffs help": {
            "command": "mem spiffs help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- mem spiffs copy available offline: no copy a file to another (destructively) in spiffs file system",
            "usage": "mem spiffs copy [-h] -s <fn> -d <fn>",
            "options": [
                "-h, --help this help",
                "-s, --src <fn> source file name",
                "-d, --dest <fn> destination file name"
            ],
            "notes": [
                "mem spiffs copy -s aaa.bin -d aaa_cpy.bin"
            ]
        },
        "mem spiffs check": {
            "command": "mem spiffs check",
            "offline": false,
            "description": "check/try to defrag faulty/fragmented spiffs file system",
            "usage": "mem spiffs check [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "mem spiffs check"
            ]
        },
        "mem spiffs dump": {
            "command": "mem spiffs dump",
            "offline": false,
            "description": "dumps device spiffs file to a local file size is handled by first sending a stat command against file to verify existence",
            "usage": "mem spiffs dump [-he] -s <fn> [-d <fn>]",
            "options": [
                "-h, --help this help",
                "-s, --src <fn> spiffs file to save",
                "-d, --dest <fn> file name to save to <w/o .bin>",
                "-e, --eml also save in eml format"
            ],
            "notes": [
                "mem spiffs dump -s tag.bin -> download binary file from device",
                "mem spiffs dump -s tag.bin -d aaa -e -> download tag.bin, save as aaa.eml format"
            ]
        },
        "mem spiffs info": {
            "command": "mem spiffs info",
            "offline": false,
            "description": "print file system info and usage statistics",
            "usage": "mem spiffs info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "mem spiffs info"
            ]
        },
        "mem spiffs mount": {
            "command": "mem spiffs mount",
            "offline": false,
            "description": "mount the spiffs file system if not already mounted",
            "usage": "mem spiffs mount [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "mem spiffs mount"
            ]
        },
        "mem spiffs remove": {
            "command": "mem spiffs remove",
            "offline": false,
            "description": "remove a file from spiffs filesystem",
            "usage": "mem spiffs remove [-h] -f <fn>",
            "options": [
                "-h, --help this help",
                "-f, --filename <fn> file to remove"
            ],
            "notes": [
                "mem spiffs remove -f lasttag.bin"
            ]
        },
        "mem spiffs rename": {
            "command": "mem spiffs rename",
            "offline": false,
            "description": "rename/move a file from spiffs filesystem.",
            "usage": "mem spiffs rename [-h] -s <fn> -d <fn>",
            "options": [
                "-h, --help this help",
                "-s, --src <fn> source file name",
                "-d, --dest <fn> destination file name"
            ],
            "notes": [
                "mem spiffs rename -s aaa.bin -d bbb.bin"
            ]
        },
        "mem spiffs test": {
            "command": "mem spiffs test",
            "offline": false,
            "description": "test spiffs operations, require wiping pages 0 and 1",
            "usage": "mem spiffs test [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "mem spiffs test"
            ]
        },
        "mem spiffs tree": {
            "command": "mem spiffs tree",
            "offline": false,
            "description": "print the flash memory file system tree",
            "usage": "mem spiffs tree [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "mem spiffs tree"
            ]
        },
        "mem spiffs unmount": {
            "command": "mem spiffs unmount",
            "offline": false,
            "description": "un-mount the spiffs file system",
            "usage": "mem spiffs unmount [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "mem spiffs unmount"
            ]
        },
        "mem spiffs upload": {
            "command": "mem spiffs upload",
            "offline": false,
            "description": "uploads binary-wise file into device file system warning: mem area to be written must have been wiped first. this is already taken care when loading dictionaries. file names can only be 32 bytes long on device spiffs",
            "usage": "mem spiffs upload [-h] -s <fn> -d <fn>",
            "options": [
                "-h, --help this help",
                "-s, --src <fn> source file name",
                "-d, --dest <fn> destination file name"
            ],
            "notes": [
                "mem spiffs upload -s local.bin -d dest.bin"
            ]
        },
        "mem spiffs view": {
            "command": "mem spiffs view",
            "offline": false,
            "description": "view a file on flash memory on devicer in console",
            "usage": "mem spiffs view [-h] -f <fn> [-c <dec>]",
            "options": [
                "-h, --help this help",
                "-f, --file <fn> spiffs file to view",
                "-c, --cols <dec> column breaks (def 32)"
            ],
            "notes": [
                "mem spiffs view -f tag.bin"
            ]
        },
        "mem spiffs wipe": {
            "command": "mem spiffs wipe",
            "offline": false,
            "description": "* * * warning * * * this command wipes all files on the device spiffs file system",
            "usage": "mem spiffs wipe [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "mem spiffs wipe"
            ]
        },
        "smart help": {
            "command": "smart help",
            "offline": true,
            "description": "help this help list list iso 7816 history upgrade upgrade sim module firmware --------------------------------------------------------------------------------------- smart list available offline: yes alias of `trace list -t 7816` with selected protocol data to annotate trace buffer you can load a trace from file (see `trace load -h`) or it be downloaded from device by default it accepts all other arguments of `trace list`. note that some might not be relevant for this specific protocol",
            "usage": "smart list [-h1fcrux] [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "smart list -f -> show frame delay times",
                "smart list -1 -> use trace buffer"
            ]
        },
        "smart info": {
            "command": "smart info",
            "offline": false,
            "description": "extract more detailed information from smart card.",
            "usage": "smart info [-hv]",
            "options": [
                "-h, --help this help",
                "-v, --verbose verbose"
            ],
            "notes": [
                "smart info -v"
            ]
        },
        "smart reader": {
            "command": "smart reader",
            "offline": false,
            "description": "act as a smart card reader.",
            "usage": "smart reader [-hv]",
            "options": [
                "-h, --help this help",
                "-v, --verbose verbose"
            ],
            "notes": [
                "smart reader"
            ]
        },
        "smart raw": {
            "command": "smart raw",
            "offline": false,
            "description": "sends raw bytes to card",
            "usage": "smart raw [-hrast0] -d <hex>",
            "options": [
                "-h, --help this help",
                "-r do not read response",
                "-a active smartcard without select (reset sc module)",
                "-s active smartcard with select (get atr)",
                "-t, --tlv executes tlv decoder if it possible",
                "-0 use protocol t=0",
                "-d, --data <hex> bytes to send"
            ],
            "notes": [
                "smart raw -s -0 -d 00a404000e315041592e5359532e4444463031 -> `1pay.sys.ddf01` ppse directory with get atr",
                "smart raw -0 -d 00a404000e325041592e5359532e4444463031 -> `2pay.sys.ddf01` ppse directory",
                "smart raw -0 -t -d 00a4040007a0000000041010 -> mastercard",
                "smart raw -0 -t -d 00a4040007a0000000031010 -> visa"
            ]
        },
        "smart upgrade": {
            "command": "smart upgrade",
            "offline": true,
            "description": "[=] ------------------------------------------------------------------- [!] warning - sim module firmware upgrade [!] a dangerous command, do wrong and you could brick the sim module [=] ------------------------------------------------------------------- upgrade rdv4.0 sim module firmware",
            "usage": "smart upgrade [-h] -f <filename>",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> firmware file name"
            ],
            "notes": [
                "smart upgrade -f sim011.bin"
            ]
        },
        "smart setclock": {
            "command": "smart setclock",
            "offline": false,
            "description": "set clock speed for smart card interface.",
            "usage": "smart setclock [-h] [--16mhz] [--8mhz] [--4mhz]",
            "options": [
                "-h, --help this help",
                "--16mhz 16 mhz clock speed",
                "--8mhz 8 mhz clock speed",
                "--4mhz 4 mhz clock speed"
            ],
            "notes": [
                "smart setclock --4mhz",
                "smart setclock --16mhz"
            ]
        },
        "smart brute": {
            "command": "smart brute",
            "offline": false,
            "description": "tries to bruteforce sfi, using a known list of aid's",
            "usage": "smart brute [-ht]",
            "options": [
                "-h, --help this help",
                "-t, --tlv executes tlv decoder if it possible"
            ],
            "notes": [
                "smart brute -t"
            ]
        },
        "script help": {
            "command": "script help",
            "offline": true,
            "description": "this is a feature to run lua/cmd/python scripts. you can place scripts within the luascripts/cmdscripts/pyscripts folders. --------------------------------------------------------------------------------------- script list available offline: yes list available lua, cmd and python scripts",
            "usage": "script list [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "script list"
            ]
        },
        "script run": {
            "command": "script run",
            "offline": true,
            "description": "run a lua, cmd or python script. if no extension it will search for lua/cmd/py extensions use `script list` to see available scripts",
            "usage": "script run [-h] <filename> [<params>]...",
            "options": [
                "-h, --help this help",
                "<filename> name of script to run",
                "<params> script parameters"
            ],
            "notes": [
                "script run my_script -h"
            ]
        },
        "trace help": {
            "command": "trace help",
            "offline": true,
            "description": "help this help list list protocol data in trace buffer load load trace from file save save trace buffer to file --------------------------------------------------------------------------------------- trace list available offline: yes annotate trace buffer with selected protocol data you can load a trace from file (see `trace load -h`) or it be downloaded from device by default",
            "usage": "trace list [-h1fcrux] [-t <string>]... [--dict <file>]...",
            "options": [
                "-h, --help this help",
                "-1, --buffer use data from trace buffer",
                "-f show frame delay times",
                "-c mark crc bytes",
                "-r show relative times (gap and duration)",
                "-u display times in microseconds instead of clock cycles",
                "-x show hexdump to convert to pcap(ng)",
                "or to import into wireshark using encapsulation type \"iso 14443\"",
                "-t, --type <string> protocol to annotate the trace",
                "--dict <file> use dictionary keys file"
            ],
            "notes": [
                "trace list -t raw -> just show raw data without annotations",
                "trace list -t 14a -> interpret as iso14443-a communications",
                "trace list -t thinfilm -> interpret as thinfilm communications",
                "trace list -t topaz -> interpret as topaz communications",
                "trace list -t mf -> interpret as mifare classic communications and decrypt crypto1 stream",
                "trace list -t des -> interpret as mifare desfire communications",
                "trace list -t 14b -> interpret as iso14443-b communications",
                "trace list -t 7816 -> interpret as iso7816-4 communications",
                "trace list -t 15 -> interpret as iso15693 communications",
                "trace list -t iclass -> interpret as iclass communications",
                "trace list -t legic -> interpret as legic communications",
                "trace list -t felica -> interpret as iso18092 / felica communications",
                "trace list -t hitag1 -> interpret as hitag1 communications",
                "trace list -t hitag2 -> interpret as hitag2 communications",
                "trace list -t hitags -> interpret as hitags communications",
                "trace list -t lto -> interpret as lto-cm communications",
                "trace list -t cryptorf -> interpret as cryptorf communitcations",
                "trace list -t mf --dict <mfc_default_keys> -> use dictionary keys file",
                "trace list -t 14a -f -> show frame delay times",
                "trace list -t 14a -1 -> use trace buffer"
            ]
        },
        "trace load": {
            "command": "trace load",
            "offline": true,
            "description": "load protocol data from binary file to trace buffer file extension is <.trace>",
            "usage": "trace load [-h] [-f <filename>]...",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> trace file to load"
            ],
            "notes": [
                "trace load -f mytracefile -> w/o file extension"
            ]
        },
        "trace save": {
            "command": "trace save",
            "offline": true,
            "description": "save protocol data from trace buffer to binary file file extension is <.trace>",
            "usage": "trace save [-h] [-f <filename>]...",
            "options": [
                "-h, --help this help",
                "-f, --file <filename> trace file to save"
            ],
            "notes": [
                "trace save -f mytracefile -> w/o file extension"
            ]
        },
        "usart help": {
            "command": "usart help",
            "offline": true,
            "description": "help this help --------------------------------------------------------------------------------------- usart btpin available offline: no change bt add-on pin. warning: this requires 1) btpower to be turned on 2) bt add-on to not be connected => the add-on blue led must blink",
            "usage": "usart btpin [-h] -p <dec>",
            "options": [
                "-h, --help this help",
                "-p, --pin <dec> desired pin number (4 digits)"
            ],
            "notes": [
                "usart btpin -p 1234"
            ]
        },
        "usart btfactory": {
            "command": "usart btfactory",
            "offline": false,
            "description": "reset bt add-on to factory settings this requires 1) btpower to be turned on 2) bt add-on to not be connected => the add-on blue led must blink warning: process only if strictly needed!",
            "usage": "usart btfactory [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "usart btfactory"
            ]
        },
        "usart tx": {
            "command": "usart tx",
            "offline": false,
            "description": "send string over usart. warning: it will have side-effects if used in usart host mode!",
            "usage": "usart tx [-h] -d <string>",
            "options": [
                "-h, --help this help",
                "-d, --data <string> string to send"
            ],
            "notes": [
                "usart tx -d \"at+version\"",
                "usart tx -d \"at+version\\r\\n\""
            ]
        },
        "usart rx": {
            "command": "usart rx",
            "offline": false,
            "description": "receive string over usart. warning: it will have side-effects if used in usart host mode!",
            "usage": "usart rx [-h] [-t <dec>]",
            "options": [
                "-h, --help this help",
                "-t, --timeout <dec> timeout in ms, default is 0ms"
            ],
            "notes": [
                "usart rx -t 2000 -> 2 second timeout"
            ]
        },
        "usart txrx": {
            "command": "usart txrx",
            "offline": false,
            "description": "send string over usart and wait for response. warning: if used in usart host mode, you can only send at commands to add-on when bt connection is not established (led needs to be blinking) any other usage in usart host mode will have side-effects!",
            "usage": "usart txrx [-h] [-t <dec>] -d <string>",
            "options": [
                "-h, --help this help",
                "-t, --timeout <dec> timeout in ms, default is 1000 ms",
                "-d, --data <string> string to send"
            ],
            "notes": [
                "usart txrx -d \"at+version\" -> talking to bt add-on (when no connection)",
                "usart txrx -t 2000 -d \"at+somestuff\\r\\n\" -> talking to a target requiring longer time and end-of-line chars"
            ]
        },
        "usart txhex": {
            "command": "usart txhex",
            "offline": false,
            "description": "send bytes over usart. warning: it will have side-effects if used in usart host mode!",
            "usage": "usart txhex [-h] -d <hex>",
            "options": [
                "-h, --help this help",
                "-d, --data <hex> bytes to send"
            ],
            "notes": [
                "usart txhex -d 504d33620a80000000010100f09f988ef09fa5b36233"
            ]
        },
        "usart rxhex": {
            "command": "usart rxhex",
            "offline": false,
            "description": "receive bytes over usart. warning: it will have side-effects if used in usart host mode!",
            "usage": "usart rxhex [-h] [-t <dec>]",
            "options": [
                "-h, --help this help",
                "-t, --timeout <dec> timeout in ms, default is 0ms"
            ],
            "notes": [
                "usart rxhex -t 2000 -> 2 second timeout"
            ]
        },
        "usart config": {
            "command": "usart config",
            "offline": false,
            "description": "configure usart. warning: it will have side-effects if used in usart host mode! the changes are not permanent, restart proxmark3 to get default settings back.",
            "usage": "usart config [-hneo] [-b <dec>]",
            "options": [
                "-h, --help this help",
                "-b, --baud <dec> baudrate",
                "-n, --none mone parity",
                "-e, --even even parity",
                "-o, --odd odd parity"
            ],
            "notes": [
                "usart config -b 9600",
                "usart config -b 9600 --none",
                "usart config -e"
            ]
        },
        "wiegand help": {
            "command": "wiegand help",
            "offline": true,
            "description": "help this help list list available wiegand formats encode encode to wiegand raw hex (currently for hid prox) decode convert raw hex to decoded wiegand format (currently for hid prox) --------------------------------------------------------------------------------------- wiegand list available offline: yes list available wiegand formats",
            "usage": "wiegand info [-h]",
            "options": [
                "-h, --help this help"
            ],
            "notes": [
                "wiegand list"
            ]
        },
        "wiegand encode": {
            "command": "wiegand encode",
            "offline": true,
            "description": "encode wiegand formatted number to raw hex",
            "usage": "wiegand encode [-h] [--fc <dec>] --cn <dec> [--issue <dec>] [--oem <dec>] [-w <format>] [--pre]",
            "options": [
                "-h, --help this help",
                "--fc <dec> facility number",
                "--cn <dec> card number",
                "--issue <dec> issue level",
                "--oem <dec> oem code",
                "-w, --wiegand <format> see `wiegand list` for available formats",
                "--pre add hid proxii preamble to wiegand output"
            ],
            "notes": [
                "wiegand encode --fc 101 --cn 1337 -> show all formats",
                "wiegand encode -w h10301 --fc 101 --cn 1337 -> h10301 format"
            ]
        },
        "wiegand decode": {
            "command": "wiegand decode",
            "offline": true,
            "description": "decode raw hex or binary to wiegand format",
            "usage": "wiegand decode [-h] [-r <hex>]... [-b <bin>]",
            "options": [
                "-h, --help this help",
                "-r, --raw <hex> raw hex to be decoded",
                "-b, --bin <bin> binary string to be decoded"
            ],
            "notes": [
                "wiegand decode --raw 2006f623ae"
            ]
        }
    }
}